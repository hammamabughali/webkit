var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var kr3m;
(function (kr3m) {
    kr3m.VERSION = "1.7.1.11";
})(kr3m || (kr3m = {}));
if (!Function.prototype.bind) {
    Function.prototype.bind = function (oThis) {
        if (typeof this !== "function")
            throw new TypeError("Function.prototype.bind could not be set on legacy browser");
        var aArgs = Array.prototype.slice.call(arguments, 1);
        var fToBind = this;
        var fNOP = function () { };
        var fBound = function () {
            return fToBind.apply(this instanceof fNOP && oThis ? this : oThis, aArgs.concat(Array.prototype.slice.call(arguments)));
        };
        fNOP.prototype = this.prototype;
        fBound.prototype = new fNOP();
        return fBound;
    };
}
if (!Array.isArray) {
    Array.isArray = function (arg) {
        return Object.prototype.toString.call(arg) === "[object Array]";
    };
}
if (!Array.prototype.indexOf) {
    Array.prototype.indexOf = function (searchElement, fromIndex) {
        var k;
        if (this == null)
            throw new TypeError('"this" is null or not defined');
        var O = Object(this);
        var len = O.length >>> 0;
        if (len === 0)
            return -1;
        var n = +fromIndex || 0;
        if (Math.abs(n) === Infinity)
            n = 0;
        if (n >= len)
            return -1;
        k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
        while (k < len) {
            if (k in O && O[k] === searchElement)
                return k;
            k++;
        }
        return -1;
    };
}
if (!Array.prototype.forEach) {
    Array.prototype.forEach = function (callback, thisArg) {
        var T, k;
        if (this == null)
            throw new TypeError(" this is null or not defined");
        var O = Object(this);
        var len = O.length >>> 0;
        if (typeof callback !== "function")
            throw new TypeError(callback + " is not a function");
        if (arguments.length > 1)
            T = thisArg;
        k = 0;
        while (k < len) {
            var kValue;
            if (k in O) {
                kValue = O[k];
                callback.call(T, kValue, k, O);
            }
            k++;
        }
    };
}
if (!Array.prototype["find"]) {
    Object.defineProperty(Array.prototype, "find", {
        value: function (predicate) {
            if (this == null)
                throw new TypeError("this is null or not defined");
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== "function")
                throw new TypeError("predicate must be a function");
            var thisArg = arguments[1];
            var k = 0;
            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o))
                    return kValue;
                k++;
            }
            return undefined;
        }
    });
}
if (!Array.prototype["findIndex"]) {
    Object.defineProperty(Array.prototype, "findIndex", {
        value: function (predicate) {
            if (this == null)
                throw new TypeError("this is null or not defined");
            var o = Object(this);
            var len = o.length >>> 0;
            if (typeof predicate !== "function")
                throw new TypeError("predicate must be a function");
            var thisArg = arguments[1];
            var k = 0;
            while (k < len) {
                var kValue = o[k];
                if (predicate.call(thisArg, kValue, k, o))
                    return k;
                ++k;
            }
            return -1;
        }
    });
}
if (!Array.prototype.filter) {
    Array.prototype.filter = function (fun) {
        'use strict';
        if (this === void 0 || this === null)
            throw new TypeError();
        var t = Object(this);
        var len = t.length >>> 0;
        if (typeof fun !== "function")
            throw new TypeError();
        var res = [];
        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t) {
                var val = t[i];
                if (fun.call(thisArg, val, i, t))
                    res.push(val);
            }
        }
        return res;
    };
}
if (typeof Object.create != 'function') {
    Object.create = (function () {
        var Temp = function () { };
        return function (prototype) {
            if (arguments.length > 1)
                throw Error('Second argument not supported');
            if (typeof prototype != 'object')
                throw TypeError('Argument must be an object');
            Temp.prototype = prototype;
            var result = new Temp();
            Temp.prototype = null;
            return result;
        };
    })();
}
if (!Object.keys) {
    Object.keys = (function () {
        'use strict';
        var hasOwnProperty = Object.prototype.hasOwnProperty;
        var hasDontEnumBug = !({ toString: null }).propertyIsEnumerable('toString');
        var dontEnums = [
            'toString',
            'toLocaleString',
            'valueOf',
            'hasOwnProperty',
            'isPrototypeOf',
            'propertyIsEnumerable',
            'constructor'
        ];
        var dontEnumsLength = dontEnums.length;
        return function (obj) {
            if (typeof obj !== 'object' && (typeof obj !== 'function' || obj === null))
                throw new TypeError('Object.keys called on non-object');
            var result = [];
            for (var prop in obj) {
                if (hasOwnProperty.call(obj, prop))
                    result.push(prop);
            }
            if (hasDontEnumBug) {
                for (var i = 0; i < dontEnumsLength; ++i) {
                    if (hasOwnProperty.call(obj, dontEnums[i]))
                        result.push(dontEnums[i]);
                }
            }
            return result;
        };
    }());
}
if (typeof Element !== "undefined" && !("remove" in Element.prototype)) {
    Element.prototype.remove = function () {
        if (this.parentNode)
            this.parentNode.removeChild(this);
    };
}
var kr3m;
(function (kr3m) {
    kr3m.ANDROID = "ANDROID";
    kr3m.IOS = "IOS";
    kr3m.MAX_TAB_INDEX = 0x7fff;
    kr3m.PASSWORD_SECURITY_NONE = 0;
    kr3m.PASSWORD_SECURITY_LOW = 1;
    kr3m.PASSWORD_SECURITY_MEDIUM = 2;
    kr3m.PASSWORD_SECURITY_HIGH = 3;
    kr3m.FORMAT_TIME = "FORMAT_TIME";
    kr3m.FORMAT_DATE = "FORMAT_DATE";
    kr3m.FORMAT_DATETIME = "FORMAT_DATETIME";
    kr3m.SUCCESS = "SUCCESS";
    kr3m.ERROR_CANCELLED = "ERROR_CANCELLED";
    kr3m.ERROR_DATABASE = "ERROR_DATABASE";
    kr3m.ERROR_DENIED = "ERROR_DENIED";
    kr3m.ERROR_EMPTY_DATA = "ERROR_EMPTY_DATA";
    kr3m.ERROR_EXPIRED = "ERROR_EXPIRED";
    kr3m.ERROR_EXTERNAL = "ERROR_EXTERNAL";
    kr3m.ERROR_FILE = "ERROR_FILE";
    kr3m.ERROR_INPUT = "ERROR_INPUT";
    kr3m.ERROR_INTERNAL = "ERROR_INTERNAL";
    kr3m.ERROR_FLOOD = "ERROR_FLOOD";
    kr3m.ERROR_NETWORK = "ERROR_NETWORK";
    kr3m.ERROR_NOT_SUPPORTED = "ERROR_NOT_SUPPORTED";
    kr3m.ERROR_NYI = "ERROR_NYI";
    kr3m.ERROR_PARAMS = "ERROR_PARAMS";
    kr3m.ERROR_PARTIAL = "ERROR_PARTIAL";
    kr3m.ERROR_PENDING = "ERROR_PENDING";
    kr3m.ERROR_PERMISSION = "ERROR_PERMISSION";
    kr3m.ERROR_REQUIRED = "ERROR_REQUIRED";
    kr3m.ERROR_TAKEN = "ERROR_TAKEN";
    kr3m.ERROR_TIMEOUT = "ERROR_TIMEOUT";
    kr3m.ERROR_UPLOAD_COUNT = "ERROR_UPLOAD_COUNT";
    kr3m.ERROR_UPLOAD_SIZE = "ERROR_UPLOAD_SIZE";
    kr3m.ERROR_UPLOAD_DIMENSIONS = "ERROR_UPLOAD_DIMENSIONS";
    kr3m.ERROR_UPLOAD_TYPE = "ERROR_UPLOAD_TYPE";
    kr3m.ERROR_VERSIONS = "ERROR_VERSIONS";
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var services;
    (function (services) {
        var CallbackResult = (function () {
            function CallbackResult(status, data) {
                this.status = status;
                this.success = this.status == kr3m.SUCCESS;
                this.data = data;
            }
            return CallbackResult;
        }());
        services.CallbackResult = CallbackResult;
    })(services = kr3m.services || (kr3m.services = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    kr3m.REGEX_CRON = /((\S+)\s+(\S+)\s+(\S+)\s+(\S+)\s+(\S+)(?:\s+(\S+))?)\s+(.+)/;
    kr3m.REGEX_CRON_GROUPS = ["pattern", "minute", "hour", "dayOfMonth", "month", "dayOfWeek", "year", "command"];
    kr3m.REGEX_DATA_URL = /^data:([^;]+)(?:;(base64)),(.+)$/;
    kr3m.REGEX_DATA_URL_GROUPS = ["mimeType", "encoding", "payload"];
    kr3m.REGEX_DEVICE_ID = /^[A-Z]+:/;
    kr3m.REGEX_EMAIL = /^[0-9a-zA-Z\._\-]+@[0-9a-zA-Z][0-9a-zA-Z\-\.]+\.[a-zA-Z]+$/;
    kr3m.REGEX_FLOAT = /^\-?\d+[,\.]?\d*$/;
    kr3m.REGEX_INTEGER = /^\-?\d+$/;
    kr3m.REGEX_LOCALE = /^([a-z][a-z])[_\-]?([A-Z][A-Z])$/;
    kr3m.REGEX_LOCALE_GROUPS = ["languageId", "countryId"];
    kr3m.REGEX_URL = /^(?:(http|https|ftp)\:)?(?:\/\/(?:(\w+):(\w+)@)?([^\/:#?]+)(?::(\d+))?)?([^\?#"':]*)(?:\?([^#"':]*))?(?:#(.*))?$/;
    kr3m.REGEX_URL_GROUPS = ["protocol", "user", "password", "domain", "port", "resource", "query", "hash"];
    kr3m.REGEX_USERNAME = /^[^<>"'&;\/]+$/;
    kr3m.REGEX_WORD_SEPERATORS = /[\s!§*@$%\/\(\)\{\}=\#\[\]\\\?´`\"\'+\:;,\.<>|€\u0000]+/;
    kr3m.REGEX_TIMESTAMP = /^(\d\d\d\d)\-(\d\d)\-(\d\d)(?:T| )(\d\d)\:(\d\d)(?:\:(\d\d)(?:\.(\d\d\d))?)?(Z|[\+\-]\d\d\:\d\d)?$/;
    kr3m.REGEX_TIMESTAMP_GROUPS = ["year", "month", "day", "hours", "minutes", "seconds", "milliseconds", "timezone"];
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var StringEx = (function () {
            function StringEx() {
            }
            StringEx.captureNamed = function (text, regex, groupNames) {
                var matches = text.match(regex);
                if (!matches)
                    return undefined;
                var result = {};
                var l = Math.min(groupNames.length, matches.length - 1);
                for (var i = 0; i < l; ++i)
                    result[groupNames[i]] = matches[i + 1];
                return result;
            };
            StringEx.captureNamedGlobal = function (text, regex, groupNames) {
                var results = [];
                var match = regex.exec(text);
                while (match) {
                    var result = {};
                    var l = Math.min(groupNames.length, match.length - 1);
                    for (var i = 0; i < l; ++i)
                        result[groupNames[i]] = match[i + 1];
                    results.push(result);
                    match = regex.exec(text);
                }
                return results;
            };
            StringEx.stripBom = function (text) {
                if (text.slice(0, StringEx.BOM.length) == StringEx.BOM)
                    return text.slice(StringEx.BOM.length);
                else
                    return text;
            };
            StringEx.splitNoQuoted = function (text, seperator, openingQuotes, closingQuotes) {
                if (seperator === void 0) { seperator = ","; }
                if (openingQuotes === void 0) { openingQuotes = ["\"", "'"]; }
                closingQuotes = closingQuotes || openingQuotes;
                if (openingQuotes.length != closingQuotes.length)
                    throw new Error("openingQuotes.length doesn't match closingQuotes.length");
                var quote = -1;
                var parts = [];
                var offset = 0;
                for (var i = 0; i < text.length; ++i) {
                    if (quote < 0) {
                        if (text.slice(i, i + seperator.length) == seperator) {
                            parts.push(text.slice(offset, i));
                            offset = i + seperator.length;
                            i = offset - 1;
                            continue;
                        }
                        for (var j = 0; j < openingQuotes.length; ++j) {
                            if (text.slice(i, i + openingQuotes[j].length) == openingQuotes[j]) {
                                quote = j;
                                break;
                            }
                        }
                    }
                    else {
                        if (text.slice(i, i + closingQuotes[quote].length) == closingQuotes[quote])
                            quote = -1;
                    }
                }
                if (offset < text.length)
                    parts.push(text.slice(offset));
                return parts;
            };
            StringEx.camelback = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                var parts = [];
                for (var i = 0; i < values.length; ++i) {
                    var text = values[i].toString();
                    text = text.replace(/\W+/g, "_");
                    parts = parts.concat(text.split("_"));
                }
                if (parts.length > 0)
                    parts[0] = parts[0].toLowerCase();
                for (var i = 1; i < parts.length; ++i)
                    parts[i] = parts[i].slice(0, 1).toUpperCase() + parts[i].slice(1).toLowerCase();
                return parts.join("");
            };
            StringEx.replaceSuccessive = function (haystack, needle, replacement) {
                var old;
                while (old != haystack) {
                    old = haystack;
                    haystack = haystack.replace(needle, replacement);
                }
                return haystack;
            };
            StringEx.joinAssoc = function (obj, seperator, assignOperator, valueFormatter) {
                if (seperator === void 0) { seperator = "&"; }
                if (assignOperator === void 0) { assignOperator = "="; }
                var keys = Object.keys(obj);
                if (valueFormatter)
                    return keys.map(function (key) { return key + assignOperator + valueFormatter(obj[key]); }).join(seperator);
                else
                    return keys.map(function (key) { return key + assignOperator + obj[key]; }).join(seperator);
            };
            StringEx.splitAssoc = function (text, seperator, assignOperator, valueFormatter) {
                if (seperator === void 0) { seperator = "&"; }
                if (assignOperator === void 0) { assignOperator = "="; }
                var result = {};
                var parts = text.split(seperator);
                for (var i = 0; i < parts.length; ++i) {
                    var pos = parts[i].indexOf(assignOperator);
                    if (pos < 0)
                        continue;
                    var key = parts[i].substring(0, pos);
                    var value = parts[i].substring(pos + assignOperator.length);
                    result[key] = valueFormatter ? valueFormatter(value) : value;
                }
                return result;
            };
            StringEx.joinKeys = function (obj, seperator) {
                if (seperator === void 0) { seperator = ","; }
                var parts = [];
                for (var i in obj)
                    parts.push(i);
                return parts.join(seperator);
            };
            StringEx.joinValues = function (obj, seperator) {
                if (seperator === void 0) { seperator = ","; }
                var parts = [];
                for (var i in obj)
                    parts.push(obj[i]);
                return parts.join(seperator);
            };
            StringEx.getBefore = function (text, needle, fromFront) {
                if (fromFront === void 0) { fromFront = true; }
                var pos = fromFront ? text.indexOf(needle) : text.lastIndexOf(needle);
                return (pos > 0) ? text.substr(0, pos) : text;
            };
            StringEx.getAfter = function (text, needle, fromFront) {
                if (fromFront === void 0) { fromFront = true; }
                var pos = fromFront ? text.indexOf(needle) : text.lastIndexOf(needle);
                return (pos >= 0) ? text.substr(pos + needle.length) : text;
            };
            StringEx.flip = function (test) {
                var result = "";
                for (var i = test.length - 1; i >= 0; --i)
                    result += test.charAt(i);
                return result;
            };
            StringEx.literalReplace = function (haystack, needle, newValue) {
                return haystack.split(needle).join(newValue);
            };
            StringEx.parseIntSafe = function (text, errorResult) {
                if (errorResult === void 0) { errorResult = 0; }
                if (text === null || typeof text === "undefined")
                    return errorResult;
                var value = parseInt(text, 10);
                if (isNaN(value))
                    value = errorResult;
                return value;
            };
            StringEx.parseFloatSafe = function (text, errorResult) {
                if (errorResult === void 0) { errorResult = 0; }
                if (text === null || typeof text === "undefined")
                    return errorResult;
                var value = parseFloat(text.replace(/,/g, "."));
                if (isNaN(value))
                    value = errorResult;
                return value;
            };
            StringEx.format = function (text) {
                var values = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    values[_i - 1] = arguments[_i];
                }
                var result = "";
                var j = 0;
                var specs = { "%": true, "n": true, "j": true, "s": true };
                for (var i = 0; i < text.length; ++i) {
                    var token = text.charAt(i);
                    if (token == "%") {
                        var k = i + 1;
                        do {
                            if (k >= text.length)
                                return result;
                            var spec = text.charAt(k++);
                        } while (!specs[spec]);
                        var options = text.slice(i + 1, k - 1);
                        var matches = options.match(/^([0\-\+hb]*)(\d*)\.?(\d*)([hb])*$/);
                        if (!matches)
                            continue;
                        var padWith = (matches[1].indexOf("0") >= 0) ? "0" : " ";
                        var alignLeft = matches[1].indexOf("-") >= 0;
                        var alignCenter = matches[1].indexOf("+") >= 0;
                        var length = StringEx.parseIntSafe(matches[2]);
                        var precision = StringEx.parseIntSafe(matches[3]);
                        var base = 10;
                        if ((matches[1] && matches[1].indexOf("h") >= 0) || (matches[4] && matches[4].indexOf("h") >= 0))
                            base = 16;
                        else if ((matches[1] && matches[1].indexOf("b") >= 0) || (matches[4] && matches[4].indexOf("b") >= 0))
                            base = 2;
                        var value;
                        switch (spec) {
                            case "%":
                                if (options == "") {
                                    result += "%";
                                    ++i;
                                    continue;
                                }
                                break;
                            case "n":
                                value = (precision > 0 ? values[j++].toFixed(precision) : values[j++]).toString(base);
                                break;
                            case "s":
                                value = values[j++].toString();
                                break;
                            case "j":
                                value = util.Json.encode(values[j++]);
                                break;
                        }
                        value = value || "";
                        if (alignCenter) {
                            var odd = false;
                            while (value.length < length) {
                                if (odd)
                                    value += padWith;
                                else
                                    value = padWith + value;
                                odd = !odd;
                            }
                        }
                        else if (alignLeft) {
                            while (value.length < length)
                                value += padWith;
                        }
                        else {
                            while (value.length < length)
                                value = padWith + value;
                        }
                        result += value;
                        i = k - 1;
                    }
                    else {
                        result += token;
                    }
                }
                return result;
            };
            StringEx.getVersionParts = function (version, padToLength) {
                if (padToLength === void 0) { padToLength = 0; }
                var parts = version.split(".").map(function (part) { return StringEx.parseIntSafe(part); });
                while (parts.length < padToLength)
                    parts.push(0);
                return parts;
            };
            StringEx.splitArguments = function (line) {
                var args = line.split(" ");
                for (var i = 0; i < args.length; ++i) {
                    var token = args[i].slice(0, 1);
                    if (token == "'" || token == '"') {
                        for (var j = i + 1; j < args.length; ++j) {
                            args[i] += " " + args[j];
                            if (args[j].slice(-1) == token)
                                break;
                        }
                        args.splice(i + 1, j - i);
                    }
                    else {
                        args[i] = args[i].trim();
                    }
                    if (args[i] == "")
                        args.splice(i--, 1);
                }
                return args;
            };
            StringEx.getNamedArguments = function (params, mapping) {
                if (mapping === void 0) { mapping = {}; }
                var result = { values: [] };
                for (var i = 0; i < params.length; ++i) {
                    var meta = mapping[params[i]];
                    if (meta) {
                        var name = meta.name || params[i];
                        var count = meta.count || 0;
                        if (count == 0) {
                            result[name] = params[i];
                        }
                        else if (count == 1) {
                            result[name] = params[++i];
                        }
                        else {
                            result[name] = [];
                            for (var j = 0; j < count; ++j)
                                result[name].push(params[++i]);
                        }
                    }
                    else {
                        result.values.push(params[i]);
                    }
                }
                return result;
            };
            StringEx.wrapText = function (text, lineLength, prefix, suffix) {
                if (lineLength === void 0) { lineLength = 80; }
                if (prefix === void 0) { prefix = ""; }
                if (suffix === void 0) { suffix = ""; }
                if (lineLength < 0)
                    return text;
                var words = text.split(" ");
                if (words.length == 0)
                    return text;
                var result = "";
                var line = words[0];
                var count = words.length;
                for (var i = 1; i < count; ++i) {
                    if (line.length + 1 + words[i].length <= lineLength) {
                        line += " " + words[i];
                    }
                    else {
                        result += prefix + line + suffix + "\n";
                        line = words[i];
                    }
                }
                result += prefix + line + suffix;
                return result;
            };
            StringEx.sortCaseIndependant = function (items) {
                items.sort(function (a, b) { return a.trim().localeCompare(b.trim()); });
            };
            StringEx.getUnitString = function (value, units, maxUnits) {
                if (maxUnits === void 0) { maxUnits = 0; }
                if (value == 0)
                    return "0" + (Object.keys(units)[0] || "");
                var parts = [];
                for (var unit in units) {
                    var amount = value % units[unit];
                    if (amount > 0)
                        parts.unshift(amount + unit);
                    value = Math.floor(value / units[unit]);
                }
                if (maxUnits > 0)
                    parts = parts.slice(0, maxUnits);
                return parts.join(" ");
            };
            StringEx.bigNumber = function (value, maxUnits) {
                if (maxUnits === void 0) { maxUnits = 0; }
                var units = { "": 1000, k: 1000, M: 1000, G: 1000, T: 1000, P: 1000, E: 1000, Z: 1000, Y: 1000, ALOT: 100000000 };
                return StringEx.getUnitString(value, units, maxUnits);
            };
            StringEx.getSizeString = function (size, useDual, maxUnits) {
                if (useDual === void 0) { useDual = true; }
                if (maxUnits === void 0) { maxUnits = 0; }
                var units = useDual
                    ? { B: 1024, kB: 1024, MB: 1024, GB: 1024, TB: 1024, PB: 1024, EB: 1024, ZB: 1024, YB: 1024, ALOT: 100000000 }
                    : { B: 1000, kB: 1000, MB: 1000, GB: 1000, TB: 1000, PB: 1000, EB: 1000, ZB: 1000, YB: 1000, ALOT: 100000000 };
                return StringEx.getUnitString(size, units, maxUnits);
            };
            StringEx.getDurationString = function (duration, maxUnits) {
                if (maxUnits === void 0) { maxUnits = 0; }
                var units = { ms: 1000, s: 60, m: 60, h: 24, d: 7, w: 52, y: 100, centuries: 10, millenia: 1000, ages: 100000000 };
                return StringEx.getUnitString(duration, units, maxUnits);
            };
            StringEx.BOM = "\ufeff";
            return StringEx;
        }());
        util.StringEx = StringEx;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Dates = (function () {
            function Dates() {
            }
            Dates.getDateString = function (date, useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                if (useUTC) {
                    var result = date.getUTCFullYear() + "-";
                    var month = date.getUTCMonth() + 1;
                    result += ((month < 10) ? "0" + month : "" + month);
                    var day = date.getUTCDate();
                    result += "-" + ((day < 10) ? "0" + day : "" + day);
                    return result;
                }
                else {
                    var result = date.getFullYear() + "-";
                    var month = date.getMonth() + 1;
                    result += ((month < 10) ? "0" + month : "" + month);
                    var day = date.getDate();
                    result += "-" + ((day < 10) ? "0" + day : "" + day);
                    return result;
                }
            };
            Dates.getTimeString = function (date, useUTC, addMilliseconds) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                if (addMilliseconds === void 0) { addMilliseconds = false; }
                if (useUTC) {
                    var result = "";
                    var hours = date.getUTCHours();
                    result += ((hours < 10) ? "0" + hours : "" + hours);
                    var minutes = date.getUTCMinutes();
                    result += ":" + ((minutes < 10) ? "0" + minutes : "" + minutes);
                    var seconds = date.getUTCSeconds();
                    result += ":" + ((seconds < 10) ? "0" + seconds : "" + seconds);
                    if (addMilliseconds) {
                        var millis = date.getUTCMilliseconds();
                        result += "." + ((millis < 10) ? "00" + millis : (millis < 100) ? "0" + millis : "" + millis);
                    }
                    return result + "Z";
                }
                else {
                    var result = "";
                    var hours = date.getHours();
                    result += ((hours < 10) ? "0" + hours : "" + hours);
                    var minutes = date.getMinutes();
                    result += ":" + ((minutes < 10) ? "0" + minutes : "" + minutes);
                    var seconds = date.getSeconds();
                    result += ":" + ((seconds < 10) ? "0" + seconds : "" + seconds);
                    if (addMilliseconds) {
                        var millis = date.getMilliseconds();
                        result += "." + ((millis < 10) ? "00" + millis : (millis < 100) ? "0" + millis : "" + millis);
                    }
                    return result;
                }
            };
            Dates.getDateFromDateTimeString = function (value) {
                if (!value || typeof value != "string")
                    return null;
                var matches = util.StringEx.captureNamed(value, kr3m.REGEX_TIMESTAMP, kr3m.REGEX_TIMESTAMP_GROUPS);
                if (!matches)
                    return null;
                matches.seconds = matches.seconds || "0";
                matches.milliseconds = matches.milliseconds || "0";
                var date = new Date();
                if (matches.timezone == "Z") {
                    date.setUTCFullYear(parseInt(matches.year, 10), parseInt(matches.month, 10) - 1, parseInt(matches.day, 10));
                    date.setUTCHours(parseInt(matches.hours, 10), parseInt(matches.minutes, 10), parseInt(matches.seconds, 10), parseInt(matches.milliseconds, 10));
                }
                else if (matches.timezone && matches.timezone.length == 6) {
                    var hourOffset = parseInt(matches.timezone.slice(1, 3), 10);
                    var minuteOffset = parseInt(matches.timezone.slice(4, 5), 10);
                    if (matches.timezone.charAt(0) == "-") {
                        hourOffset *= -1;
                        minuteOffset *= -1;
                    }
                    date.setUTCFullYear(parseInt(matches.year, 10), parseInt(matches.month, 10) - 1, parseInt(matches.day, 10));
                    date.setUTCHours(parseInt(matches.hours, 10) - hourOffset, parseInt(matches.minutes, 10) - minuteOffset, parseInt(matches.seconds, 10), parseInt(matches.milliseconds, 10));
                }
                else {
                    date.setFullYear(parseInt(matches.year, 10), parseInt(matches.month, 10) - 1, parseInt(matches.day, 10));
                    date.setHours(parseInt(matches.hours, 10), parseInt(matches.minutes, 10), parseInt(matches.seconds, 10), parseInt(matches.milliseconds, 10));
                }
                return date;
            };
            Dates.getDateFromDateString = function (value) {
                if (!value || typeof value != "string")
                    return null;
                var matches = value.match(/^(\d\d\d\d)\-(\d\d)\-(\d\d)$/);
                if (!matches)
                    return null;
                var date = new Date();
                date.setFullYear(parseInt(matches[1], 10), parseInt(matches[2], 10) - 1, parseInt(matches[3], 10));
                date.setHours(0, 0, 0, 0);
                return date;
            };
            Dates.getDateTimeString = function (date, useUTC, addMilliseconds) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                if (addMilliseconds === void 0) { addMilliseconds = false; }
                return this.getDateString(date, useUTC) + " " + this.getTimeString(date, useUTC, addMilliseconds);
            };
            Dates.getToday = function (useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                return this.getDateString(new Date(), useUTC);
            };
            Dates.getYesterday = function (useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                var date = new Date();
                date.setUTCDate(date.getUTCDate() - 1);
                return this.getDateString(date, useUTC);
            };
            Dates.getTomorrow = function (useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                var date = new Date();
                date.setUTCDate(date.getUTCDate() + 1);
                return this.getDateString(date, useUTC);
            };
            Dates.getNow = function (useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                return this.getDateTimeString(new Date(), useUTC);
            };
            Dates.areSameDay = function (a, b) {
                if (a.getUTCFullYear() != b.getUTCFullYear())
                    return false;
                if (a.getUTCMonth() != b.getUTCMonth())
                    return false;
                if (a.getUTCDate() != b.getUTCDate())
                    return false;
                return true;
            };
            Dates.getSomeDaysAgo = function (date, count) {
                var newDate = new Date(date.getTime());
                newDate.setUTCDate(newDate.getUTCDate() - count);
                return newDate;
            };
            Dates.getSomeMonthsAgo = function (date, count) {
                var newDate = new Date(date.getTime());
                newDate.setUTCMonth(newDate.getUTCMonth() - count);
                return newDate;
            };
            Dates.getAgeInYears = function (birthday) {
                if (!birthday)
                    return -1;
                var now = new Date();
                var years = now.getFullYear() - birthday.getFullYear();
                var months = now.getMonth() - birthday.getMonth();
                var days = now.getDate() - birthday.getDate();
                var age = years;
                if ((months < 0) || (months == 0 && days < 0))
                    --age;
                return age;
            };
            Dates.max = function () {
                var dates = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    dates[_i] = arguments[_i];
                }
                if (dates.length == 0)
                    return null;
                var result = dates[0];
                for (var i = 1; i < dates.length; ++i)
                    if (dates[i] > result)
                        result = dates[i];
                return result;
            };
            Dates.min = function () {
                var dates = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    dates[_i] = arguments[_i];
                }
                if (dates.length == 0)
                    return null;
                var result = dates[0];
                for (var i = 1; i < dates.length; ++i)
                    if (dates[i] < result)
                        result = dates[i];
                return result;
            };
            Dates.getCalendarWeek = function (date, useUTC) {
                if (date === void 0) { date = new Date(); }
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                if (useUTC) {
                    var currentThursday = new Date(date.getTime() + (3 - ((date.getUTCDay() + 6) % 7)) * 86400000);
                    var yearOfThursday = currentThursday.getUTCFullYear();
                    var offset = new Date(0);
                    offset.setUTCFullYear(yearOfThursday, 0, 4);
                    var firstThursday = new Date(offset.getTime() + (3 - ((offset.getUTCDay() + 6) % 7)) * 86400000);
                    var weekNumber = Math.floor(1 + 0.5 + (currentThursday.getTime() - firstThursday.getTime()) / 86400000 / 7);
                    return weekNumber;
                }
                else {
                    var currentThursday = new Date(date.getTime() + (3 - ((date.getDay() + 6) % 7)) * 86400000);
                    var yearOfThursday = currentThursday.getFullYear();
                    var firstThursday = new Date(new Date(yearOfThursday, 0, 4).getTime() + (3 - ((new Date(yearOfThursday, 0, 4).getDay() + 6) % 7)) * 86400000);
                    var weekNumber = Math.floor(1 + 0.5 + (currentThursday.getTime() - firstThursday.getTime()) / 86400000 / 7);
                    return weekNumber;
                }
            };
            Dates.getCalendarWeekYear = function (date, useUTC) {
                if (date === void 0) { date = new Date(); }
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                var year = useUTC ? date.getUTCFullYear() : date.getFullYear();
                var week = Dates.getCalendarWeek(date, useUTC);
                if (week < 52)
                    return year;
                return date.getMonth() > 6 ? year : year - 1;
            };
            Dates.getFirstOfWeek = function (date, useUTC) {
                if (date === void 0) { date = new Date(); }
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                var result = new Date(date.getTime());
                if (useUTC) {
                    result.setUTCDate(result.getUTCDate() - (result.getUTCDay() + 6) % 7);
                    result.setUTCHours(0, 0, 0, 0);
                }
                else {
                    result.setDate(result.getDate() - (result.getDay() + 6) % 7);
                    result.setHours(0, 0, 0, 0);
                }
                return result;
            };
            Dates.getFirstOfMonth = function (date, useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                var result = new Date(date.getTime());
                if (useUTC) {
                    result.setUTCDate(1);
                    result.setUTCHours(0, 0, 0, 0);
                }
                else {
                    result.setDate(1);
                    result.setHours(0, 0, 0, 0);
                }
                return result;
            };
            Dates.getLastOfMonth = function (date, useUTC) {
                if (useUTC === void 0) { useUTC = Dates.USE_UTC; }
                var result = new Date(date.getTime());
                if (useUTC) {
                    result.setUTCDate(1);
                    result.setUTCMonth(result.getUTCMonth() + 1);
                    result.setUTCDate(0);
                    result.setUTCHours(0, 0, 0, 0);
                }
                else {
                    result.setDate(1);
                    result.setMonth(result.getMonth() + 1);
                    result.setDate(0);
                    result.setHours(0, 0, 0, 0);
                }
                return result;
            };
            Dates.areClose = function (a, b, threshold) {
                if (threshold === void 0) { threshold = 1000; }
                if (!a || !b)
                    return false;
                return Math.abs(a.getTime() - b.getTime()) <= threshold;
            };
            Dates.getMonthDays = function (date) {
                if (date === void 0) { date = new Date(); }
                var temp = new Date(date.getFullYear(), date.getMonth() + 1, 0);
                return temp.getDate();
            };
            Dates.delta = function (date, years, months, days, hours, minutes, seconds, milliSeconds, isCapped) {
                if (years === void 0) { years = 0; }
                if (months === void 0) { months = 0; }
                if (days === void 0) { days = 0; }
                if (hours === void 0) { hours = 0; }
                if (minutes === void 0) { minutes = 0; }
                if (seconds === void 0) { seconds = 0; }
                if (milliSeconds === void 0) { milliSeconds = 0; }
                if (isCapped === void 0) { isCapped = true; }
                var result = new Date(date.getTime());
                result.setUTCFullYear(result.getUTCFullYear() + years);
                if (isCapped) {
                    var oldMonth = result.getUTCMonth();
                    result.setUTCMonth(oldMonth + months);
                    var newMonth = result.getUTCMonth();
                    if ((oldMonth + months) % 12 != newMonth)
                        result.setUTCDate(0);
                }
                else {
                    result.setUTCMonth(result.getUTCMonth() + months);
                }
                result.setUTCDate(result.getUTCDate() + days);
                result.setUTCHours(result.getUTCHours() + hours);
                result.setUTCMinutes(result.getUTCMinutes() + minutes);
                result.setUTCSeconds(result.getUTCSeconds() + seconds);
                result.setUTCMilliseconds(result.getUTCMilliseconds() + milliSeconds);
                return result;
            };
            Dates.USE_UTC = false;
            return Dates;
        }());
        util.Dates = Dates;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Util = (function () {
            function Util() {
            }
            Util.equal = function (obj1, obj2, maxRecursionDepth) {
                if (maxRecursionDepth === void 0) { maxRecursionDepth = 1000; }
                if (maxRecursionDepth < 0)
                    return true;
                if (!obj1 != !obj2)
                    return false;
                if (!obj1 && !obj2)
                    return true;
                --maxRecursionDepth;
                if (typeof obj1 != "object" || typeof obj2 != "object")
                    return obj1 === obj2;
                if (!obj1 != !obj2)
                    return false;
                if (typeof obj1.equals == "function")
                    return obj1.equals(obj2);
                if ((obj1.length || obj2.length) && obj1.length != obj2.length)
                    return false;
                if (obj1 instanceof Date && obj2 instanceof Date)
                    return obj1.getTime() == obj2.getTime();
                for (var i in obj1) {
                    if (!Util.equal(obj1[i], obj2[i], maxRecursionDepth))
                        return false;
                }
                for (var i in obj2) {
                    if (!Util.equal(obj1[i], obj2[i], maxRecursionDepth))
                        return false;
                }
                return true;
            };
            Util.fieldsMatch = function (obj1, obj2, fieldNames, strict) {
                if (strict === void 0) { strict = false; }
                if (!obj1 || !obj2)
                    return false;
                if (strict) {
                    for (var i = 0; i < fieldNames.length; ++i) {
                        if (Util.getProperty(obj1, fieldNames[i]) !== Util.getProperty(obj2, fieldNames[i]))
                            return false;
                    }
                }
                else {
                    for (var i = 0; i < fieldNames.length; ++i) {
                        if (Util.getProperty(obj1, fieldNames[i]) != Util.getProperty(obj2, fieldNames[i]))
                            return false;
                    }
                }
                return true;
            };
            Util.clone = function (obj) {
                if (!obj || typeof obj != "object")
                    return obj;
                if (obj instanceof Date)
                    return new Date(obj.getTime());
                var result = typeof obj["length"] == "number" ? [] : obj["__proto__"] ? Object.create(obj["__proto__"]) : {};
                var keys = Object.keys(obj);
                for (var i = 0; i < keys.length; ++i) {
                    if (typeof obj[keys[i]] == "object")
                        result[keys[i]] = Util.clone(obj[keys[i]]);
                    else
                        result[keys[i]] = obj[keys[i]];
                }
                return result;
            };
            Util.encodeHtml = function (text) {
                if (!text)
                    return text;
                text = text
                    .replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
                return text;
            };
            Util.decodeHtml = function (text) {
                var tokens = { nbsp: " ", amp: "&", lt: "<", gt: ">", quot: "\"" };
                text = text.replace(/&(#?\w+?);/g, function (all, captured) {
                    if (tokens[captured])
                        return tokens[captured];
                    try {
                        if (captured.charAt(0) == "#")
                            return String.fromCharCode(parseInt(captured.slice(1)));
                    }
                    catch (e) {
                    }
                    return all;
                });
                return text;
            };
            Util.reverse = function (values) {
                values = values.slice();
                var m = Math.floor(values.length / 2);
                var e = values.length - 1;
                for (var i = 0; i < m; ++i)
                    _a = [values[e - i], values[i]], values[i] = _a[0], values[e - i] = _a[1];
                return values;
                var _a;
            };
            Util.contains = function (container, target, strict) {
                if (strict === void 0) { strict = false; }
                if (!container || container.length <= 0)
                    return false;
                for (var i = 0; i < container.length; ++i) {
                    if (container[i] === target || (!strict && container[i] == target))
                        return true;
                }
                return false;
            };
            Util.remove = function (container, target, strict) {
                if (strict === void 0) { strict = false; }
                for (var i = 0; i < container.length; ++i) {
                    if (container[i] === target || (!strict && container[i] == target))
                        return container.splice(i, 1)[0];
                }
                return null;
            };
            Util.difference = function (base) {
                var operands = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    operands[_i - 1] = arguments[_i];
                }
                var result = base.slice(0);
                for (var i = 0; i < result.length; ++i) {
                    for (var j = 0; j < operands.length; ++j) {
                        if (Util.contains(operands[j], result[i])) {
                            result.splice(i--, 1);
                            break;
                        }
                    }
                }
                return result;
            };
            Util.intersect = function () {
                var arrays = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arrays[_i] = arguments[_i];
                }
                var result = Util.merge.apply(Util, arrays);
                for (var i = 0; i < result.length; ++i) {
                    for (var j = 0; j < arrays.length; ++j) {
                        if (!Util.contains(arrays[j], result[i])) {
                            result.splice(i--, 1);
                            break;
                        }
                    }
                }
                return result;
            };
            Util.merge = function () {
                var arrays = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arrays[_i] = arguments[_i];
                }
                var result = [];
                for (var i = 0; i < arrays.length; ++i) {
                    for (var j in arrays[i]) {
                        if (!Util.contains(result, arrays[i][j]))
                            result.push(arrays[i][j]);
                    }
                }
                return result;
            };
            Util.mergeAssoc = function () {
                var objects = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    objects[_i] = arguments[_i];
                }
                var result = {};
                for (var i = 0; i < objects.length; ++i) {
                    if (!objects[i])
                        continue;
                    for (var j in objects[i])
                        result[j] = objects[i][j];
                }
                return result;
            };
            Util.getProperty = function (obj, propertyName) {
                var parts = propertyName.split(".");
                while (parts.length > 0) {
                    if (!obj)
                        return undefined;
                    obj = obj[parts.shift()];
                }
                return obj;
            };
            Util.getPropertyAndGetter = function (obj, propertyName) {
                if (propertyName == "")
                    return obj;
                var parts = propertyName.split(".");
                while (parts.length > 0) {
                    if (!obj)
                        return undefined;
                    var prop = parts.shift();
                    if (prop.substr(prop.length - 2, 2) == '()')
                        obj = obj[prop.substr(0, prop.length - 2)]();
                    else
                        obj = obj[prop];
                }
                return obj;
            };
            Util.setProperty = function (obj, name, value) {
                var parts = name.split(".");
                while (parts.length > 1) {
                    var key = parts.shift();
                    if (typeof obj[key] == "undefined") {
                        var index = parseInt(parts[0], 10);
                        if (isNaN(index)) {
                            obj[key] = {};
                        }
                        else {
                            obj[key] = [];
                            for (var i = -1; i < index; ++i)
                                obj[key].push(undefined);
                        }
                    }
                    obj = obj[key];
                }
                obj[parts[0]] = value;
            };
            Util.findBy = function (objects, propertyName, propertyValue, offset, strict) {
                if (offset === void 0) { offset = 0; }
                if (strict === void 0) { strict = false; }
                if (!objects)
                    return -1;
                if (strict) {
                    for (var i = offset; i < objects.length; ++i) {
                        if (Util.getProperty(objects[i], propertyName) === propertyValue)
                            return i;
                    }
                }
                else {
                    for (var i = offset; i < objects.length; ++i) {
                        if (Util.getProperty(objects[i], propertyName) == propertyValue)
                            return i;
                    }
                }
                return -1;
            };
            Util.getBy = function (objects, propertyName, propertyValue, offset, strict) {
                if (offset === void 0) { offset = 0; }
                if (strict === void 0) { strict = false; }
                var pos = Util.findBy(objects, propertyName, propertyValue, offset, strict);
                return pos >= 0 ? objects[pos] : undefined;
            };
            Util.mapAssoc = function (values, mapFunc) {
                var assoc = {};
                for (var i = 0; i < values.length; ++i) {
                    var _a = mapFunc(values[i], i), id = _a[0], newValue = _a[1];
                    assoc[id] = newValue;
                }
                return assoc;
            };
            Util.combine = function (keys, values) {
                if (keys.length != values.length)
                    throw new Error("keys.length doesn't match values.length");
                var result = {};
                for (var i = 0; i < keys.length; ++i)
                    result[keys[i]] = values[i];
                return result;
            };
            Util.getAllBy = function (objects, propertyName, propertyValue) {
                if (!objects)
                    return [];
                var results = [];
                for (var i = 0; i < objects.length; ++i) {
                    if (Util.getProperty(objects[i], propertyName) == propertyValue)
                        results.push(objects[i]);
                }
                return results;
            };
            Util.removeBy = function (objects, propertyName, propertyValue) {
                var result = [];
                if (!objects)
                    return result;
                for (var i = 0; i < objects.length; ++i) {
                    if (Util.getProperty(objects[i], propertyName) == propertyValue)
                        result = result.concat(objects.splice(i--, 1));
                }
                return result;
            };
            Util.gather = function (objects, fieldName, filterFunc) {
                var result = [];
                var parts = fieldName.split(".");
                if (filterFunc) {
                    for (var i in objects) {
                        if (filterFunc(objects[i])) {
                            var temp = objects[i];
                            for (var j = 0; j < parts.length; ++j)
                                temp = temp[parts[j]];
                            result.push(temp);
                        }
                    }
                }
                else {
                    for (var i in objects) {
                        var temp = objects[i];
                        for (var j = 0; j < parts.length; ++j)
                            temp = temp[parts[j]];
                        result.push(temp);
                    }
                }
                return result;
            };
            Util.gatherUnique = function (objects, fieldName, filterFunc) {
                return Util.removeDuplicates(Util.gather(objects, fieldName, filterFunc));
            };
            Util.removeDuplicates = function (objects) {
                var result = [];
                for (var i = 0; i < objects.length; ++i) {
                    if (result.indexOf(objects[i]) < 0)
                        result.push(objects[i]);
                }
                return result;
            };
            Util.arrayToAssoc = function (data, indexField) {
                if (indexField === void 0) { indexField = "id"; }
                var result = {};
                for (var i = 0; i < data.length; ++i) {
                    var key = Util.getProperty(data[i], indexField);
                    result[key] = data[i];
                }
                return result;
            };
            Util.arrayToPairs = function (data, indexField, valueField) {
                var result = {};
                for (var i in data) {
                    var key = Util.getProperty(data[i], indexField);
                    var value = Util.getProperty(data[i], valueField);
                    result[key] = value;
                }
                return result;
            };
            Util.arrayToSet = function (data, trueValue) {
                if (trueValue === void 0) { trueValue = true; }
                var set = {};
                for (var i = 0; i < data.length; ++i)
                    set[data[i]] = trueValue;
                return set;
            };
            Util.assocToArray = function (data) {
                var result = [];
                for (var i in data)
                    result.push(data[i]);
                return result;
            };
            Util.filter = function (value, validValues, fallbackValue) {
                if (fallbackValue === void 0) { fallbackValue = null; }
                for (var i = 0; i < validValues.length; ++i) {
                    if (validValues[i] == value)
                        return value;
                }
                return fallbackValue;
            };
            Util.filterKey = function (key, validKeys, fallbackKey) {
                if (fallbackKey === void 0) { fallbackKey = null; }
                if (typeof validKeys[key] != "undefined")
                    return key;
                return fallbackKey;
            };
            Util.filterAssoc = function (obj, func) {
                var result = {};
                for (var name in obj) {
                    if (func(obj[name], name))
                        result[name] = obj[name];
                }
                return result;
            };
            Util.sortBy = function () {
                var values = arguments[0];
                var fields;
                if (typeof arguments[1] == "string") {
                    fields = {};
                    fields[arguments[1]] = arguments[2] === undefined ? true : arguments[2];
                }
                else {
                    fields = arguments[1];
                }
                for (var i = 0; i < values.length; ++i) {
                    for (var name in fields) {
                        if (Util.getProperty(values[i], name) === undefined) {
                            util.Log.logError("property", name, "in", values[i], "not found while sorting, aborting sort");
                            break;
                        }
                    }
                }
                values.sort(function (a, b) {
                    for (var name in fields) {
                        var aValue = Util.getProperty(a, name);
                        var bValue = Util.getProperty(b, name);
                        if (aValue < bValue)
                            return fields[name] ? -1 : 1;
                        if (aValue > bValue)
                            return fields[name] ? 1 : -1;
                    }
                    return 0;
                });
            };
            Util.sortAssocByKey = function (data, sortFunc) {
                sortFunc = sortFunc || (function (keyA, keyB) { return keyA.localeCompare(keyB); });
                var keys = Object.keys(data);
                keys.sort(sortFunc);
                var result = {};
                for (var i = 0; i < keys.length; ++i)
                    result[keys[i]] = data[keys[i]];
                return result;
            };
            Util.sortAssocByValue = function (data, sortFunc) {
                sortFunc = sortFunc || (function (valueA, valueB) { return valueA.toString().localeCompare(valueB.toString()); });
                var keys = Object.keys(data);
                keys.sort(function (keyA, keyB) { return sortFunc(data[keyA], data[keyB]); });
                var result = {};
                for (var i = 0; i < keys.length; ++i)
                    result[keys[i]] = data[keys[i]];
                return result;
            };
            Util.sortIndicesBy = function (values, field, ascending) {
                if (ascending === void 0) { ascending = true; }
                var one = ascending ? 1 : -1;
                var results = [];
                for (var i = 0; i < values.length; ++i)
                    results.push(i);
                results.sort(function (a, b) {
                    var aValue = Util.getProperty(values[a], field);
                    var bValue = Util.getProperty(values[b], field);
                    return (aValue > bValue) ? one : (aValue < bValue) ? -one : 0;
                });
                return results;
            };
            Util.bucketBy = function (values, field) {
                var buckets = {};
                for (var i = 0; i < values.length; ++i) {
                    var key = Util.getProperty(values[i], field);
                    if (!buckets[key])
                        buckets[key] = [];
                    buckets[key].push(values[i]);
                }
                return buckets;
            };
            Util.bucketByRecursive = function (values) {
                var fields = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    fields[_i - 1] = arguments[_i];
                }
                if (fields.length == 0)
                    return undefined;
                var field = fields.shift();
                var buckets = Util.bucketBy(values, field);
                if (fields.length > 0) {
                    for (var id in buckets)
                        buckets[id] = Util.bucketByRecursive.apply(Util, [buckets[id]].concat(fields));
                }
                return buckets;
            };
            Util.bucketAssocBy = function (values, field) {
                var buckets = {};
                for (var i in values) {
                    var key = Util.getProperty(values[i], field);
                    if (!buckets[key])
                        buckets[key] = [];
                    buckets[key].push(values[i]);
                }
                return buckets;
            };
            Util.forEachRecursive = function (obj, func) {
                if (!obj || typeof obj != "object")
                    return;
                var workset = Object.keys(obj);
                while (workset.length > 0) {
                    var key = workset.pop();
                    var value = Util.getProperty(obj, key);
                    var type = value ? typeof value : "null";
                    switch (type) {
                        case "object":
                            var subKeys = Object.keys(value);
                            for (var i = 0; i < subKeys.length; ++i)
                                workset.push(key + "." + subKeys[i]);
                            break;
                        default:
                            func(key, value, obj);
                            break;
                    }
                }
            };
            Util.mergeAssocRecursive = function () {
                var objects = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    objects[_i] = arguments[_i];
                }
                var result = {};
                for (var i = 0; i < objects.length; ++i)
                    Util.forEachRecursive(objects[i], function (key, value) { return Util.setProperty(result, key, value); });
                return result;
            };
            Util.getFirstInstanceOf = function (values, cls, offset, skip) {
                if (offset === void 0) { offset = 0; }
                if (skip === void 0) { skip = 0; }
                for (var i = offset; i < values.length; ++i) {
                    if (values[i] instanceof cls) {
                        if (skip <= 0)
                            return values[i];
                        --skip;
                    }
                }
                return undefined;
            };
            Util.getFirstOfType = function (values, type, offset, skip) {
                if (offset === void 0) { offset = 0; }
                if (skip === void 0) { skip = 0; }
                for (var i = offset; i < values.length; ++i) {
                    if (typeof values[i] == type) {
                        if (skip <= 0)
                            return values[i];
                        --skip;
                    }
                }
                return undefined;
            };
            Util.getAllInstancesOf = function (values, cls, offset) {
                if (offset === void 0) { offset = 0; }
                var result = [];
                for (var i = offset; i < values.length; ++i) {
                    if (values[i] instanceof cls)
                        result.push(values[i]);
                }
                return result;
            };
            Util.getAllOfType = function (values, type, offset) {
                if (offset === void 0) { offset = 0; }
                var result = [];
                for (var i = offset; i < values.length; ++i) {
                    if (typeof values[i] == type)
                        result.push(values[i]);
                }
                return result;
            };
            Util.rearrange = function (values, newOffsets) {
                var result = [];
                for (var i = 0; i < newOffsets.length; ++i)
                    result.push(values[newOffsets[i]]);
                result = result.concat(values.slice(newOffsets.length));
                return result;
            };
            Util.fill = function () {
                var result = [];
                if (typeof arguments[1] == "function") {
                    for (var i = 0; i < arguments[0]; ++i)
                        result.push(arguments[1](i));
                }
                else {
                    for (var i = 0; i < arguments[0]; ++i)
                        result.push(arguments[1]);
                }
                return result;
            };
            return Util;
        }());
        util.Util = Util;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
function firstOfType(values, type, offset, skip) {
    if (offset === void 0) { offset = 0; }
    if (skip === void 0) { skip = 0; }
    return kr3m.util.Util.getFirstOfType(values, type, offset, skip);
}
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Json = (function () {
            function Json() {
            }
            Json.breakCircular = function (obj) {
                if (!obj || typeof obj != "object" || obj instanceof Date)
                    return obj;
                var found = [];
                var broken = [];
                var workset1 = [obj];
                while (workset1.length > 0) {
                    var current = workset1.shift();
                    found.push(current);
                    for (var key in current) {
                        if (typeof current[key] != "object" || current[key] instanceof Date)
                            continue;
                        if (found.indexOf(current[key]) >= 0)
                            broken.push(current[key]);
                        else
                            workset1.push(current[key]);
                    }
                }
                if (broken.length == 0)
                    return obj;
                var clone = typeof obj["length"] == "number" ? [] : {};
                var workset2 = [{ prefix: "", value: obj }];
                while (workset2.length > 0) {
                    var current = workset2.shift();
                    for (var key in current.value) {
                        if (broken.indexOf(current.value[key]) >= 0) {
                            util.Util.setProperty(clone, current.prefix + key, "[CYCLICAL]");
                            continue;
                        }
                        if (typeof current.value[key] != "object" || current.value[key] instanceof Date)
                            util.Util.setProperty(clone, current.prefix + key, current.value[key]);
                        else
                            workset2.push({ value: current.value[key], prefix: current.prefix + key + "." });
                    }
                }
                return clone;
            };
            Json.encode = function (obj, breakCircular) {
                if (breakCircular === void 0) { breakCircular = false; }
                if (breakCircular)
                    obj = Json.breakCircular(obj);
                return JSON.stringify(obj);
            };
            Json.encodeNice = function (obj, padding, breakCircular) {
                if (padding === void 0) { padding = ""; }
                if (breakCircular === void 0) { breakCircular = false; }
                if (breakCircular)
                    obj = Json.breakCircular(obj);
                if (typeof obj == "object" && !(obj instanceof Date)) {
                    var json = "";
                    if (typeof obj.length == "number") {
                        if (obj.length === 0)
                            return padding + "[]";
                        json += padding + "[";
                        for (var i = 0; i < obj.length; ++i)
                            json += "\n" + Json.encodeNice(obj[i], padding + "\t") + ",";
                        if (obj.length > 0)
                            json = json.slice(0, -1);
                        json += "\n" + padding + "]";
                    }
                    else {
                        json += padding + "{";
                        for (var ind in obj) {
                            if (typeof obj[ind] == "object" && !(obj instanceof Date))
                                json += "\n\t" + padding + "\"" + ind + "\":\n" + Json.encodeNice(obj[ind], padding + "\t") + ",";
                            else
                                json += "\n\t" + padding + "\"" + ind + "\":" + Json.encode(obj[ind]) + ",";
                        }
                        if (json.slice(-1) == ",")
                            json = json.slice(0, -1);
                        json += "\n" + padding + "}";
                    }
                    return json;
                }
                else {
                    return padding + Json.encode(obj);
                }
            };
            Json.escapeSpecialChars = function (json) {
                return json.replace(/[\u0080-\uffff]/g, function (char) { return "\\u" + ("0000" + char.charCodeAt(0).toString(16)).slice(-4); });
            };
            Json.reviver = function (key, computed) {
                if (typeof computed == "string") {
                    var date = kr3m.util.Dates.getDateFromDateTimeString(computed);
                    if (date)
                        return date;
                }
                return computed;
            };
            Json.isJSON = function (text) {
                if (!text)
                    return false;
                try {
                    JSON.parse(text);
                    return true;
                }
                catch (e) {
                    return false;
                }
            };
            Json.decode = function (json) {
                if (!json)
                    return null;
                try {
                    return JSON.parse(json, Json.reviver);
                }
                catch (e) {
                    console.error(json);
                    console.error(e);
                    return null;
                }
            };
            Json.mergeAssoc = function () {
                var jsons = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    jsons[_i] = arguments[_i];
                }
                var objs = jsons.map(function (j) { return Json.decode(j); });
                var result = util.Util.mergeAssoc.apply(util.Util, objs);
                return Json.encode(result);
            };
            return Json;
        }());
        util.Json = Json;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Log = (function () {
            function Log() {
            }
            Log.logError = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                if (!Log.enabled || typeof console == "undefined" || typeof console.error == "undefined")
                    return;
                if (values.length == 1 && values[0] instanceof Error) {
                    if (typeof values[0].stack != "undefined" && typeof window["chrome"] == "undefined")
                        throw values[0].stack;
                    else
                        throw values[0];
                }
                else {
                    try {
                        console.error.apply(console, values);
                    }
                    catch (e) {
                        console.error(values);
                    }
                }
            };
            Log.log = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                if (!Log.enabled || typeof console == "undefined" || typeof console.log == "undefined")
                    return;
                try {
                    console.log.apply(console, values);
                }
                catch (e) {
                    console.log(values);
                }
            };
            Log.logWarning = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                if (!Log.enabled || typeof console == "undefined" || typeof console.warn == "undefined")
                    return;
                if (values.length == 1 && values[0] instanceof Error) {
                    if (typeof values[0].stack != "undefined" && typeof window["chrome"] == "undefined")
                        throw values[0].stack;
                    else
                        throw values[0];
                }
                else {
                    try {
                        console.warn.apply(console, values);
                    }
                    catch (e) {
                        console.warn(values);
                    }
                }
            };
            Log.logDebug = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                Log.log.apply(null, values);
            };
            Log.logVerbose = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
            };
            Log.dump = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                if (!Log.enabled || typeof console == "undefined" || typeof console.log == "undefined")
                    return;
                for (var i = 0; i < values.length; ++i) {
                    if (typeof values[i] == "object")
                        values[i] = util.Json.encode(values[i], true);
                }
                Log.log.apply(null, values);
            };
            Log.stackTrace = function (asError, skipLines) {
                if (asError === void 0) { asError = false; }
                if (skipLines === void 0) { skipLines = 0; }
                var e = new Error();
                var stack = e["stack"].split(/\s+at\s+/).slice(skipLines + 1);
                return stack.join("\n");
            };
            Log.logStackTrace = function (asError, skipLines) {
                if (asError === void 0) { asError = false; }
                if (skipLines === void 0) { skipLines = 0; }
                Log.log(Log.stackTrace(asError));
            };
            Log.enabled = true;
            return Log;
        }());
        util.Log = Log;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
function log() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    kr3m.util.Log.log.apply(null, values);
}
function logDebug() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    kr3m.util.Log.logDebug.apply(null, values);
}
function logVerbose() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
}
function dump() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    kr3m.util.Log.dump.apply(null, values);
}
function logError() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    kr3m.util.Log.logError.apply(null, values);
}
function logWarning() {
    var values = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        values[_i] = arguments[_i];
    }
    kr3m.util.Log.logWarning.apply(null, values);
}
function logFunc(functionName) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
    }
    var text = functionName + "(";
    for (var i = 0; i < params.length; ++i)
        params[i] = kr3m.util.Json.encode(params[i], true);
    text += params.join(", ") + ")";
    kr3m.util.Log.log(text);
}
var kr3m;
(function (kr3m) {
    var async;
    (function (async) {
        var Timeout = (function () {
            function Timeout() {
            }
            Timeout.call = function (timeout, callFunc, successCallback, timeoutCallback) {
                timeoutCallback = timeoutCallback || successCallback;
                var hadTimeout = false;
                var timer;
                var helper = function () {
                    if (!hadTimeout) {
                        clearTimeout(timer);
                        successCallback.apply(null, arguments);
                    }
                };
                timer = setTimeout(function () {
                    hadTimeout = true;
                    timeoutCallback();
                }, timeout);
                try {
                    callFunc(helper);
                }
                catch (ex) {
                    kr3m.util.Log.logDebug(ex.toString());
                    hadTimeout = true;
                    clearTimeout(timer);
                    timeoutCallback();
                }
            };
            return Timeout;
        }());
        async.Timeout = Timeout;
    })(async = kr3m.async || (kr3m.async = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        function trySafe(func) {
            var params = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                params[_i - 1] = arguments[_i];
            }
            try {
                func.apply(void 0, params);
            }
            catch (e) {
                util.Log.logError(e);
            }
        }
        util.trySafe = trySafe;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
function trySafe(func) {
    var params = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        params[_i - 1] = arguments[_i];
    }
    try {
        func.apply(void 0, params);
    }
    catch (e) {
        kr3m.util.Log.logError(e);
    }
}
var kr3m;
(function (kr3m) {
    var async;
    (function (async) {
        var Delayed = (function () {
            function Delayed() {
                this.done = false;
                this.pendingCalls = [];
            }
            Delayed.prototype.execute = function () {
                for (var i = 0; i < this.pendingCalls.length; ++i)
                    kr3m.util.trySafe(this.pendingCalls[i].func);
                this.pendingCalls = [];
                this.done = true;
            };
            Delayed.prototype.call = function (func, exclusiveKey, exclusivePriority) {
                if (exclusivePriority === void 0) { exclusivePriority = 0; }
                if (this.done) {
                    func();
                    return;
                }
                if (exclusiveKey) {
                    for (var i = 0; i < this.pendingCalls.length; ++i) {
                        if (this.pendingCalls[i].key == exclusiveKey) {
                            if (this.pendingCalls[i].priority >= exclusivePriority)
                                return;
                            else
                                this.pendingCalls.splice(i--, 1);
                        }
                    }
                }
                this.pendingCalls.push({ func: func, key: exclusiveKey, priority: exclusivePriority });
            };
            Delayed.prototype.isDone = function () {
                return this.done;
            };
            Delayed.prototype.reset = function (flush) {
                if (flush === void 0) { flush = false; }
                this.done = false;
                if (flush)
                    this.pendingCalls = [];
            };
            return Delayed;
        }());
        async.Delayed = Delayed;
    })(async = kr3m.async || (kr3m.async = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var async;
    (function (async) {
        var Loop = (function () {
            function Loop() {
            }
            Loop.loop = function (loopFunc, callback) {
                var counter = 0;
                var innerHelper = function (again) {
                    if (again || again === undefined) {
                        ++counter;
                        if (counter < Loop.MAX_SYNC_ITERATIONS)
                            return loopFunc(innerHelper);
                        counter = 0;
                        setTimeout(innerHelper, 0);
                        return;
                    }
                    callback && callback();
                };
                innerHelper(true);
            };
            Loop.times = function (count, loopFunc, callback, parallelCount) {
                if (parallelCount === void 0) { parallelCount = 1; }
                if (count < 1)
                    return callback && callback();
                var i = 0;
                var runningCount = Math.min(parallelCount, count);
                var runningCountInitial = runningCount;
                var innerHelpers = [];
                var counters = [];
                var innerHelper = function (j) {
                    --runningCount;
                    if (i < count) {
                        ++runningCount;
                        ++counters[j];
                        var myI = i++;
                        if (counters[j] < Loop.MAX_SYNC_ITERATIONS)
                            return loopFunc(innerHelpers[j], myI);
                        counters[j] = 0;
                        setTimeout(function () { return loopFunc(innerHelpers[j], myI); }, 0);
                    }
                    else if (callback && runningCount == 0) {
                        callback();
                    }
                };
                for (var j = 0; j < runningCountInitial; ++j) {
                    counters[j] = 0;
                    innerHelpers[j] = innerHelper.bind(null, j);
                    innerHelpers[j]();
                }
            };
            Loop.forEach = function (values, loopFunc, callback, parallelCount) {
                if (parallelCount === void 0) { parallelCount = 1; }
                if (!values || values.length == 0)
                    return callback && callback();
                var i = 0;
                var runningCount = Math.min(parallelCount, values.length);
                var runningCountInitial = runningCount;
                var innerHelpers = [];
                var counters = [];
                var innerHelper = function (j) {
                    --runningCount;
                    if (i < values.length) {
                        ++runningCount;
                        ++counters[j];
                        var myI = i++;
                        if (counters[j] < Loop.MAX_SYNC_ITERATIONS)
                            return loopFunc(values[myI], innerHelpers[j], myI);
                        counters[j] = 0;
                        setTimeout(function () { return loopFunc(values[myI], innerHelpers[j], myI); }, 0);
                    }
                    else if (callback && runningCount == 0) {
                        callback();
                    }
                };
                for (var j = 0; j < runningCountInitial; ++j) {
                    counters[j] = 0;
                    innerHelpers[j] = innerHelper.bind(null, j);
                    innerHelpers[j]();
                }
            };
            Loop.forEachAssoc = function (valuesMap, loopFunc, callback, parallelCount) {
                if (parallelCount === void 0) { parallelCount = 1; }
                if (!valuesMap)
                    return callback && callback();
                var keys = Object.keys(valuesMap);
                kr3m.async.Loop.forEach(keys, function (key, next) {
                    loopFunc(key, valuesMap[key], next);
                }, callback, parallelCount);
            };
            Loop.forEachBatch = function (values, batchSize, loopFunc, callback, parallelCount) {
                if (parallelCount === void 0) { parallelCount = 1; }
                if (!values || values.length == 0)
                    return callback && callback();
                var i = 0;
                var runningCount = Math.min(parallelCount, Math.ceil(values.length / batchSize));
                var runningCountInitial = runningCount;
                var innerHelpers = [];
                var counters = [];
                var innerHelper = function (j) {
                    --runningCount;
                    if (i < values.length) {
                        ++runningCount;
                        ++counters[j];
                        var myI = i;
                        var batch = values.slice(i, i + batchSize);
                        i += batch.length;
                        if (counters[j] < Loop.MAX_SYNC_ITERATIONS)
                            return loopFunc(batch, innerHelpers[j], myI);
                        counters[j] = 0;
                        setTimeout(function () { return loopFunc(batch, innerHelpers[j], myI); }, 0);
                    }
                    else if (callback && runningCount == 0) {
                        callback();
                    }
                };
                for (var j = 0; j < runningCountInitial; ++j) {
                    counters[j] = 0;
                    innerHelpers[j] = innerHelper.bind(null, j);
                    innerHelpers[j]();
                }
            };
            Loop.MAX_SYNC_ITERATIONS = 200;
            return Loop;
        }());
        async.Loop = Loop;
    })(async = kr3m.async || (kr3m.async = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var AdBlock = (function () {
            function AdBlock() {
            }
            AdBlock.has = function (callback) {
                if (callback)
                    AdBlock.delay.call(function () { return callback(AdBlock.hasBlocker); });
                AdBlock.check();
            };
            AdBlock.check = function () {
                var _this = this;
                if (AdBlock.checking)
                    return;
                if (document.readyState != "complete") {
                    document.addEventListener("readystatechange", function () { return AdBlock.check(); });
                    return;
                }
                AdBlock.checking = true;
                var bait = document.createElement("div");
                bait.setAttribute("class", "pub_300x250 pub_300x250m pub_728x90 text-ad textAd text_ad text_ads text-ads text-ad-links");
                bait.setAttribute("style", "width: 1px !important; height: 1px !important; position: absolute !important; left: -10000px !important; top: -1000px !important;");
                document.body.appendChild(bait);
                var i = 5;
                kr3m.async.Loop.loop(function (loopDone) {
                    setTimeout(function () {
                        var found = function () {
                            AdBlock.hasBlocker = true;
                            _this.delay.execute();
                        };
                        if (document.body.getAttribute("abp") !== null)
                            return found();
                        if (bait.offsetParent === null
                            || bait.offsetHeight == 0
                            || bait.offsetLeft == 0
                            || bait.offsetTop == 0
                            || bait.offsetWidth == 0
                            || bait.clientHeight == 0
                            || bait.clientWidth == 0)
                            return found();
                        if (window.getComputedStyle !== undefined) {
                            var styles = window.getComputedStyle(bait, null);
                            if (styles.getPropertyValue("display") == "none"
                                || styles.getPropertyValue("visibility") == "hidden")
                                return found();
                        }
                        loopDone(--i > 0);
                    }, 50);
                }, function () {
                    bait.remove();
                    AdBlock.hasBlocker = false;
                    _this.delay.execute();
                });
            };
            AdBlock.delay = new kr3m.async.Delayed();
            AdBlock.checking = false;
            return AdBlock;
        }());
        util.AdBlock = AdBlock;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Device = (function () {
            function Device(globals) {
                globals = globals || {};
                globals.document = globals.document || document;
                globals.navigator = globals.navigator || navigator;
                globals.window = globals.window || window;
                try {
                    globals.localStorage = globals.localStorage || localStorage;
                }
                catch (e) {
                }
                this.checkOS(globals);
                this.checkBrowser(globals);
                this.checkDevice(globals);
                this.checkFeatures(globals);
                this.checkAudio(globals);
                this.checkTablet(globals);
                this.mobile = !this.desktop && !this.tablet;
            }
            Device.getInstance = function () {
                var self = Device;
                if (typeof self.instance == "undefined")
                    self.instance = new Device();
                return self.instance;
            };
            Device.prototype.canPlayAudio = function (type) {
                switch (type) {
                    case "ogg":
                        return this.ogg;
                    case "opus":
                        return this.opus;
                    case "mp3":
                        return this.mp3;
                    case "wav":
                        return this.wav;
                    case "m4a":
                        return this.m4a;
                    case "webm":
                        return this.webm;
                }
                return false;
            };
            Device.prototype.checkOS = function (globals) {
                var ua = globals.navigator.userAgent;
                if (/Playstation Vita/.test(ua)) {
                    this.vita = true;
                    this.desktop = false;
                }
                else if (/Kindle/.test(ua) || /\bKF[A-Z][A-Z]+/.test(ua) || /Silk.*Mobile Safari/.test(ua)) {
                    this.kindle = true;
                    this.desktop = false;
                }
                else if (/Android/.test(ua)) {
                    this.android = true;
                    this.desktop = false;
                    this.checkAndroidVersion(globals);
                }
                else if (/CrOS/.test(ua)) {
                    this.chromeOS = true;
                }
                else if (/iP[ao]d|iPhone/i.test(ua)) {
                    this.iOS = true;
                    this.desktop = false;
                    var osVersionMatch = ua.match(/OS (\d+)_/i);
                    if (osVersionMatch)
                        this.iOSVersion = parseInt(osVersionMatch[1], 10);
                    if (/OS 11_/i.test(ua))
                        this.iOS11 = true;
                    else if (/OS 10_/i.test(ua))
                        this.iOS10 = true;
                    else if (/OS 9_/i.test(ua))
                        this.iOS9 = true;
                }
                else if (/Linux/.test(ua)) {
                    this.linux = true;
                }
                else if (/Mac OS/.test(ua)) {
                    this.macOS = true;
                }
                else if (/Windows/.test(ua)) {
                    this.windows = true;
                    if (/Windows Phone/i.test(ua))
                        this.windowsPhone = true;
                }
                if (this.windows || this.macOS || (this.linux && !this.silk) || this.chromeOS)
                    this.desktop = true;
                if (this.windowsPhone || ((/Windows NT/i.test(ua)) && (/Touch/i.test(ua))))
                    this.desktop = false;
            };
            Device.prototype.checkFeatures = function (globals) {
                this.canvas = !!globals.window['CanvasRenderingContext2D'];
                try {
                    this.localStorage = !!globals.localStorage.getItem;
                }
                catch (error) {
                    this.localStorage = false;
                }
                this.file = !!globals.window['File'] && !!globals.window['FileReader'] && !!globals.window['FileList'] && !!globals.window['Blob'];
                this.fileSystem = !!globals.window['requestFileSystem'];
                this.webGL = (function () {
                    try {
                        var canvas = globals.document.createElement('canvas');
                        canvas["screencanvas"] = false;
                        var options = { failIfMajorPerformanceCaveat: true };
                        return (!!globals.window["WebGLRenderingContext"]) && (canvas.getContext('webgl', options) || canvas.getContext('experimental-webgl', options));
                    }
                    catch (e) {
                        return false;
                    }
                })();
                this.webGL = !!this.webGL;
                if ('ontouchstart' in globals.document.documentElement || (globals.navigator["maxTouchPoints"] && globals.navigator["maxTouchPoints"] > 1))
                    this.touch = true;
                if (globals.navigator.msPointerEnabled || globals.navigator["pointerEnabled"])
                    this.mspointer = true;
                this.pointerLock = 'pointerLockElement' in globals.document || 'mozPointerLockElement' in globals.document || 'webkitPointerLockElement' in globals.document;
                this.quirksMode = (globals.document.compatMode === 'CSS1Compat') ? false : true;
            };
            Device.prototype.checkBrowser = function (globals) {
                var ua = globals.navigator.userAgent;
                if (/Instagram/.test(ua)) {
                    this.inApp = true;
                    this.instagramApp = true;
                }
                else if (/FBAV/.test(ua)) {
                    this.inApp = true;
                    this.fbApp = true;
                }
                else if (/Arora/.test(ua)) {
                    this.arora = true;
                }
                else if (/Edge\/\d+/.test(ua)) {
                    this.edge = true;
                }
                else if (/Chrome/.test(ua)) {
                    this.chrome = true;
                    this.checkChromeVersion(ua);
                }
                else if (/CriOS/.test(ua)) {
                    this.iOSChrome = true;
                    this.checkChromeVersion(ua);
                }
                else if (/Epiphany/.test(ua)) {
                    this.epiphany = true;
                }
                else if (/Firefox/.test(ua)) {
                    this.firefox = true;
                    this.checkFirefoxVersion(ua);
                }
                else if (/AppleWebKit/.test(ua) && this.iOS) {
                    this.mobileSafari = true;
                }
                else if (/MSIE (\d+\.\d+);/.test(ua)) {
                    this.ie = true;
                    this.ieVersion = parseInt(RegExp.$1, 10);
                }
                else if (/Midori/.test(ua)) {
                    this.midori = true;
                }
                else if (/Opera/.test(ua)) {
                    this.opera = true;
                }
                else if (/Safari/.test(ua)) {
                    this.safari = true;
                }
                else if (/Trident\/(\d+\.\d+)(.*)rv:(\d+\.\d+)/.test(ua)) {
                    this.ie = true;
                    this.trident = true;
                    this.tridentVersion = parseInt(RegExp.$1, 10);
                    this.ieVersion = parseInt(RegExp.$3, 10);
                }
                this.silk = /Silk/.test(ua);
                if (globals.navigator['standalone'])
                    this.webApp = true;
                var matches = globals.navigator.userAgent.match(/Android.*AppleWebKit\/([\d.]+)/);
                this.androidStockBrowser = matches ? parseInt(matches[1], 10) < 537 : false;
            };
            Device.prototype.checkDevice = function (globals) {
                this.pixelRatio = globals.window['devicePixelRatio'] || 1;
                this.iPhone = globals.navigator.userAgent.toLowerCase().indexOf('iphone') != -1;
                this.iPhone4 = (this.pixelRatio == 2 && this.iPhone);
                this.iPhone5 = (this.pixelRatio == 2 && this.iPhone && screen.availHeight == 548);
                this.iPad = globals.navigator.userAgent.toLowerCase().indexOf('ipad') != -1;
            };
            Device.prototype.checkAudio = function (globals) {
                this.audioData = !!(globals.window['Audio']);
                this.webAudio = !!globals.window['AudioContext'];
                var audioElement = globals.document.createElement('audio');
                var result = false;
                try {
                    if (result = !!audioElement.canPlayType) {
                        if (audioElement.canPlayType('audio/ogg; codecs="vorbis"').replace(/^no$/, ''))
                            this.ogg = true;
                        if (audioElement.canPlayType('audio/ogg; codecs="opus"').replace(/^no$/, '') || audioElement.canPlayType('audio/opus;').replace(/^no$/, ''))
                            this.opus = true;
                        if (audioElement.canPlayType('audio/mpeg;').replace(/^no$/, ''))
                            this.mp3 = true;
                        if (audioElement.canPlayType('audio/wav; codecs="1"').replace(/^no$/, ''))
                            this.wav = true;
                        if (audioElement.canPlayType('audio/x-m4a;') || audioElement.canPlayType('audio/aac;').replace(/^no$/, ''))
                            this.m4a = true;
                        if (audioElement.canPlayType('audio/webm; codecs="vorbis"').replace(/^no$/, ''))
                            this.webm = true;
                    }
                }
                catch (e) {
                }
            };
            Device.prototype.checkTablet = function (globals) {
                if (this.desktop) {
                    this.tablet = false;
                    return;
                }
                var ua = globals.navigator.userAgent;
                this.tablet = false;
                if (this.iOS && /ipad/i.test(ua))
                    this.tablet = true;
                if (this.android && !/mobile/i.test(ua))
                    this.tablet = true;
                if ((/blackberry/i.test(ua) || /bb10/i.test(ua) || /rim/i.test(ua)) && /tablet/i.test(ua))
                    this.tablet = true;
                if (this.tablet)
                    this.desktop = false;
            };
            Device.prototype.checkAndroidVersion = function (globals) {
                var ua = globals.navigator.userAgent.toLowerCase();
                var match = ua.match(/android\s([0-9\.]*)/);
                if (match) {
                    try {
                        this.androidVersion = match[1];
                    }
                    catch (e) {
                    }
                }
            };
            ;
            Device.prototype.checkChromeVersion = function (ua) {
                var matches = ua.match(/Chrome\/(\d+)/i);
                if (matches)
                    this.chromeVersion = parseInt(matches[1], 10);
            };
            Device.prototype.checkFirefoxVersion = function (ua) {
                var matches = ua.match(/Firefox\/(\d+)/i);
                if (matches) {
                    this.firefoxVersion = parseInt(matches[1], 10);
                    this.firefoxQuantum = this.firefoxVersion > 57;
                }
            };
            return Device;
        }());
        util.Device = Device;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
function getDevice() {
    return kr3m.util.Device.getInstance();
}
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var UrlParts = (function () {
            function UrlParts() {
                this.protocol = "";
                this.user = "";
                this.password = "";
                this.domain = "";
                this.port = "";
                this.resource = "";
                this.query = "";
                this.hash = "";
            }
            return UrlParts;
        }());
        util.UrlParts = UrlParts;
        var ArrayHandling;
        (function (ArrayHandling) {
            ArrayHandling[ArrayHandling["ToString"] = 0] = "ToString";
            ArrayHandling[ArrayHandling["Repeat"] = 1] = "Repeat";
            ArrayHandling[ArrayHandling["RepeatBrackets"] = 2] = "RepeatBrackets";
        })(ArrayHandling = util.ArrayHandling || (util.ArrayHandling = {}));
        var Url = (function () {
            function Url() {
            }
            Url.mergeResource = function (a, b) {
                if (!a)
                    return b;
                if (!b)
                    return a;
                if (b.charAt(0) == "/")
                    return b;
                var parts = a.split("/");
                if (parts.length == 0)
                    return b;
                if (parts.length > 0)
                    parts.pop();
                parts = parts.concat(b.split("/"));
                for (var i = 1; i < parts.length - 1; ++i) {
                    if (!parts[i])
                        parts.splice(i--, 1);
                }
                for (var i = 1; i < parts.length; ++i) {
                    if (parts[i] == "..")
                        parts.splice(--i, 2);
                }
                return parts.join("/");
            };
            Url.splitQuery = function (query, ah) {
                var result = {};
                if (!query)
                    return result;
                var parts = query.split("&");
                switch (ah) {
                    case ArrayHandling.ToString:
                        for (var i = 0; i < parts.length; ++i) {
                            var subParts = parts[i].split("=");
                            var name = subParts[0];
                            var value = decodeURIComponent(subParts[1]);
                            result[name] = value;
                        }
                        break;
                    case ArrayHandling.Repeat:
                        for (var i = 0; i < parts.length; ++i) {
                            var subParts = parts[i].split("=");
                            var name = subParts[0];
                            var value = decodeURIComponent(subParts[1]);
                            if (result[name] === undefined)
                                result[name] = value;
                            else if (typeof result[name] === "string")
                                result[name] = [result[name], value];
                            else
                                result[name].push(value);
                        }
                        break;
                    case ArrayHandling.RepeatBrackets:
                        for (var i = 0; i < parts.length; ++i) {
                            var subParts = parts[i].split("=");
                            var name = subParts[0];
                            var value = decodeURIComponent(subParts[1]);
                            if (name.slice(-2) == "[]") {
                                name = name.slice(0, -2);
                                if (!result[name])
                                    result[name] = [];
                                result[name].push(value);
                            }
                            else {
                                result[name] = value;
                            }
                        }
                        break;
                }
                return result;
            };
            Url.joinQuery = function (params, ah) {
                var parts = [];
                for (var name in params) {
                    if (Array.isArray(params[name])) {
                        switch (ah) {
                            case ArrayHandling.ToString:
                                parts.push(name + "=" + encodeURIComponent(params[name].toString()));
                                break;
                            case ArrayHandling.Repeat:
                                for (var i = 0; i < params[name].length; ++i)
                                    parts.push(name + "=" + encodeURIComponent(params[name][i]));
                                break;
                            case ArrayHandling.RepeatBrackets:
                                for (var i = 0; i < params[name].length; ++i)
                                    parts.push(name + "[]=" + encodeURIComponent(params[name][i]));
                                break;
                        }
                    }
                    else if (params[name] === undefined || params[name] === null) {
                        parts.push(name + "=");
                    }
                    else {
                        parts.push(name + "=" + encodeURIComponent(params[name].toString()));
                    }
                }
                return parts.join("&");
            };
            Url.mergeQuery = function (a, b, ah) {
                if (ah === void 0) { ah = ArrayHandling.ToString; }
                a = a || "";
                b = b || "";
                if (a.charAt(0) == "?")
                    a = a.slice(1);
                if (b.charAt(0) == "?")
                    b = b.slice(1);
                var aParams = Url.splitQuery(a, ah);
                var bParams = Url.splitQuery(b, ah);
                for (var i in bParams)
                    aParams[i] = bParams[i];
                return Url.joinQuery(aParams, ah);
            };
            Url.mergeHash = function (a, b) {
                a = a || "";
                b = b || "";
                if (a.charAt(0) == "#")
                    a = a.slice(1);
                if (b.charAt(0) == "#")
                    b = b.slice(1);
                var params = {};
                var aParts = a.split("&");
                var aId = "";
                for (var i = 0; i < aParts.length; ++i) {
                    var subParts = aParts[i].split("=");
                    if (subParts.length == 1)
                        aId = aId || subParts[0];
                    else if (subParts.length == 2)
                        params[subParts[0]] = subParts[1];
                }
                var bParts = b.split("&");
                var bId = "";
                for (var i = 0; i < bParts.length; ++i) {
                    var subParts = bParts[i].split("=");
                    if (subParts.length == 1)
                        bId = bId || subParts[0];
                    else if (subParts.length == 2)
                        params[subParts[0]] = subParts[1];
                }
                var id = aId || bId || "";
                var paramsString = Url.joinQuery(params, ArrayHandling.ToString);
                return paramsString ? id + "&" + paramsString : id;
            };
            Url.merge = function () {
                var urls = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    urls[_i] = arguments[_i];
                }
                var result = new UrlParts();
                for (var i = 0; i < urls.length; ++i) {
                    var parts = Url.parse(urls[i]);
                    result.protocol = parts.protocol || result.protocol;
                    if (result.user) {
                        result.user = parts.user;
                        result.password = result.password;
                    }
                    if (parts.domain) {
                        result.domain = parts.domain;
                        result.port = parts.port;
                        result.resource = parts.resource;
                    }
                    else {
                        result.resource = Url.mergeResource(result.resource, parts.resource);
                    }
                    result.query = Url.mergeQuery(result.query, parts.query);
                    result.hash = Url.mergeHash(result.hash, parts.hash);
                }
                return Url.format(result);
            };
            Url.getPath = function (parts) {
                var path = parts.resource || "/";
                if (parts.query)
                    path += "?" + parts.query;
                if (parts.hash)
                    path += "#" + parts.hash;
                return path;
            };
            Url.parse = function (url) {
                var parts = new UrlParts();
                if (!url)
                    return parts;
                var isFile = url.slice(0, 8) == "file:///";
                if (isFile)
                    url = url.slice(7);
                var parsed = util.StringEx.captureNamed(url, kr3m.REGEX_URL, kr3m.REGEX_URL_GROUPS);
                if (isFile)
                    parsed["protocol"] = "file";
                for (var i in parsed) {
                    if (parsed[i] !== undefined)
                        parts[i] = parsed[i];
                }
                return parts;
            };
            Url.format = function (parts) {
                var url = "";
                if (parts.protocol)
                    url += parts.protocol + "://";
                if (parts.user)
                    url += parts.user + ":" + parts.password + "@";
                if (parts.domain) {
                    url += parts.domain;
                    if (parts.port)
                        url += ":" + parts.port;
                }
                if (parts.resource) {
                    if (parts.domain && parts.resource.charAt(0) != "/")
                        url += "/";
                    url += parts.resource;
                }
                if (parts.query)
                    url += "?" + parts.query;
                if (parts.hash)
                    url += "#" + parts.hash;
                return url;
            };
            Url.getResourceFromUrl = function (url) {
                return Url.parse(url).resource;
            };
            Url.getQueryParams = function (url, ah) {
                if (ah === void 0) { ah = ArrayHandling.ToString; }
                var parts = Url.parse(url);
                var params = Url.splitQuery(parts.query, ah);
                return params;
            };
            Url.setQueryParams = function (url, params, ah) {
                if (ah === void 0) { ah = ArrayHandling.ToString; }
                var parts = Url.parse(url);
                parts.query = Url.joinQuery(params, ah);
                return Url.format(parts);
            };
            Url.addParameter = function (url, key, value, ah) {
                if (ah === void 0) { ah = ArrayHandling.ToString; }
                var params = Url.getQueryParams(url, ah);
                params[key] = value;
                return Url.setQueryParams(url, params, ah);
            };
            Url.addParameters = function (url, params, ah) {
                if (ah === void 0) { ah = ArrayHandling.ToString; }
                var old = Url.getQueryParams(url, ah);
                for (var i in params)
                    old[i] = params[i];
                return Url.setQueryParams(url, old, ah);
            };
            Url.removeParameter = function (url, key, ah) {
                if (ah === void 0) { ah = ArrayHandling.ToString; }
                var params = Url.getQueryParams(url, ah);
                if (typeof params[key] == "undefined")
                    return url;
                delete params[key];
                return Url.setQueryParams(url, params, ah);
            };
            Url.getMailToUrl = function (to, subject, body, cc, bcc) {
                var receivers = typeof to == "string" ? to : to.join(",");
                var headers = [];
                if (subject)
                    headers.push("subject=" + encodeURIComponent(subject));
                if (body)
                    headers.push("body=" + encodeURIComponent(body));
                if (cc !== undefined)
                    headers.push("cc=" + encodeURIComponent(typeof cc == "string" ? cc : cc.join(",")));
                if (bcc != undefined)
                    headers.push("bcc=" + encodeURIComponent(typeof bcc == "string" ? bcc : bcc.join(",")));
                var url = "mailto:" + receivers;
                if (headers.length > 0)
                    url += "?" + headers.join("&");
                return url;
            };
            return Url;
        }());
        util.Url = Url;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Browser = (function () {
            function Browser() {
            }
            Browser.hasAdBlock = function (callback) {
                setTimeout(function () { return util.AdBlock.has(callback); }, 1);
            };
            Browser.isMobile = function () {
                if (location.search.indexOf("force-mobile") > -1)
                    return true;
                if (location.search.indexOf("force-iphone") > -1)
                    return true;
                var device = util.Device.getInstance();
                return !device.desktop;
            };
            Browser.isTablet = function () {
                if (location.search.indexOf("force-tablet") > -1)
                    return true;
                if (location.search.indexOf("force-ipad") > -1)
                    return true;
                var device = util.Device.getInstance();
                return device.tablet;
            };
            Browser.isPhone = function () {
                var device = util.Device.getInstance();
                return Browser.isMobile() && !device.tablet;
            };
            Browser.isIPhone = function () {
                var device = util.Device.getInstance();
                if (location.search.indexOf("force-iphone") > -1)
                    return true;
                return device.iPhone;
            };
            Browser.isFirefox = function () {
                var device = util.Device.getInstance();
                return device.firefox;
            };
            Browser.isAndroid = function () {
                var device = util.Device.getInstance();
                return device.android;
            };
            Browser.isAndroidStock = function () {
                var device = util.Device.getInstance();
                return device.androidStockBrowser;
            };
            Browser.isIOs = function () {
                var device = util.Device.getInstance();
                if ((location.search.indexOf("force-ios") > -1) ||
                    (location.search.indexOf("force-ios9") > -1) ||
                    (location.search.indexOf("force-ios10") > -1))
                    return true;
                return device.iOS;
            };
            Browser.isIOs9 = function () {
                var device = util.Device.getInstance();
                if (location.search.indexOf("force-ios9") > -1)
                    return true;
                return device.iOS9;
            };
            Browser.isIOs10 = function () {
                var device = util.Device.getInstance();
                if (location.search.indexOf("force-ios10") > -1)
                    return true;
                return device.iOS10;
            };
            Browser.isInternetExplorer = function () {
                var device = util.Device.getInstance();
                return device.ie;
            };
            Browser.isChrome = function () {
                var device = util.Device.getInstance();
                return device.chrome;
            };
            Browser.isIOSChrome = function () {
                var device = util.Device.getInstance();
                return device.iOSChrome;
            };
            Browser.isSafari = function () {
                var device = util.Device.getInstance();
                return device.safari;
            };
            Browser.supportsClickJacking = function () {
                if (Browser.isInternetExplorer())
                    return false;
                if (Browser.isSafari())
                    return false;
                return true;
            };
            Browser.isOldBrowser = function () {
                var device = util.Device.getInstance();
                return (device.ie && device.ieVersion < 9) ? true : false;
            };
            Browser.getCookie = function (name) {
                var pattern = new RegExp(name + "=([^;]*)");
                var matches = document.cookie.match(pattern);
                return matches ? decodeURIComponent(matches[1]) : null;
            };
            Browser.setCookie = function (name, value, ttlSeconds) {
                if (ttlSeconds === void 0) { ttlSeconds = 30 * 24 * 60 * 60; }
                value = encodeURIComponent(value);
                if (ttlSeconds > 0) {
                    var exDate = new Date();
                    exDate.setTime(exDate.getTime() + ttlSeconds * 1000);
                    value += "; expires=" + exDate.toUTCString();
                }
                document.cookie = name + "=" + value;
            };
            Browser.deleteCookie = function (name) {
                Browser.setCookie(name, "", -1);
            };
            Browser.getHighestSameDomainWindow = function (win) {
                if (win === void 0) { win = window; }
                try {
                    while (win != win.parent && win.document.domain == win.parent.document.domain)
                        win = win.parent;
                }
                catch (e) {
                }
                return win;
            };
            Browser.getQueryValues = function (win) {
                if (win === void 0) { win = window; }
                try {
                    var data = win.location.search;
                    if (!data || data == "")
                        return {};
                    data = data.substr(1);
                    var values = util.StringEx.splitAssoc(data);
                    var result = {};
                    for (var i in values)
                        result[i] = decodeURIComponent(values[i]);
                    return result;
                }
                catch (e) {
                    return {};
                }
            };
            Browser.getQueryValue = function (key, win) {
                if (win === void 0) { win = window; }
                try {
                    var data = win.location.search;
                    if (!data || data == "")
                        return null;
                    data = data.substr(1);
                    var values = util.StringEx.splitAssoc(data);
                    for (var i in values) {
                        if (i == key)
                            return decodeURIComponent(values[i]);
                    }
                    return null;
                }
                catch (e) {
                    return null;
                }
            };
            Browser.removeParam = function (key, win) {
                if (win === void 0) { win = window; }
                var sourceUrl = win.location.href;
                return util.Url.removeParameter(sourceUrl, key);
            };
            Browser.getBaseUrl = function (win) {
                if (win === void 0) { win = window; }
                var url = win.location.href;
                url = util.StringEx.getBefore(url, "?", true);
                url = util.StringEx.getBefore(url, "#", true);
                url = util.StringEx.getBefore(url, "/", false);
                url += "/";
                return url;
            };
            Browser.getLanguagePreferences = function () {
                var languages = navigator.language || navigator["userLanguage"] || "";
                var parts = languages.split(",");
                var result = [];
                for (var i = 0; i < parts.length; ++i) {
                    if (kr3m.REGEX_LOCALE.test(parts[i])) {
                        var lang = parts[i].slice(0, 2);
                        if (!util.Util.contains(result, lang))
                            result.push(lang);
                    }
                }
                return result;
            };
            Browser.getCountryPreferences = function () {
                var languages = navigator.language || navigator["userLanguage"] || "";
                var parts = languages.split(",");
                var result = [];
                for (var i = 0; i < parts.length; ++i) {
                    if (kr3m.REGEX_LOCALE.test(parts[i])) {
                        var country = parts[i].slice(-2);
                        if (!util.Util.contains(result, country))
                            result.push(country);
                    }
                }
                return result;
            };
            Browser.isHtml5Supported = function () {
                var elem = document.createElement("canvas");
                var isSupported = !!(elem.getContext && elem.getContext("2d"));
                return isSupported;
            };
            Browser.isWebAudioAvailable = function () {
                var win = window;
                if (typeof win.AudioContext != "undefined" || typeof win.webkitAudioContext != "undefined")
                    return true;
                return false;
            };
            return Browser;
        }());
        util.Browser = Browser;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var xml;
    (function (xml_1) {
        var Parser = (function () {
            function Parser() {
                this.S = { " ": true, "\n": true, "\r": true, "\t": true };
                this.NW = { " ": true, "\n": true, "\t": true, "<": true, ">": true, "=": true, "\"": true, "'": true, "\r": true };
                this.ESC = { amp: "&", lt: "<", gt: ">", quot: "\"" };
                this.styleAttibutesPattern = /^xs[a-z]+:/;
                this.stripStyleAttributes = true;
            }
            Parser.prototype.eat = function () {
                return this.rawXml.charAt(this.i++);
            };
            Parser.prototype.skipWS = function () {
                while (this.S[this.rawXml.charAt(this.i)])
                    ++this.i;
            };
            Parser.prototype.skipHeader = function () {
                var t = this.eat();
                while (t && t != "<")
                    t = this.eat();
                var found = false;
                if (this.rawXml.slice(this.i, this.i + 4) == "?xml") {
                    var t = this.eat();
                    while (t && t != "<")
                        t = this.eat();
                    found = true;
                }
                --this.i;
                return found;
            };
            Parser.prototype.readWord = function () {
                this.skipWS();
                var start = this.i;
                while (!this.NW[this.rawXml.charAt(this.i)])
                    ++this.i;
                return this.rawXml.slice(start, this.i);
            };
            Parser.prototype.readTill = function (token) {
                var start = this.i;
                var f = token.charAt(0);
                while (1) {
                    var t = this.eat();
                    if (!t)
                        break;
                    if (t == f) {
                        if (this.rawXml.slice(this.i - 1, this.i - 1 + token.length) == token)
                            break;
                    }
                }
                this.i += token.length - 1;
                return this.rawXml.slice(start, this.i - token.length);
            };
            Parser.prototype.readQuoted = function () {
                this.skipWS();
                var q = this.eat();
                return this.readTill(q);
            };
            Parser.prototype.readAttributes = function () {
                var attributes = {};
                while (true) {
                    this.skipWS();
                    var t = this.rawXml.charAt(this.i);
                    if (t == ">" || t == "/")
                        break;
                    var name = this.readWord();
                    this.skipWS();
                    ++this.i;
                    var value = this.readQuoted();
                    if (!this.stripStyleAttributes || !this.styleAttibutesPattern.test(name))
                        attributes[name] = value;
                }
                return attributes;
            };
            Parser.prototype.isNull = function (node) {
                for (var i in node._attributes) {
                    if ((i == "nil" || i.slice(-4) == ":nil") && node._attributes[i] == "true")
                        return true;
                }
                return false;
            };
            Parser.prototype.isPrimitive = function (node) {
                for (var i in node._attributes)
                    return false;
                for (var i in node) {
                    if (i.charAt(0) != "_")
                        return false;
                }
                return true;
            };
            Parser.prototype.fillChildNodes = function (node, nodes) {
                var temp = {};
                for (var i = 0; i < nodes.length; ++i) {
                    if (!temp[nodes[i]._tag])
                        temp[nodes[i]._tag] = [];
                    if (this.isNull(nodes[i]))
                        temp[nodes[i]._tag].push(null);
                    else if (this.isPrimitive(nodes[i]))
                        temp[nodes[i]._tag].push(nodes[i]._data);
                    else
                        temp[nodes[i]._tag].push(nodes[i]);
                }
                for (var tag in temp)
                    node[tag] = (temp[tag].length == 1) ? temp[tag][0] : temp[tag];
            };
            Parser.prototype.readNode = function () {
                var start = this.i;
                this.skipWS();
                ++this.i;
                var node = {};
                _a = this.readWord().match(/(?:([^\:]+)\:)?([^\:]+)/), node._ns = _a[1], node._tag = _a[2];
                if (node._tag.slice(-1) == "/") {
                    node._tag = node._tag.slice(0, -1);
                    this.i += 1;
                    return node;
                }
                node._attributes = this.readAttributes();
                var t = this.eat();
                if (t == "/") {
                    ++this.i;
                    return node;
                }
                var _b = this.readContent(), data = _b[0], nodes = _b[1];
                node._data = data.trim();
                this.fillChildNodes(node, nodes);
                this.skipWS();
                var skip = node._tag.length + (node._ns ? node._ns.length + 4 : 3);
                this.i += skip;
                return node;
                var _a;
            };
            Parser.prototype.readData = function () {
                this.i += 9;
                var start = this.i;
                var l = this.rawXml.length;
                while (this.i < l) {
                    while (this.i < l && this.rawXml.charAt(this.i) != "]")
                        ++this.i;
                    if (this.rawXml.slice(this.i, this.i + 3) == "]]>") {
                        this.i += 3;
                        return this.rawXml.slice(start, this.i - 3);
                    }
                    ++this.i;
                }
                throw new Error("invalid xml syntax - CDATA terminator expected");
            };
            Parser.prototype.unescape = function (escaped) {
                var unescaped = this.ESC[escaped];
                if (unescaped)
                    return unescaped;
                if (escaped.charAt(0) == "#")
                    return String.fromCharCode(parseInt(escaped.slice(1), 8));
                return String.fromCharCode(parseInt(escaped));
            };
            Parser.prototype.skipComment = function () {
                this.readTill("-->");
            };
            Parser.prototype.readContent = function () {
                this.skipWS();
                var content = "";
                var nodes = [];
                while (1) {
                    var t = this.eat();
                    if (!t)
                        break;
                    if (t == "<") {
                        t = this.eat();
                        this.i -= 2;
                        if (t == "!") {
                            if (this.rawXml.slice(this.i, this.i + 4) == "<!--")
                                this.skipComment();
                            else
                                content += this.readData();
                        }
                        else if (t == "/") {
                            break;
                        }
                        else {
                            nodes.push(this.readNode());
                        }
                    }
                    else if (t == "&") {
                        var escaped = this.readTill(";");
                        content += this.unescape(escaped);
                    }
                    else {
                        content += t;
                    }
                }
                return [content, nodes];
            };
            Parser.prototype.parse = function (rawXml) {
                this.rawXml = rawXml;
                this.i = 0;
                if (!this.skipHeader() && this.i > 3)
                    return undefined;
                var _a = this.readContent(), content = _a[0], nodes = _a[1];
                return nodes.length == 1 ? nodes[0] : undefined;
            };
            return Parser;
        }());
        xml_1.Parser = Parser;
        function parseString(rawXml) {
            var parser = new kr3m.xml.Parser();
            return parser.parse(rawXml);
        }
        xml_1.parseString = parseString;
        function parseXml(xml) {
            var rawXml = new XMLSerializer().serializeToString(xml.documentElement);
            return parseString(rawXml);
        }
        xml_1.parseXml = parseXml;
    })(xml = kr3m.xml || (kr3m.xml = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Ajax = (function () {
            function Ajax() {
            }
            Ajax.getTypeFromUrl = function (url) {
                var resource = util.Url.getResourceFromUrl(url);
                for (var i = 0; i < Ajax.typesByExtension.length; ++i) {
                    var item = Ajax.typesByExtension[i];
                    if (item.pattern.test(resource))
                        return item.type;
                }
                return undefined;
            };
            Ajax.getXMLHttpRequestObject = function () {
                var ref = null;
                if (window.XMLHttpRequest)
                    ref = new XMLHttpRequest();
                else if (window.ActiveXObject)
                    ref = new ActiveXObject("MSXML2.XMLHTTP.3.0");
                return ref;
            };
            Ajax.responseHandler = function (request, callback, type, errorCallback) {
                if (request.readyState != 4)
                    return;
                var status = request.status;
                if (status >= 200 && status < 300) {
                    if (callback) {
                        try {
                            var headers = {};
                            var headerStr = request.getAllResponseHeaders();
                            if (headerStr && (headerStr.length > 0)) {
                                var headerPairs = headerStr.split('\u000d\u000a');
                                for (var i = 0; i < headerPairs.length; ++i) {
                                    var sep = headerPairs[i].indexOf('\u003a\u0020');
                                    if (sep > 0)
                                        headers[headerPairs[i].substr(0, sep)] = headerPairs[i].substr(sep + 2);
                                }
                            }
                            switch (type) {
                                case "json":
                                    callback(util.Json.decode(request.responseText), headers);
                                    break;
                                case "xml":
                                    if (request.responseXML)
                                        return callback(request.responseXML, headers);
                                    if (DOMParser) {
                                        var parser = new DOMParser();
                                        var xml = parser.parseFromString(request.responseText, "text/xml");
                                        return callback(xml, headers);
                                    }
                                    util.Log.logError("error while loading xml file");
                                    callback(null, headers);
                                    break;
                                case "text":
                                    callback(request.responseText, headers);
                                    break;
                                case "binary":
                                    callback(request.response, headers);
                                    break;
                                case "image":
                                    callback(request.response, headers);
                                    break;
                                case "arraybuffer":
                                    callback(request.response, headers);
                                    break;
                                case "xml->json":
                                    callback(kr3m.xml.parseString(request.responseText), headers);
                                    break;
                            }
                        }
                        catch (e) {
                            util.Log.logError(e);
                        }
                    }
                }
                else if (errorCallback) {
                    errorCallback(status);
                }
            };
            Ajax.adjustMimeType = function (request, url, desiredType) {
                if (request instanceof XMLHttpRequest) {
                    switch (desiredType) {
                        case "json":
                            request.overrideMimeType("application/json");
                            break;
                        case "text":
                            request.overrideMimeType("text/plain");
                            break;
                    }
                }
            };
            Ajax.call = function (url, callback, type, errorCallback) {
                type = type || Ajax.getTypeFromUrl(url) || "json";
                var request = Ajax.getXMLHttpRequestObject();
                Ajax.adjustMimeType(request, url, type);
                request.onreadystatechange = Ajax.responseHandler.bind(null, request, callback, type, errorCallback);
                request.open("GET", url, true);
                if (type == "arraybuffer")
                    request.responseType = type;
                request.send();
                return request;
            };
            Ajax.callTimeout = function (url, successCallback, timeoutCallback, timeout, type) {
                if (timeout <= 0) {
                    Ajax.call(url, successCallback, type);
                    return;
                }
                var xhr = null;
                kr3m.async.Timeout.call(timeout, function (callback) {
                    xhr = Ajax.call(url, callback, type);
                }, successCallback, function () {
                    xhr.abort();
                    timeoutCallback();
                });
            };
            Ajax.postCall = function (url, callback, data, type) {
                if (data === void 0) { data = {}; }
                type = type || Ajax.getTypeFromUrl(url) || "json";
                var request = Ajax.getXMLHttpRequestObject();
                var encoded = {};
                for (var i in data)
                    encoded[i] = encodeURIComponent(data[i]);
                Ajax.adjustMimeType(request, url, type);
                var params = util.StringEx.joinAssoc(encoded);
                request.onreadystatechange = Ajax.responseHandler.bind(null, request, callback, type, null);
                request.open("POST", url, true);
                request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                request.send(params);
                return request;
            };
            Ajax.postCallTimeout = function (url, successCallback, timeoutCallback, timeout, data, type) {
                if (data === void 0) { data = {}; }
                if (timeout <= 0) {
                    Ajax.postCall(url, successCallback, data, type);
                    return;
                }
                var xhr = null;
                kr3m.async.Timeout.call(timeout, function (callback) {
                    xhr = Ajax.postCall(url, callback, data, type);
                }, successCallback, function () {
                    xhr.abort();
                    timeoutCallback();
                });
            };
            Ajax.callService = function (method, data, callback, type, errorCallback) {
                if (data === void 0) { data = {}; }
                var params = "method=" + method + "&payload=" + encodeURIComponent(util.Json.encode(data));
                if (Ajax.serviceUrl)
                    var url = Ajax.serviceUrl + "?_=" + (new Date()).getTime();
                else
                    var url = util.Browser.getBaseUrl() + "gateway?_=" + (new Date()).getTime();
                type = type || Ajax.getTypeFromUrl(url) || "json";
                var request = Ajax.getXMLHttpRequestObject();
                Ajax.adjustMimeType(request, url, type);
                request.onreadystatechange = Ajax.responseHandler.bind(null, request, callback, type, errorCallback);
                request.open("POST", url, true);
                request.setRequestHeader("Content-type", "application/x-www-form-urlencoded");
                request.send(params);
                return request;
            };
            Ajax.callServiceUnique = function (method, data, callback, type, errorCallback) {
                if (data === void 0) { data = {}; }
                var oldXhr = Ajax.pendingXhr[method];
                if (oldXhr)
                    oldXhr.abort();
                var xhr = Ajax.callService(method, data, function (response, headers) {
                    delete Ajax.pendingXhr[method];
                    callback && callback(response, headers);
                }, null, errorCallback);
                Ajax.pendingXhr[method] = xhr;
            };
            Ajax.callServiceTimeout = function (method, data, successCallback, timeoutCallback, timeout, type, errorCallback) {
                if (timeout <= 0) {
                    Ajax.callService(method, data, successCallback, type, errorCallback);
                    return;
                }
                var xhr = null;
                kr3m.async.Timeout.call(timeout, function (callback) {
                    xhr = Ajax.callService(method, data, callback, type, errorCallback);
                }, successCallback, function () {
                    xhr.abort();
                    timeoutCallback();
                });
            };
            Ajax.pendingXhr = {};
            Ajax.typesByExtension = [
                { pattern: /\.bmp$/i, type: "image" },
                { pattern: /\.css$/i, type: "text" },
                { pattern: /\.fnt$/i, type: "xml->json" },
                { pattern: /\.gif$/i, type: "image" },
                { pattern: /\.html$/i, type: "text" },
                { pattern: /\.jpeg$/i, type: "image" },
                { pattern: /\.jpg$/i, type: "image" },
                { pattern: /\.js$/i, type: "text" },
                { pattern: /\.json$/i, type: "json" },
                { pattern: /\.md5anim$/i, type: "text" },
                { pattern: /\.md5mesh$/i, type: "text" },
                { pattern: /\.mp3$/i, type: "binary" },
                { pattern: /\.ogg$/i, type: "binary" },
                { pattern: /\.php$/i, type: "json" },
                { pattern: /\.png$/i, type: "image" },
                { pattern: /\.txt$/i, type: "text" },
                { pattern: /\.xml$/i, type: "xml" }
            ];
            return Ajax;
        }());
        util.Ajax = Ajax;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var services;
    (function (services) {
        var AjaxStub = (function () {
            function AjaxStub() {
                this.cache = {};
                this.showServiceCallsInLog = false;
                this.htmlEscapeStrings = true;
                this.timeoutDuration = 0;
                this.cacheDuration = 600000;
            }
            AjaxStub.prototype.cleanResult = function (key, value, result) {
                var type = typeof (value);
                if (type == "string") {
                    var newValue = value;
                    if (this.htmlEscapeStrings)
                        newValue = kr3m.util.Util.encodeHtml(newValue);
                    if (newValue != value)
                        kr3m.util.Util.setProperty(result, key, newValue);
                }
            };
            AjaxStub.prototype.callService = function (serviceName, params, callback, timeoutCallback, errorCallback) {
                var _this = this;
                if (params === void 0) { params = {}; }
                if (this.showServiceCallsInLog) {
                    kr3m.util.Log.log("<== " + serviceName);
                    kr3m.util.Log.log(params);
                }
                kr3m.util.Ajax.callServiceTimeout(serviceName, params, function (result, headers) {
                    kr3m.util.Util.forEachRecursive(result, _this.cleanResult.bind(_this));
                    if (_this.showServiceCallsInLog) {
                        kr3m.util.Log.log("==> " + serviceName);
                        kr3m.util.Log.log(result);
                    }
                    callback && callback(result, headers);
                }, function () {
                    if (_this.showServiceCallsInLog)
                        kr3m.util.Log.log("<== " + serviceName + " [TIMEOUT]");
                    timeoutCallback && timeoutCallback();
                }, this.timeoutDuration, null, errorCallback);
            };
            AjaxStub.prototype.callServiceCached = function (serviceName, params, callback, timeoutCallback, errorCallback) {
                var _this = this;
                if (params === void 0) { params = {}; }
                if (!callback)
                    return this.callService(serviceName, params);
                var key = serviceName + "(" + kr3m.util.Json.encode(params) + ")";
                var item = this.cache[key];
                if (item && item.expires >= new Date())
                    return callback(kr3m.util.Util.clone(item.response));
                this.callService(serviceName, params, function (response) {
                    var expires = new Date();
                    expires.setTime(expires.getTime() + _this.cacheDuration);
                    var item = { expires: expires, response: response };
                    _this.cache[key] = item;
                    callback(kr3m.util.Util.clone(item.response));
                }, timeoutCallback, errorCallback);
            };
            AjaxStub.prototype.clearCache = function (serviceName, params) {
                if (params) {
                    var key = serviceName + "(" + kr3m.util.Json.encode(params) + ")";
                    if (this.cache[key])
                        delete this.cache[key];
                }
                else {
                    serviceName += "(";
                    for (var i in this.cache) {
                        if (i.indexOf(serviceName) == 0)
                            delete this.cache[i];
                    }
                }
            };
            return AjaxStub;
        }());
        services.AjaxStub = AjaxStub;
    })(services = kr3m.services || (kr3m.services = {}));
})(kr3m || (kr3m = {}));
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Abstract = (function (_super) {
            __extends(Abstract, _super);
            function Abstract() {
                var _this = _super.call(this) || this;
                _this.htmlEscapeStrings = false;
                return _this;
            }
            return Abstract;
        }(kr3m.services.AjaxStub));
        stubs.Abstract = Abstract;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var Comment = (function () {
            function Comment() {
            }
            return Comment;
        }());
        vo.Comment = Comment;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var EvaluationData = (function () {
            function EvaluationData() {
                this.scoreCubes = 0;
                this.scoreTotal = 0;
                this.scoreTrack = [0, 0, 0, 0, 0];
                this.scoreSubstructure = 0;
                this.cubes = 0;
                this.track = [0, 0, 0, 0, 0];
                this.substructure = 0;
            }
            return EvaluationData;
        }());
        vo.EvaluationData = EvaluationData;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var TrackData = (function () {
            function TrackData() {
                this.evaluation = new cuboro.vo.EvaluationData();
            }
            return TrackData;
        }());
        vo.TrackData = TrackData;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var User = (function () {
            function User() {
            }
            return User;
        }());
        vo.User = User;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var Track = (function () {
            function Track() {
                this.data = new cuboro.vo.TrackData();
            }
            return Track;
        }());
        vo.Track = Track;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Comment = (function (_super) {
            __extends(Comment, _super);
            function Comment() {
                var _this = _super.call(this) || this;
                _this.htmlEscapeStrings = false;
                return _this;
            }
            Comment.prototype.saveTrackComment = function (trackId, comment, callback) {
                var params = { trackId: trackId, comment: comment };
                this.callService("Comment.saveTrackComment", params, function (response) { return callback(response.data, response.status); });
            };
            Comment.prototype.getTrackComment = function (trackId, callback) {
                var params = { trackId: trackId };
                this.callService("Comment.getTrackComment", params, function (response) { return callback(response.data, response.status); });
            };
            Comment.prototype.reportAbuse = function (commentId, callback) {
                var params = { commentId: commentId };
                this.callService("Comment.reportAbuse", params, function (response) { return callback(response.data, response.status); });
            };
            return Comment;
        }(stubs.Abstract));
        stubs.Comment = Comment;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sComment = new cuboro.stubs.Comment();
var kr3m;
(function (kr3m) {
    var model;
    (function (model) {
        var EventDispatcher = (function () {
            function EventDispatcher() {
                this.onListeners = {};
                this.onceListeners = {};
            }
            EventDispatcher.prototype.on = function (eventName, listener, context) {
                if (!this.onListeners[eventName])
                    this.onListeners[eventName] = [];
                var meta = kr3m.util.Util.getBy(this.onListeners[eventName], "context", context, 0, true);
                if (meta) {
                    meta.listeners.push(listener);
                    return;
                }
                this.onListeners[eventName].push({ context: context, listeners: [listener] });
            };
            EventDispatcher.prototype.once = function (eventName, listener, context) {
                if (!this.onceListeners[eventName])
                    this.onceListeners[eventName] = [];
                var meta = kr3m.util.Util.getBy(this.onceListeners[eventName], "context", context, 0, true);
                if (meta) {
                    meta.listeners.push(listener);
                    return;
                }
                this.onceListeners[eventName].push({ context: context, listeners: [listener] });
            };
            EventDispatcher.prototype.off = function () {
                var first = kr3m.util.Util.getFirstOfType.bind(null, arguments);
                var eventName = first("string");
                var listener = first("function");
                var context = first("object");
                var listenerTypes = [this.onListeners, this.onceListeners];
                var eventNames = eventName ? [eventName] : kr3m.util.Util.merge(Object.keys(this.onListeners), Object.keys(this.onceListeners));
                for (var i = 0; i < listenerTypes.length; ++i) {
                    for (var j = 0; j < eventNames.length; ++j) {
                        var metas = listenerTypes[i][eventNames[j]];
                        if (!metas)
                            continue;
                        for (var k = 0; k < metas.length; ++k) {
                            if (context && context !== metas[k].context)
                                continue;
                            if (listener)
                                kr3m.util.Util.remove(metas[k].listeners, listener, true);
                            else
                                metas[k].listeners = [];
                        }
                    }
                }
            };
            EventDispatcher.prototype.dispatch = function (eventName, data, context) {
                if (this.onListeners[eventName]) {
                    for (var i = 0; i < this.onListeners[eventName].length; ++i) {
                        for (var j = 0; j < this.onListeners[eventName][i].listeners.length; ++j)
                            this.onListeners[eventName][i].listeners[j].call(context || this.onListeners[eventName][i].context || this, data);
                    }
                }
                if (this.onceListeners[eventName]) {
                    for (var i = 0; i < this.onceListeners[eventName].length; ++i) {
                        for (var j = 0; j < this.onceListeners[eventName][i].listeners.length; ++j)
                            this.onceListeners[eventName][i].listeners[j].call(context || this.onceListeners[eventName][i].context || this, data);
                    }
                    this.onceListeners[eventName] = [];
                }
            };
            return EventDispatcher;
        }());
        model.EventDispatcher = EventDispatcher;
    })(model = kr3m.model || (kr3m.model = {}));
})(kr3m || (kr3m = {}));
var cuboro;
(function (cuboro) {
    var clientmodels;
    (function (clientmodels) {
        var Comment = (function (_super) {
            __extends(Comment, _super);
            function Comment() {
                return _super.call(this) || this;
            }
            Comment.prototype.saveTrackComment = function (trackId, comment) {
                sComment.saveTrackComment(trackId, comment, function (status) {
                    console.log("status ", status);
                });
            };
            Comment.prototype.reportAbuse = function (commentId) {
                sComment.reportAbuse(commentId, function (status) {
                    console.log(" status ", status);
                });
            };
            return Comment;
        }(kr3m.model.EventDispatcher));
        clientmodels.Comment = Comment;
    })(clientmodels = cuboro.clientmodels || (cuboro.clientmodels = {}));
})(cuboro || (cuboro = {}));
var mComment = new cuboro.clientmodels.Comment();
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Mail = (function (_super) {
            __extends(Mail, _super);
            function Mail() {
                var _this = _super.call(this) || this;
                _this.htmlEscapeStrings = false;
                return _this;
            }
            Mail.prototype.sendEcard = function (trackId, recipienEmail, recipienName, senderEmail, senderName, message, callback) {
                var params = { trackId: trackId, recipienEmail: recipienEmail, recipienName: recipienName, senderEmail: senderEmail, senderName: senderName, message: message };
                this.callService("Mail.sendEcard", params, function (response) { return callback(response.data, response.status); });
            };
            Mail.prototype.sendContact = function (senderName, senderEmail, senderMessage, callback) {
                var params = { senderName: senderName, senderEmail: senderEmail, message: senderMessage };
                this.callService("Mail.sendContact", params, function (response) { return callback(response.data, response.status); });
            };
            return Mail;
        }(stubs.Abstract));
        stubs.Mail = Mail;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sMail = new cuboro.stubs.Mail();
var cuboro;
(function (cuboro) {
    var clientmodels;
    (function (clientmodels) {
        var Mail = (function (_super) {
            __extends(Mail, _super);
            function Mail() {
                return _super.call(this) || this;
            }
            Mail.prototype.sendEcard = function (trackId, recepienEmail, recepienName, senderEmail, senderName, message) {
                sMail.sendEcard(trackId, recepienEmail, recepienName, senderEmail, senderName, message, function (status) {
                    console.log(" status : ", status);
                });
            };
            return Mail;
        }(kr3m.model.EventDispatcher));
        clientmodels.Mail = Mail;
    })(clientmodels = cuboro.clientmodels || (cuboro.clientmodels = {}));
})(cuboro || (cuboro = {}));
var mMail = new cuboro.clientmodels.Mail();
var mTrack = new cuboro.vo.Track();
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var User = (function (_super) {
            __extends(User, _super);
            function User() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            User.prototype.login = function (casUserId, casToken, callback) {
                var params = { casUserId: casUserId, casToken: casToken };
                this.callService("User.login", params, function (response) { return callback && callback(response.data, response.status); });
            };
            User.prototype.logout = function (callback) {
                var params = {};
                this.callService("User.logout", params, function (response) { return callback && callback(response.status); });
            };
            return User;
        }(stubs.Abstract));
        stubs.User = User;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sUser = new cuboro.stubs.User();
var cuboro;
(function (cuboro) {
    var clientmodels;
    (function (clientmodels) {
        var User = (function (_super) {
            __extends(User, _super);
            function User() {
                var _this = _super.call(this) || this;
                casClient.addEventListener(_this.handleCasEvent.bind(_this));
                return _this;
            }
            User.prototype.handleCasEvent = function (eventName, params) {
                var _this = this;
                switch (eventName) {
                    case cas.EVENT_ONLINE:
                        this.dispatch("login");
                        casClient.getUser(function (casUser) {
                            casClient.getToken(function (casToken) {
                                sUser.login(casUser.id, casToken, function (user, status) {
                                    if (status != kr3m.SUCCESS) {
                                        _this.user = null;
                                        _this.casUser = null;
                                        return;
                                    }
                                    _this.user = user;
                                    _this.casUser = casUser;
                                    _this.dispatch("loggedIn");
                                });
                            });
                        });
                        break;
                    case cas.EVENT_LOGOUT:
                        this.user = null;
                        this.casUser = null;
                        sUser.logout();
                        this.dispatch("logout");
                        break;
                }
            };
            User.prototype.isLoggedIn = function () {
                return !!this.user;
            };
            User.prototype.getUserId = function () {
                return this.isLoggedIn() ? this.user.id : null;
            };
            User.prototype.getUser = function () {
                return this.isLoggedIn() ? this.user : null;
            };
            return User;
        }(kr3m.model.EventDispatcher));
        clientmodels.User = User;
    })(clientmodels = cuboro.clientmodels || (cuboro.clientmodels = {}));
})(cuboro || (cuboro = {}));
var mUser = new cuboro.clientmodels.User();
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var gallery;
        (function (gallery) {
            var Filters = (function () {
                function Filters() {
                    this.offset = 0;
                    this.limit = 20;
                    this.sortBy = "rating";
                    this.own = false;
                    this.edu = false;
                }
                return Filters;
            }());
            gallery.Filters = Filters;
        })(gallery = vo.gallery || (vo.gallery = {}));
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var gallery;
        (function (gallery) {
            var Page = (function () {
                function Page() {
                }
                return Page;
            }());
            gallery.Page = Page;
        })(gallery = vo.gallery || (vo.gallery = {}));
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Gallery = (function (_super) {
            __extends(Gallery, _super);
            function Gallery() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Gallery.prototype.getPage = function (filters, callback) {
                var params = { filters: filters };
                this.callService("Gallery.getPage", params, function (response) { return callback(response.data, response.status); });
            };
            return Gallery;
        }(stubs.Abstract));
        stubs.Gallery = Gallery;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sGallery = new cuboro.stubs.Gallery();
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var History = (function () {
            function History() {
            }
            return History;
        }());
        vo.History = History;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Track = (function (_super) {
            __extends(Track, _super);
            function Track() {
                var _this = _super.call(this) || this;
                _this.htmlEscapeStrings = false;
                return _this;
            }
            Track.prototype.generateUniqueRandomName = function (namePrefix, callback) {
                var params = { namePrefix: namePrefix };
                this.callService("Track.generateUniqueRandomName", params, function (response) { return callback(response.data); });
            };
            Track.prototype.delete = function (trackId, callback) {
                var params = { trackId: trackId };
                this.callService("Track.delete", params, function (response) { return callback(response.status); });
            };
            Track.prototype.unpublish = function (trackId, callback) {
                var params = { trackId: trackId };
                this.callService("Track.unpublish", params, function (response) { return callback(response.status); });
            };
            Track.prototype.publish = function (trackId, name, callback) {
                var params = { trackId: trackId, name: name };
                this.callService("Track.publish", params, function (response) { return callback(response.status); });
            };
            Track.prototype.load = function (trackId, callback) {
                var params = { trackId: trackId };
                this.callService("Track.load", params, function (response) { return callback(response.data, response.status); });
            };
            Track.prototype.save = function (trackData, name, overwrite, previousId, callback) {
                var params = { trackData: trackData, name: name, overwrite: overwrite, previousId: previousId };
                this.callService("Track.save", params, function (response) { return callback(response.data, response.status); });
            };
            Track.prototype.saveTrackImage = function (trackId, name, trackImage, callback) {
                var params = { trackId: trackId, name: name, trackImage: trackImage };
                this.callService("Track.saveTrackImage", params, function (response) { return callback(response.data); });
            };
            Track.prototype.isNameUnique = function (trackId, name, callback) {
                var params = { trackId: trackId, newName: name };
                this.callService("Track.isNameUnique", params, function (response) { return callback(response.data, response.status); });
            };
            Track.prototype.isPublished = function (trackId, callback) {
                var params = { trackId: trackId };
                this.callService("Track.isPublished", params, function (response) { return callback(response.data, response.status); });
            };
            Track.prototype.getHistory = function (trackId, callback) {
                var params = { trackId: trackId };
                this.callService("Track.getHistory", params, function (response) { return callback(response.data, response.status); });
            };
            return Track;
        }(stubs.Abstract));
        stubs.Track = Track;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sTrack = new cuboro.stubs.Track();
var cuboro;
(function (cuboro) {
    var clientmodels;
    (function (clientmodels) {
        var RunTestResult = (function () {
            function RunTestResult() {
            }
            return RunTestResult;
        }());
        var TrackTestResults = (function () {
            function TrackTestResults() {
                this.runs = [];
            }
            return TrackTestResults;
        }());
        var Tests = (function () {
            function Tests() {
                this.propMap = {
                    angularDamping: "pg.marble.body.angularDamping",
                    angularFactorX: "pg.marble.body.angularFactor.x",
                    angularFactorY: "pg.marble.body.angularFactor.y",
                    angularFactorZ: "pg.marble.body.angularFactor.z",
                    friction: "pg.world.defaultContactMaterial.friction",
                    gravity: "pg.world.gravity.y",
                    linearDamping: "pg.marble.body.linearDamping",
                    linearFactorX: "pg.marble.body.linearFactor.x",
                    linearFactorY: "pg.marble.body.linearFactor.y",
                    linearFactorZ: "pg.marble.body.linearFactor.z",
                    restitution: "pg.world.defaultContactMaterial.restitution",
                    mass: "pg.marble.body.mass"
                };
                this.initialized = false;
                this.running = false;
                this.cancelled = false;
            }
            Tests.prototype.onMarbleCollision = function (body) {
                if (body.id === this.pg.ground.body.id && !this.currentRun.groundTouchPosition) {
                    this.currentRun.groundTouchPosition = this.pg.marble.body.position.clone();
                    this.currentRun.groundTouchVelocity = this.pg.marble.body.velocity.clone();
                    this.currentRun.groundTouchRotation = this.pg.marble.body.quaternion.clone();
                }
            };
            Tests.prototype.showProps = function () {
                var props = {};
                for (var prop in this.propMap)
                    props[prop] = kr3m.util.Util.getProperty(this, this.propMap[prop]);
                log("props", props);
            };
            Tests.prototype.setProp = function (prop, value) {
                if (!this.propMap[prop])
                    return logError("unknown property name:", prop);
                kr3m.util.Util.setProperty(this, this.propMap[prop], value);
                log(prop, "set to", value);
            };
            Tests.prototype.cancel = function () {
                this.cancelled = true;
                log("----------------------------------------");
                log("automated tests will be cancelled after next run");
                log("----------------------------------------");
            };
            Tests.prototype.setDropHeight = function (value, height) {
                cuboro.MARBLE_DROP_HEIGHTS[value] = height;
                this.pg.gameScreen.bottomMenu.btDropHeight.dropHeight = value;
            };
            Tests.prototype.loadTrack = function (track, callback) {
                this.pg.once(cuboro.PLAYGROUND_READY, callback, this);
                cuboro.core.Loader.loadTrack(this.pg.game, track, false);
            };
            Tests.prototype.startRun = function (startCube, dropHeightId, callback) {
                var _this = this;
                this.currentRun = new RunTestResult();
                this.currentRun.cubeMapPosition = startCube.mapPosition.clone();
                this.currentRun.dropHeight = dropHeightId;
                var startTime = Date.now();
                var freeMapY = this.pg.map.getNextEmptyY(startCube.mapPosition.x, startCube.mapPosition.z);
                var position = this.pg.map.to3DPos(startCube.mapPosition.x, freeMapY, startCube.mapPosition.z);
                this.pg.gameScreen.bottomMenu.btDropHeight.dropHeight = cuboro.MARBLE_DROP_HEIGHTS[dropHeightId];
                position.y += cuboro.MARBLE_DROP_HEIGHTS[dropHeightId];
                this.pg.marble.x = position.x;
                this.pg.marble.y = position.y;
                this.pg.marble.z = position.z;
                this.pg.marble.mesh.visible = true;
                this.pg.cubes.highlightMarble(true);
                this.pg.marble.start();
                this.pg.marble.once("stop", function () {
                    _this.currentRun.reachedGround = _this.pg.marble.isOnGround();
                    _this.currentRun.reachedContainer = _this.pg.marble.isInContainer();
                    _this.currentRun.hasSkipped = _this.pg.marble.hasSkipped();
                    _this.currentRun.success = !_this.currentRun.hasSkipped && (_this.currentRun.reachedGround || _this.currentRun.reachedContainer);
                    _this.currentRun.duration = Date.now() - startTime;
                    _this.currentRun.duration *= _this.pg.physicSpeedFactor;
                    _this.currentRun.score = _this.pg.evaluation.current.scoreTotal;
                    var result = _this.currentRun;
                    _this.currentRun = undefined;
                    setTimeout(function () { return callback(result); }, 1);
                });
            };
            Tests.prototype.showRunResult = function (run) {
                var outputs = [
                    "start:", run.cubeMapPosition,
                    "dropHeight:", run.dropHeight,
                    "score:", run.score,
                    "duration:", (run.duration / 1000).toFixed(1) + "s",
                    "hasSkipped:", run.hasSkipped,
                    "reachedGround:", run.reachedGround,
                    "reachedContainer:", run.reachedContainer,
                    "groundTouchPosition:", run.groundTouchPosition,
                    "groundTouchVelocity:", run.groundTouchVelocity,
                    "groundTouchRotation:", run.groundTouchRotation
                ];
                if (run.success)
                    outputs.unshift("%cSUCCESS", "background-color: green; color: white; padding: 5px;");
                else
                    outputs.unshift("%cFAILURE", "background-color: red; color: white; padding: 5px;");
                log.apply(void 0, outputs);
            };
            Tests.prototype.runTests = function (callback) {
                var _this = this;
                log("testing track", mTrack.id, "-", mTrack.name);
                var trackResults = new TrackTestResults();
                trackResults.trackId = mTrack.id;
                trackResults.trackName = mTrack.name;
                var cubes = this.pg.cubes.getHighestStartCubes();
                if (cubes.length == 0) {
                    trackResults.success = false;
                    logError("no starting cube found on the highest level");
                    return callback(trackResults);
                }
                kr3m.async.Loop.forEach(cubes, function (cube, nextCube) {
                    kr3m.async.Loop.forEachAssoc(cuboro.MARBLE_DROP_HEIGHTS, function (dropHeightId, dropHeight, nextHeight) {
                        if (_this.cancelled) {
                            _this.pg.physicSpeedFactor = 1;
                            _this.running = false;
                            return log("automatic testing cancelled by user");
                        }
                        _this.startRun(cube, dropHeightId, function (runResult) {
                            trackResults.runs.push(runResult);
                            _this.showRunResult(runResult);
                            nextHeight();
                        });
                    }, nextCube);
                }, function () { return callback(trackResults); });
            };
            Tests.prototype.showResults = function (results) {
                log("----------------------------------------");
                log("test run results");
                log("----------------------------------------");
                var totalRuns = 0;
                var totalSuccesses = 0;
                for (var i = 0; i < results.length; ++i) {
                    totalRuns += results[i].runs.length;
                    for (var j = 0; j < results[i].runs.length; ++j) {
                        if (results[i].runs[j].success)
                            ++totalSuccesses;
                    }
                }
                log("successfull", totalSuccesses, "/", totalRuns);
            };
            Tests.prototype.init = function () {
                var _this = this;
                this.initialized = true;
                this.pg.marble.body.addEventListener("collide", function (event) { return _this.onMarbleCollision(event.body); });
            };
            Tests.prototype.run = function (speed, trackIds) {
                var _this = this;
                if (speed === void 0) { speed = 1; }
                if (this.running)
                    return log("automated tests are already running");
                if (!this.initialized) {
                    this.init();
                }
                console.clear();
                log("----------------------------------------");
                log("running automated tests");
                log("----------------------------------------");
                this.running = true;
                this.cancelled = false;
                this.pg.physicSpeedFactor = speed;
                if (!mUser.isLoggedIn())
                    return logError("user is not logged in");
                var filters = new cuboro.vo.gallery.Filters();
                filters.limit = 999999999;
                filters.own = true;
                sGallery.getPage(filters, function (page, status) {
                    if (status != kr3m.SUCCESS)
                        return logError("error while loading tracks");
                    var results = [];
                    var tracks;
                    if (trackIds)
                        tracks = page.tracks.filter(function (track) { return trackIds.indexOf(track.id) >= 0; });
                    else
                        tracks = page.tracks;
                    log("testing " + tracks.length + " tracks");
                    kr3m.async.Loop.forEach(tracks, function (track, next) {
                        _this.loadTrack(track, function () {
                            _this.runTests(function (result) {
                                results.push(result);
                                if (_this.cancelled) {
                                    _this.pg.physicSpeedFactor = 1;
                                    _this.running = false;
                                    return log("automatic testing cancelled by user");
                                }
                                next();
                            });
                        });
                    }, function () {
                        _this.pg.physicSpeedFactor = 1;
                        _this.running = false;
                        log("tests completed");
                        _this.showResults(results);
                    });
                });
            };
            return Tests;
        }());
        clientmodels.Tests = Tests;
    })(clientmodels = cuboro.clientmodels || (cuboro.clientmodels = {}));
})(cuboro || (cuboro = {}));
var mTests = new cuboro.clientmodels.Tests();
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Align = (function () {
            function Align() {
            }
            Align.centerX = function (value, alignTo) {
                if (!alignTo)
                    alignTo = value.game;
                var w;
                var px = 0;
                if (typeof alignTo === "number") {
                    w = alignTo;
                }
                else if (alignTo instanceof gf.core.Game) {
                    w = value.game.width;
                }
                else {
                    px = alignTo.getLocalBounds().x;
                    if (alignTo.scale) {
                        w = (alignTo.width / alignTo.scale.x) >> 0;
                    }
                    else {
                        w = alignTo.width >> 0;
                    }
                }
                return ((w - value.width) >> 1);
            };
            Align.centerY = function (value, alignTo) {
                if (!alignTo)
                    alignTo = value.game;
                var h;
                var py = 0;
                if (typeof alignTo === "number") {
                    h = alignTo;
                }
                else if (alignTo instanceof gf.core.Game) {
                    h = value.game.height;
                }
                else {
                    py = alignTo.getLocalBounds().y;
                    if (alignTo.scale) {
                        h = (alignTo.height / alignTo.scale.y) >> 0;
                    }
                    else {
                        h = alignTo.height >> 0;
                    }
                }
                return ((h - value.height) >> 1);
            };
            Align.hAlign = function (value, align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                if (!value.alignData)
                    return;
                if (align == gf.NONE) {
                    value.alignData.hAlignValue = null;
                    value.alignData.hAlignOffset = null;
                    value.alignData.hAlignParent = null;
                    return;
                }
                value.alignData.hAlignValue = align;
                value.alignData.hAlignOffset = offset;
                if (!alignTo)
                    value.alignData.hAlignParent = alignTo = value.game;
                else
                    value.alignData.hAlignParent = alignTo;
                var w;
                var px = 0;
                if (typeof alignTo === "number") {
                    w = alignTo;
                }
                else if (alignTo instanceof gf.core.Game) {
                    w = value.game.width;
                }
                else {
                    px = alignTo.getLocalBounds().x;
                    if (value.alignData.hAlignParent.scale) {
                        w = (value.alignData.hAlignParent.width / value.alignData.hAlignParent.scale.x) >> 0;
                    }
                    else {
                        w = value.alignData.hAlignParent.width >> 0;
                    }
                }
                if (align == gf.LEFT) {
                    value.position.x = offset;
                }
                else if (align == gf.CENTER) {
                    value.position.x = ((w - value.width) >> 1) + offset;
                }
                else if (align == gf.RIGHT) {
                    value.position.x = w - value.width + offset;
                }
                value.position.x += px - value.getLocalBounds().x;
            };
            Align.vAlign = function (value, align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                if (!value.alignData)
                    return;
                if (align == gf.NONE) {
                    value.alignData.vAlignValue = null;
                    value.alignData.vAlignOffset = null;
                    value.alignData.vAlignParent = null;
                    return;
                }
                value.alignData.vAlignValue = align;
                value.alignData.vAlignOffset = offset;
                if (!alignTo)
                    value.alignData.vAlignParent = alignTo = value.game;
                else
                    value.alignData.vAlignParent = alignTo;
                var h;
                var py = 0;
                if (typeof alignTo == "number") {
                    h = alignTo;
                }
                else if (alignTo instanceof gf.core.Game) {
                    h = value.game.height;
                }
                else {
                    py = alignTo.getLocalBounds().y;
                    if (value.alignData.vAlignParent.scale) {
                        h = (value.alignData.vAlignParent.height / value.alignData.vAlignParent.scale.y) >> 0;
                    }
                    else {
                        h = value.alignData.vAlignParent.height >> 0;
                    }
                }
                if (align == gf.TOP) {
                    value.position.y = offset;
                }
                else if (align == gf.CENTER) {
                    value.position.y = ((h - value.height) >> 1) + offset;
                }
                else if (align == gf.BOTTOM) {
                    value.position.y = h - value.height + offset;
                }
                value.position.y += py - value.getLocalBounds().y;
            };
            Align.onResize = function (value) {
                if (value.alignData) {
                    if (value.alignData.hAlignValue && value.alignData.hAlignValue != gf.NONE) {
                        value.hAlign(value.alignData.hAlignValue, value.alignData.hAlignParent, value.alignData.hAlignOffset);
                    }
                    if (value.alignData.vAlignValue && value.alignData.vAlignValue != gf.NONE) {
                        value.vAlign(value.alignData.vAlignValue, value.alignData.vAlignParent, value.alignData.vAlignOffset);
                    }
                }
                value.children.forEach(function (child) {
                    if (typeof child["onResize"] == "function" && child.parent === value)
                        child["onResize"]();
                });
            };
            Align.left = function (value) {
                return value.position.x + value.getLocalBounds().x;
            };
            Align.right = function (value) {
                return value.left + value.width;
            };
            Align.top = function (value) {
                return value.position.y + value.getLocalBounds().y;
            };
            Align.bottom = function (value) {
                return value.top + value.height;
            };
            return Align;
        }());
        utils.Align = Align;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var AlignData = (function () {
            function AlignData() {
                this.hAlignOffset = 0;
                this.hAlignValue = gf.NONE;
                this.vAlignOffset = 0;
                this.vAlignValue = gf.NONE;
            }
            return AlignData;
        }());
        utils.AlignData = AlignData;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Maths = (function () {
            function Maths() {
            }
            Maths.intersectRectRect = function (r1, r2) {
                if (r1.x < r2.x + r2.width && r2.x < r1.x + r1.width && r1.y < r2.y + r2.height) {
                    return r2.y < r1.y + r1.height;
                }
                else {
                    return false;
                }
            };
            Maths.intersectCircleRect = function (cx, cy, radius, r) {
                var closestX = (cx < r.x ? r.x : (cx > r.x + r.width ? r.x + r.width : cx));
                var closestY = (cy < r.y ? r.y : (cy > r.y + r.height ? r.y + r.height : cy));
                var dx = closestX - cx;
                var dy = closestY - cy;
                return (dx * dx + dy * dy) <= radius * radius;
            };
            Maths.intersectCircleCircle = function (x1, y1, r1, x2, y2, r2) {
                var dx = x1 - x2;
                var dy = y1 - y2;
                var len = Math.sqrt(dx * dx + dy * dy);
                return len < r1 + r2;
            };
            Maths.distance = function (value1, value2, x2, y2) {
                var dx;
                var dy;
                if (isNaN(value1)) {
                    dx = value1.x - value2.x;
                    dy = value1.y - value2.y;
                }
                else {
                    dx = value1 - x2;
                    dy = value2 - y2;
                }
                return Math.sqrt(dx * dx + dy * dy);
            };
            Maths.lerp = function (pt1, pt2, f) {
                var x = f * pt1.x + (1 - f) * pt2.x;
                var y = f * pt1.y + (1 - f) * pt2.y;
                return { x: x, y: y };
            };
            Maths.degToRad = function (degrees) {
                return degrees * this.degreeToRadiansFactor;
            };
            Maths.radToDeg = function (radians) {
                return radians * this.radianToDegreesFactor;
            };
            Maths.round = function (value, factor) {
                return value - (value % factor) + ((value % factor > 0 || value == 0) && factor);
            };
            Maths.clamp = function (value, min, max) {
                return (value < min) ? min : ((value > max) ? max : value);
            };
            Maths.wrapAngle = function (angle, radians) {
                if (radians === void 0) { radians = false; }
                var radianFactor = (radians) ? Math.PI / 180 : 1;
                return this.wrap(angle, -180 * radianFactor, 180 * radianFactor);
            };
            Maths.normalizeAngle = function (angle) {
                angle = angle % gf.utils.Maths.TWO_PI;
                if (angle < -Math.PI)
                    angle += gf.utils.Maths.TWO_PI;
                if (angle > Math.PI)
                    angle -= gf.utils.Maths.TWO_PI;
                return angle;
            };
            Maths.wrap = function (value, min, max) {
                var range = max - min;
                if (range <= 0) {
                    return 0;
                }
                var result = (value - min) % range;
                if (result < 0) {
                    result += range;
                }
                return result + min;
            };
            Maths.random = function (min, max) {
                return Math.floor(Math.random() * (max - min + 1)) + min;
            };
            Maths.randomFloat = function (min, max) {
                return Math.random() * (max - min) + min;
            };
            Maths.randomElement = function (array, except) {
                if (!array)
                    return undefined;
                if (array.length == 0)
                    return undefined;
                if (array.length == 0)
                    return undefined;
                var result = array[gf.utils.Maths.random(0, array.length - 1)];
                var found = false;
                if (except && except.length > 0) {
                    if (except.indexOf(result) != -1)
                        found = true;
                }
                if (found)
                    return this.randomElement(array, except);
                return result;
            };
            Maths.shuffle = function (array) {
                var j, x, i;
                for (i = array.length; i; --i) {
                    j = Math.floor(Math.random() * i);
                    x = array[i - 1];
                    array[i - 1] = array[j];
                    array[j] = x;
                }
                return array;
            };
            Maths.shuffledInts = function (count) {
                var result = [];
                for (var i = 0; i < count; ++i)
                    result.push(i);
                return gf.utils.Maths.shuffle(result);
            };
            Maths.TWO_PI = Math.PI * 2;
            Maths.degreeToRadiansFactor = Math.PI / 180;
            Maths.radianToDegreesFactor = 180 / Math.PI;
            return Maths;
        }());
        utils.Maths = Maths;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Angle = (function () {
            function Angle() {
            }
            Angle.getAngle = function (value) {
                return gf.utils.Maths.wrapAngle(gf.utils.Maths.radToDeg(value.rotation));
            };
            Angle.setAngle = function (display, value) {
                display.rotation = gf.utils.Maths.degToRad(gf.utils.Maths.wrapAngle(value));
            };
            return Angle;
        }());
        utils.Angle = Angle;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Scale = (function () {
            function Scale() {
            }
            Scale.getScaleX = function (value) {
                return value.scale.x;
            };
            Scale.setScaleX = function (display, value) {
                display.scale.x = value;
            };
            Scale.getScaleY = function (value) {
                return value.scale.y;
            };
            Scale.setScaleY = function (display, value) {
                display.scale.y = value;
            };
            Scale.setScaleXY = function (display, value) {
                display.scale.set(value, value);
            };
            return Scale;
        }());
        utils.Scale = Scale;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Slice9 = (function (_super) {
            __extends(Slice9, _super);
            function Slice9(game, leftWidth, topHeight, rightWidth, bottomHeight, key, frameName) {
                var _this = _super.call(this, game.cache.getTexture("__default"), leftWidth / game.client.config.assetsResolution, topHeight / game.client.config.assetsResolution, rightWidth / game.client.config.assetsResolution, bottomHeight / game.client.config.assetsResolution) || this;
                _this.game = game;
                _this.name = "";
                _this.alignData = new gf.utils.AlignData();
                _this.userData = {};
                _this._key = key;
                _this._frameName = frameName;
                _this.updateTexture();
                return _this;
            }
            Slice9.prototype.updateRegions = function (leftWidth, topHeight, rightWidth, bottomHeight) {
                var w = this.width;
                var h = this.height;
                this.leftWidth = leftWidth / this.game.client.config.assetsResolution;
                this.topHeight = topHeight / this.game.client.config.assetsResolution;
                this.rightWidth = rightWidth / this.game.client.config.assetsResolution;
                this.bottomHeight = bottomHeight / this.game.client.config.assetsResolution;
                this.updateTexture();
                this.width = w;
                this.height = h;
            };
            Slice9.prototype.updateTexture = function () {
                var resolution = 1;
                if (Slice9.EXTRACT_FULL_RESOLUTION_TEXTURE_FROM_ATLAS == true) {
                    if (this.key instanceof PIXI.Texture) {
                        resolution = this.key.baseTexture.resolution;
                    }
                    else {
                        resolution = PIXI.utils.TextureCache[this.key.toString()].baseTexture.resolution;
                    }
                }
                else {
                    resolution = (this.game.renderer instanceof PIXI.WebGLRenderer) ? 1 : this.game.renderer.resolution;
                }
                if (this._frameName) {
                    if (!PIXI.utils.TextureCache[this.key + "-" + this._frameName]) {
                        var sprite = new gf.display.Sprite(this.game, this.key, this._frameName);
                        var brt = new PIXI.BaseRenderTexture(sprite.width * resolution, sprite.height * resolution, PIXI.SCALE_MODES.LINEAR, resolution);
                        var rt = new PIXI.RenderTexture(brt);
                        if (Slice9.EXTRACT_FULL_RESOLUTION_TEXTURE_FROM_ATLAS == true) {
                            if (this.game.renderer instanceof PIXI.WebGLRenderer) {
                                sprite.scaleX = resolution;
                                sprite.scaleY = resolution;
                            }
                        }
                        this.game.renderer.render(sprite, rt);
                        PIXI.Texture.addTextureToCache(rt, this.key + "-" + this._frameName);
                    }
                    this.texture = PIXI.Texture.fromFrame(this.key + "-" + this._frameName);
                }
                else {
                    this.texture = PIXI.Texture.fromFrame(this.key);
                }
                this._origWidth = this.texture.width / resolution;
                this._origHeight = this.texture.height / resolution;
                this._uvw = 1 / this._origWidth;
                this._uvh = 1 / this._origHeight;
                this._width = this._width > 1 ? this._width : this._origWidth;
                this._height = this._height > 1 ? this._height : this._origHeight;
                var uvs = this.uvs;
                uvs[2] = uvs[10] = uvs[18] = uvs[26] = this._uvw * this.leftWidth;
                uvs[4] = uvs[12] = uvs[20] = uvs[28] = 1 - this._uvw * this.rightWidth;
                uvs[9] = uvs[11] = uvs[13] = uvs[15] = this._uvh * this.topHeight;
                uvs[17] = uvs[19] = uvs[21] = uvs[23] = 1 - this._uvh * this.bottomHeight;
                this.updateHorizontalVertices();
                this.updateVerticalVertices();
                this.onResize();
            };
            Object.defineProperty(Slice9.prototype, "maxWidth", {
                get: function () {
                    return this._maxWidth;
                },
                set: function (value) {
                    this._maxWidth = value;
                    this.width = Math.min(this.width, this._maxWidth);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "width", {
                get: function () {
                    return this._width;
                },
                set: function (value) {
                    if (value == this._width)
                        return;
                    this._width = (this._maxWidth) ? Math.min(value, this._maxWidth) : value;
                    this.updateVerticalVertices();
                    if (this.game && this.alignData)
                        this.onResize();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "height", {
                get: function () {
                    return this._height;
                },
                set: function (value) {
                    if (value == this._height)
                        return;
                    this._height = Math.max(value, this.topHeight + this.bottomHeight);
                    this.updateHorizontalVertices();
                    if (this.game && this.alignData)
                        this.onResize();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "origWidth", {
                get: function () {
                    return this._origWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "origHeight", {
                get: function () {
                    return this._origHeight;
                },
                enumerable: true,
                configurable: true
            });
            Slice9.prototype.hAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.hAlign(this, align, alignTo, offset);
            };
            Slice9.prototype.vAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.vAlign(this, align, alignTo, offset);
            };
            Slice9.prototype.onResize = function () {
                gf.utils.Align.onResize(this);
            };
            Slice9.prototype.on = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.on.call(_this, e, fn, context); });
                return this;
            };
            Slice9.prototype.off = function (events, fn, once) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.off.call(_this, e, fn, once); });
                return this;
            };
            Slice9.prototype.once = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.once.call(_this, e, fn, context); });
                return this;
            };
            Slice9.prototype.removeAllListeners = function (events) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.removeAllListeners.call(_this, e); });
                return this;
            };
            Object.defineProperty(Slice9.prototype, "angle", {
                get: function () {
                    return gf.utils.Angle.getAngle(this);
                },
                set: function (value) {
                    gf.utils.Angle.setAngle(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "scaleX", {
                get: function () {
                    return gf.utils.Scale.getScaleX(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleX(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "scaleY", {
                get: function () {
                    return gf.utils.Scale.getScaleY(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "scaleXY", {
                set: function (value) {
                    gf.utils.Scale.setScaleXY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "left", {
                get: function () {
                    return gf.utils.Align.left(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "right", {
                get: function () {
                    return gf.utils.Align.right(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "top", {
                get: function () {
                    return gf.utils.Align.top(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "bottom", {
                get: function () {
                    return gf.utils.Align.bottom(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "key", {
                get: function () {
                    return this._key;
                },
                set: function (value) {
                    if (this._key == value)
                        return;
                    this._key = value;
                    this.updateTexture();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Slice9.prototype, "frameName", {
                get: function () {
                    return this._frameName;
                },
                set: function (value) {
                    if (this._frameName == value)
                        return;
                    this._frameName = value;
                    this.updateTexture();
                },
                enumerable: true,
                configurable: true
            });
            Slice9.EXTRACT_FULL_RESOLUTION_TEXTURE_FROM_ATLAS = false;
            return Slice9;
        }(PIXI.mesh.NineSlicePlane));
        display.Slice9 = Slice9;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var TilingSprite = (function (_super) {
            __extends(TilingSprite, _super);
            function TilingSprite(game, key, frameName) {
                var _this = this;
                var texture;
                if (typeof key === "string")
                    texture = gf.utils.Texture.getTexture(game, key, frameName);
                else
                    texture = key;
                _this = _super.call(this, texture, 100, 100) || this;
                _this.game = game;
                _this.name = "";
                _this.alignData = new gf.utils.AlignData();
                _this.userData = {};
                _this._key = (key) ? key : "__default";
                _this._frameName = frameName;
                _this.orgWidth = texture.width;
                _this.orgHeight = texture.height;
                _this.width = texture.width;
                _this.height = texture.height;
                return _this;
            }
            TilingSprite.prototype.updateTexture = function () {
                gf.utils.Texture.update(this);
            };
            TilingSprite.prototype.updateKeyAndFrameName = function (key, frameName) {
                this._key = key;
                this._frameName = frameName;
                this.updateTexture();
            };
            TilingSprite.prototype.hAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.hAlign(this, align, alignTo, offset);
            };
            TilingSprite.prototype.vAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.vAlign(this, align, alignTo, offset);
            };
            TilingSprite.prototype.onResize = function () {
                gf.utils.Align.onResize(this);
            };
            TilingSprite.prototype.on = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.on.call(_this, e, fn, context); });
                return this;
            };
            TilingSprite.prototype.off = function (events, fn, once) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.off.call(_this, e, fn, once); });
                return this;
            };
            TilingSprite.prototype.once = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.once.call(_this, e, fn, context); });
                return this;
            };
            TilingSprite.prototype.removeAllListeners = function (events) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.removeAllListeners.call(_this, e); });
                return this;
            };
            Object.defineProperty(TilingSprite.prototype, "angle", {
                get: function () {
                    return gf.utils.Angle.getAngle(this);
                },
                set: function (value) {
                    gf.utils.Angle.setAngle(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "scaleX", {
                get: function () {
                    return gf.utils.Scale.getScaleX(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleX(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "scaleY", {
                get: function () {
                    return gf.utils.Scale.getScaleY(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "scaleXY", {
                set: function (value) {
                    gf.utils.Scale.setScaleXY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "left", {
                get: function () {
                    return gf.utils.Align.left(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "right", {
                get: function () {
                    return gf.utils.Align.right(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "top", {
                get: function () {
                    return gf.utils.Align.top(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "bottom", {
                get: function () {
                    return gf.utils.Align.bottom(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "key", {
                get: function () {
                    return this._key;
                },
                set: function (value) {
                    this._key = value;
                    this.updateTexture();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TilingSprite.prototype, "frameName", {
                get: function () {
                    return this._frameName;
                },
                set: function (value) {
                    this._frameName = value;
                    this.updateTexture();
                },
                enumerable: true,
                configurable: true
            });
            return TilingSprite;
        }(PIXI.extras.TilingSprite));
        display.TilingSprite = TilingSprite;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Frame = (function () {
            function Frame(index, data, name, uid, resolution) {
                this.index = index;
                this.name = name;
                this.uid = uid;
                this.trimmed = false;
                this.orig = new PIXI.Rectangle(0, 0, data.sourceSize.w / resolution, data.sourceSize.h / resolution);
                this.pivot = data.pivot || new PIXI.Point();
                if (data.rotated) {
                    this.rotated = true;
                    this.frame = new PIXI.Rectangle(data.frame.x / resolution, data.frame.y / resolution, data.frame.h / resolution, data.frame.w / resolution);
                }
                else {
                    this.rotated = false;
                    this.frame = new PIXI.Rectangle(data.frame.x / resolution, data.frame.y / resolution, data.frame.w / resolution, data.frame.h / resolution);
                }
                if (data.trimmed) {
                    this.trimmed = true;
                    this.trim = new PIXI.Rectangle(data.spriteSourceSize.x / resolution, data.spriteSourceSize.y / resolution, data.spriteSourceSize.w / resolution, data.spriteSourceSize.h / resolution);
                }
            }
            return Frame;
        }());
        utils.Frame = Frame;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var FrameData = (function () {
            function FrameData() {
                this._frames = [];
                this._frameNames = [];
            }
            FrameData.prototype.addFrame = function (frame) {
                frame.index = this._frames.length;
                this._frames.push(frame);
                if (frame.name !== "") {
                    this._frameNames[frame.name] = frame.index;
                }
                return frame;
            };
            FrameData.prototype.getFrame = function (index) {
                if (index === void 0) { index = 0; }
                if (index > this._frames.length) {
                    index = 0;
                }
                return this._frames[index];
            };
            FrameData.prototype.getFrameByName = function (name) {
                if (typeof this._frameNames[name] == "undefined")
                    logWarning("Frame with name \"" + name + "\" is not in given sprite sheet.");
                return this._frames[this._frameNames[name]];
            };
            FrameData.prototype.checkFrameName = function (name) {
                return this._frameNames[name] != null;
            };
            FrameData.prototype.getFrames = function () {
                return this._frames;
            };
            Object.defineProperty(FrameData.prototype, "total", {
                get: function () {
                    return this._frames.length;
                },
                enumerable: true,
                configurable: true
            });
            return FrameData;
        }());
        utils.FrameData = FrameData;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Texture = (function () {
            function Texture() {
            }
            Texture.update = function (display) {
                if (display.key instanceof PIXI.Texture) {
                    display.texture = display.key;
                }
                else {
                    var frameData = display.game.cache.getFrameData(display.key);
                    if (display.frameName) {
                        var frame = frameData.getFrameByName(display.frameName);
                        this.setFrame(display, frame);
                    }
                    else {
                        if (frameData)
                            this.setFrame(display, frameData.getFrame());
                        else
                            logWarning("Warning: Can't find frame data with key: " + display.key);
                    }
                }
            };
            Texture.getTexture = function (game, key, frameName) {
                var frameData = game.cache.getFrameData(key);
                var frame = (frameName) ? frameData.getFrameByName(frameName) : frameData.getFrame();
                return new PIXI.Texture(PIXI.utils.TextureCache[key], frame.frame, frame.orig, frame.trim, frame.rotated ? 2 : 0);
            };
            Texture.setFrame = function (display, frame) {
                try {
                    display.frame = frame;
                    display.texture = new PIXI.Texture(PIXI.utils.TextureCache[display.key], frame.frame, frame.orig, frame.trim, frame.rotated ? 2 : 0);
                }
                catch (e) {
                    logWarning("gf.utils.Texture.setFrame() error with key: " + display.key + ", frame: " + display.frameName);
                }
            };
            Texture.crop = function (display, rect) {
                var crop = display.texture.frame.clone();
                crop.x += rect.x;
                crop.y += rect.y;
                crop.width = rect.width;
                crop.height = rect.height;
                display.texture.frame = crop;
                display.texture["_updateUvs"]();
            };
            return Texture;
        }());
        utils.Texture = Texture;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Sprite = (function (_super) {
            __extends(Sprite, _super);
            function Sprite(game, key, frameName) {
                var _this = _super.call(this, game.cache.getTexture("__default")) || this;
                _this.game = game;
                _this.name = "";
                _this.alignData = new gf.utils.AlignData();
                _this.userData = {};
                _this._key = (key) ? key : "__default";
                _this._frameName = frameName || "";
                _this.updateTexture();
                return _this;
            }
            Sprite.prototype.updateTexture = function () {
                gf.utils.Texture.update(this);
            };
            Sprite.prototype.updateKeyAndFrameName = function (key, frameName) {
                this._key = key;
                this._frameName = frameName || "";
                this.updateTexture();
            };
            Sprite.prototype.hAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.hAlign(this, align, alignTo, offset);
            };
            Sprite.prototype.vAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.vAlign(this, align, alignTo, offset);
            };
            Sprite.prototype.onResize = function () {
                gf.utils.Align.onResize(this);
            };
            Sprite.prototype.on = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.on.call(_this, e, fn, context); });
                return this;
            };
            Sprite.prototype.off = function (events, fn, once) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.off.call(_this, e, fn, once); });
                return this;
            };
            Sprite.prototype.once = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.once.call(_this, e, fn, context); });
                return this;
            };
            Sprite.prototype.removeAllListeners = function (events) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.removeAllListeners.call(_this, e); });
                return this;
            };
            Object.defineProperty(Sprite.prototype, "angle", {
                get: function () {
                    return gf.utils.Angle.getAngle(this);
                },
                set: function (value) {
                    gf.utils.Angle.setAngle(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "scaleX", {
                get: function () {
                    return gf.utils.Scale.getScaleX(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleX(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "scaleY", {
                get: function () {
                    return gf.utils.Scale.getScaleY(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "scaleXY", {
                set: function (value) {
                    gf.utils.Scale.setScaleXY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "left", {
                get: function () {
                    return gf.utils.Align.left(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "right", {
                get: function () {
                    return gf.utils.Align.right(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "top", {
                get: function () {
                    return gf.utils.Align.top(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "bottom", {
                get: function () {
                    return gf.utils.Align.bottom(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "key", {
                get: function () {
                    return this._key;
                },
                set: function (value) {
                    this._key = value;
                    this.updateTexture();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sprite.prototype, "frameName", {
                get: function () {
                    return this._frameName;
                },
                set: function (value) {
                    this._frameName = value;
                    this.updateTexture();
                },
                enumerable: true,
                configurable: true
            });
            return Sprite;
        }(PIXI.Sprite));
        display.Sprite = Sprite;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Text = (function (_super) {
            __extends(Text, _super);
            function Text(game, text, style) {
                var _this = _super.call(this, text, style) || this;
                _this.game = game;
                _this.name = "";
                _this.alignData = new gf.utils.AlignData();
                _this.userData = {};
                if (text && style)
                    _this.updateText(true);
                return _this;
            }
            Text.prototype.truncate = function (maxWidth) {
                var text = this.text;
                this.text = "...";
                var minWidth = this.width;
                if (maxWidth <= minWidth) {
                    this.text = "...";
                    return;
                }
                else if (text) {
                    this.text = text;
                }
                var length = this.text.length;
                while (this.width > maxWidth) {
                    this.text = this.text.substring(0, length - 2) + "...";
                    length--;
                }
            };
            Text.prototype.update = function (respectDirty) {
                this.updateText(respectDirty);
            };
            Text.prototype.hAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.hAlign(this, align, alignTo, offset);
            };
            Text.prototype.vAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.vAlign(this, align, alignTo, offset);
            };
            Text.prototype.onResize = function () {
                gf.utils.Align.onResize(this);
            };
            Text.prototype.on = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.on.call(_this, e, fn, context); });
                return this;
            };
            Text.prototype.off = function (events, fn, once) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (event) { return _super.prototype.off.call(_this, event, fn, once); });
                return this;
            };
            Text.prototype.once = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (event) { return _super.prototype.once.call(_this, event, fn, context); });
                return this;
            };
            Text.prototype.removeAllListeners = function (events) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (event) { return _super.prototype.removeAllListeners.call(_this, event); });
                return this;
            };
            Object.defineProperty(Text.prototype, "angle", {
                get: function () {
                    return gf.utils.Angle.getAngle(this);
                },
                set: function (value) {
                    gf.utils.Angle.setAngle(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "scaleX", {
                get: function () {
                    return gf.utils.Scale.getScaleX(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleX(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "scaleY", {
                get: function () {
                    return gf.utils.Scale.getScaleY(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "scaleXY", {
                set: function (value) {
                    gf.utils.Scale.setScaleXY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "left", {
                get: function () {
                    return gf.utils.Align.left(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "right", {
                get: function () {
                    return gf.utils.Align.right(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "top", {
                get: function () {
                    return gf.utils.Align.top(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Text.prototype, "bottom", {
                get: function () {
                    return gf.utils.Align.bottom(this);
                },
                enumerable: true,
                configurable: true
            });
            return Text;
        }(PIXI.Text));
        display.Text = Text;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Container = (function (_super) {
            __extends(Container, _super);
            function Container(game) {
                var _this = _super.call(this) || this;
                _this.game = game;
                _this.name = "";
                _this.alignData = new gf.utils.AlignData();
                _this.userData = {};
                return _this;
            }
            Container.prototype.hAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.hAlign(this, align, alignTo, offset);
            };
            Container.prototype.vAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.vAlign(this, align, alignTo, offset);
            };
            Container.prototype.onResize = function () {
                gf.utils.Align.onResize(this);
            };
            Container.prototype.on = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.on.call(_this, e, fn, context); });
                return this;
            };
            Container.prototype.off = function (events, fn, once) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.off.call(_this, e, fn, once); });
                return this;
            };
            Container.prototype.once = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.once.call(_this, e, fn, context); });
                return this;
            };
            Container.prototype.removeAllListeners = function (events) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.removeAllListeners.call(_this, e); });
                return this;
            };
            Object.defineProperty(Container.prototype, "angle", {
                get: function () {
                    return gf.utils.Angle.getAngle(this);
                },
                set: function (value) {
                    gf.utils.Angle.setAngle(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "scaleX", {
                get: function () {
                    return gf.utils.Scale.getScaleX(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleX(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "scaleY", {
                get: function () {
                    return gf.utils.Scale.getScaleY(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "scaleXY", {
                set: function (value) {
                    gf.utils.Scale.setScaleXY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "left", {
                get: function () {
                    return gf.utils.Align.left(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "right", {
                get: function () {
                    return gf.utils.Align.right(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "top", {
                get: function () {
                    return gf.utils.Align.top(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Container.prototype, "bottom", {
                get: function () {
                    return gf.utils.Align.bottom(this);
                },
                enumerable: true,
                configurable: true
            });
            return Container;
        }(PIXI.Container));
        display.Container = Container;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var DomDisplayObject = (function (_super) {
            __extends(DomDisplayObject, _super);
            function DomDisplayObject(game, parent, tag) {
                var _this = _super.call(this, game) || this;
                _this._domParent = parent;
                _this._tag = (typeof tag == "string" && tag.length > 0) ? tag : "div";
                _this._pointerEventsEnabled = true;
                _this.createDom();
                _this._dom.style.pointerEvents = "all";
                _this.paddingLeft = 0;
                _this.paddingRight = 0;
                _this.paddingTop = 0;
                _this.paddingBottom = 0;
                if (typeof _this._domParent != "string")
                    _this._domParent.addDomChild(_this);
                return _this;
            }
            DomDisplayObject.prototype.addClass = function () {
                var token = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    token[_i] = arguments[_i];
                }
                this._dom.classList.add.apply(this._dom.classList, token);
            };
            DomDisplayObject.prototype.hasClass = function (token) {
                return this._dom.classList.contains(token);
            };
            DomDisplayObject.prototype.removeClass = function () {
                var token = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    token[_i] = arguments[_i];
                }
                this._dom.classList.remove.apply(this._dom.classList, token);
            };
            DomDisplayObject.prototype.createDom = function () {
                this._dom = document.createElement(this._tag);
            };
            DomDisplayObject.prototype.onChange = function () {
                if (typeof this._domParent != "string")
                    this._domParent.emit("change");
            };
            DomDisplayObject.prototype.enablePointerEvents = function () {
                this._dom.style.pointerEvents = "all";
            };
            DomDisplayObject.prototype.disablePointerEvents = function () {
                this._dom.style.pointerEvents = "none";
            };
            Object.defineProperty(DomDisplayObject.prototype, "domParent", {
                get: function () {
                    return this._domParent;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "dom", {
                get: function () {
                    return this._dom;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "tag", {
                get: function () {
                    return this._tag;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "paddingLeft", {
                get: function () {
                    return this._paddingLeft;
                },
                set: function (value) {
                    this._paddingLeft = value;
                    this._dom.style.paddingLeft = String(value) + "px";
                    this.setWidth(this.width);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "tabIndex", {
                get: function () {
                    return this._dom.tabIndex;
                },
                set: function (value) {
                    this._dom.tabIndex = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "padding", {
                set: function (value) {
                    this.paddingLeft = value;
                    this.paddingRight = value;
                    this.paddingTop = value;
                    this.paddingBottom = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "paddingRight", {
                get: function () {
                    return this._paddingRight;
                },
                set: function (value) {
                    this._paddingRight = value;
                    this._dom.style.paddingRight = String(value) + "px";
                    this.setWidth(this.width);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "paddingTop", {
                get: function () {
                    return this._paddingTop;
                },
                set: function (value) {
                    this._paddingTop = value;
                    this._dom.style.paddingTop = String(value) + "px";
                    this.setHeight(this.height);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "paddingBottom", {
                get: function () {
                    return this._paddingBottom;
                },
                set: function (value) {
                    this._paddingBottom = value;
                    this._dom.style.paddingBottom = String(value) + "px";
                    this.setHeight(this.height);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "x", {
                get: function () {
                    return this.position.x;
                },
                set: function (value) {
                    this.setX(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "y", {
                get: function () {
                    return this.position.y;
                },
                set: function (value) {
                    this.setY(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "width", {
                get: function () {
                    return this.getLocalBounds().width;
                },
                set: function (value) {
                    this.setWidth(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomDisplayObject.prototype, "height", {
                get: function () {
                    return this.getLocalBounds().height;
                },
                set: function (value) {
                    this.setHeight(value);
                },
                enumerable: true,
                configurable: true
            });
            DomDisplayObject.prototype.validate = function () {
                return true;
            };
            DomDisplayObject.prototype.updatePosition = function () {
                this.setX(this.x);
                this.setY(this.y);
            };
            DomDisplayObject.prototype.setX = function (value) {
                this.position.x = value;
                if (this.parent)
                    this._dom.style.left = String(this.parent.toGlobal(this.position).x) + "px";
            };
            DomDisplayObject.prototype.setY = function (value) {
                this.position.y = value;
                if (this.parent)
                    this._dom.style.top = String(this.parent.toGlobal(this.position).y) + "px";
            };
            DomDisplayObject.prototype.setWidth = function (value) {
                this._dom.style.width = value > 0 ? String(value) + "px" : "auto";
            };
            DomDisplayObject.prototype.setHeight = function (value) {
                this._dom.style.height = value > 0 ? String(value) + "px" : "auto";
            };
            DomDisplayObject.prototype.reset = function () {
            };
            return DomDisplayObject;
        }(gf.display.Container));
        display.DomDisplayObject = DomDisplayObject;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var input;
    (function (input) {
        var DomContainer = (function (_super) {
            __extends(DomContainer, _super);
            function DomContainer(game, tag, parent) {
                var _this = _super.call(this, game, (typeof parent == "string") ? parent : "kr3m", tag) || this;
                _this._tag = (typeof tag == "string" && tag.length > 0) ? tag : "div";
                _this._transformScaleX = 1;
                _this._transformScaleY = 1;
                _this._domChildren = [];
                _this.createDom();
                return _this;
            }
            DomContainer.prototype.createDom = function () {
                _super.prototype.createDom.call(this);
                this._dom.setAttribute("style", "1");
            };
            DomContainer.prototype.setTransformScale = function () {
                var opacityStyle = this._dom.style.opacity ? this._dom.style.opacity : "1";
                if (typeof opacityStyle != "string")
                    opacityStyle = "1";
                var styleScale = "scale(" + this._transformScaleX + "," + this._transformScaleY + ")";
                this._dom.style.opacity = opacityStyle;
                this._dom.style["-webkit-transform"] = styleScale;
                this._dom.style["-ms-transform"] = styleScale;
                this._dom.style["-moz-transform"] = styleScale;
                this._dom.style.transform = styleScale;
                this._dom.style.position = "absolute";
            };
            DomContainer.prototype.addDomChild = function (child) {
                this._dom.appendChild(child.dom);
                this._domChildren.push(child);
            };
            DomContainer.prototype.onResize = function () {
                var _this = this;
                _super.prototype.onResize.call(this);
                this.transformScaleX = parseFloat(this.game.canvas.style.width) / this.game.width;
                this.transformScaleY = parseFloat(this.game.canvas.style.height) / this.game.height;
                this.setTransformScale();
                setTimeout(function () {
                    _this.updateElementPositions();
                }, 100);
                setTimeout(function () {
                    _this.updateElementPositions();
                }, 10);
            };
            Object.defineProperty(DomContainer.prototype, "domChildren", {
                get: function () {
                    return this._domChildren;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomContainer.prototype, "transformScaleX", {
                get: function () {
                    return this._transformScaleX;
                },
                set: function (value) {
                    this._transformScaleX = value;
                    this.setTransformScale();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DomContainer.prototype, "transformScaleY", {
                get: function () {
                    return this._transformScaleY;
                },
                set: function (value) {
                    this._transformScaleY = value;
                    this.setTransformScale();
                },
                enumerable: true,
                configurable: true
            });
            DomContainer.prototype.showDom = function () {
                this._domChildren.forEach(function (child) {
                    child.reset();
                });
                this.appendToDom();
                this.updateElementPositions();
            };
            DomContainer.prototype.hideDom = function () {
                this.removeFromDom();
            };
            DomContainer.prototype.updateElementPositions = function () {
                this._domChildren.forEach(function (child) {
                    child.updatePosition();
                });
            };
            DomContainer.prototype.validate = function () {
                for (var i = 0, ic = this._domChildren.length; i < ic; i++) {
                    if (!this._domChildren[i].validate())
                        return false;
                }
                return true;
            };
            DomContainer.prototype.appendToDom = function () {
                if (!document.getElementById(String(this._domParent)).contains(this._dom))
                    document.getElementById(String(this._domParent)).appendChild(this._dom);
            };
            DomContainer.prototype.removeFromDom = function () {
                if (document.getElementById(String(this._domParent)).contains(this._dom))
                    document.getElementById(String(this._domParent)).removeChild(this._dom);
            };
            return DomContainer;
        }(gf.display.DomDisplayObject));
        input.DomContainer = DomContainer;
    })(input = gf.input || (gf.input = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var input;
    (function (input) {
        var TextInput = (function (_super) {
            __extends(TextInput, _super);
            function TextInput(game, parent, name) {
                var _this = _super.call(this, game, parent, "input") || this;
                _this._regExp = /(\w|\W)+/;
                _this.required = true;
                _this._inputDom.name = name;
                _this._italic = false;
                _this._bold = false;
                _this.validateTrimmedValue = true;
                _this.addChangeListeners();
                return _this;
            }
            TextInput.prototype.addChangeListeners = function () {
                var _this = this;
                this._inputDom.addEventListener("keyup", function (e) {
                    if (e.keyCode != 9)
                        _this.onChange();
                });
                this._inputDom.oninput = function () { return _this.onChange(); };
                $(this._inputDom).blur(function () { return _this.onInputBlur(); });
                $(this._inputDom).focus(function () { return _this.onInputFocus(); });
            };
            TextInput.prototype.onInputBlur = function () {
                this.emit(gf.BLUR);
            };
            TextInput.prototype.onInputFocus = function () {
                this.emit(gf.FOCUS);
            };
            TextInput.prototype.setFocus = function () {
                var _this = this;
                setTimeout(function () { return $(_this._inputDom).focus(); }, 1);
            };
            Object.defineProperty(TextInput.prototype, "inputDom", {
                get: function () {
                    return this._inputDom;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "name", {
                get: function () {
                    return this._inputDom.name;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "regExp", {
                get: function () {
                    return this._regExp;
                },
                set: function (value) {
                    this._regExp = value;
                    this.onChange();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "readOnly", {
                get: function () {
                    return this._inputDom.readOnly;
                },
                set: function (value) {
                    this._inputDom.readOnly = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "value", {
                get: function () {
                    return this._inputDom.value;
                },
                set: function (value) {
                    if (this._inputDom.value != value)
                        this.onChange();
                    this._inputDom.value = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "autoComplete", {
                get: function () {
                    return this._inputDom.autocomplete == "on";
                },
                set: function (value) {
                    if (this.type == "password")
                        value = false;
                    this._inputDom.autocomplete = value ? "on" : "off";
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "placeholder", {
                get: function () {
                    return this._inputDom.placeholder;
                },
                set: function (value) {
                    this._inputDom.placeholder = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "type", {
                get: function () {
                    return this._inputDom.type;
                },
                set: function (value) {
                    this._inputDom.type = value;
                    if (value == "password")
                        this.autoComplete = false;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "fontFamily", {
                get: function () {
                    return this._inputDom.style.fontFamily;
                },
                set: function (value) {
                    this._inputDom.style.fontFamily = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "fontSize", {
                get: function () {
                    return this._fontSize;
                },
                set: function (value) {
                    this._inputDom.style.fontSize = String(value) + "px";
                    this._fontSize = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._inputDom.style.color = "#" + value.toString(16);
                    this._color = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "italic", {
                get: function () {
                    return this._italic;
                },
                set: function (value) {
                    this._inputDom.style.fontStyle = (value) ? "italic" : "regular";
                    this._italic = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "bold", {
                get: function () {
                    return this._bold;
                },
                set: function (value) {
                    this._inputDom.style.fontWeight = (value) ? "bold" : "normal";
                    this._bold = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextInput.prototype, "maxLength", {
                get: function () {
                    return this._inputDom.maxLength ? this._inputDom.maxLength : 0;
                },
                set: function (value) {
                    this._inputDom.maxLength = value;
                },
                enumerable: true,
                configurable: true
            });
            TextInput.prototype.createDom = function () {
                _super.prototype.createDom.call(this);
                this._inputDom = this._dom;
                this._inputDom.style.position = "absolute";
                this._inputDom.style.border = "none";
                this._inputDom.style.fontFamily = "Arial, Helvetica, sans-serif";
                this._inputDom.type = "text";
            };
            TextInput.prototype.setHeight = function (value) {
                _super.prototype.setHeight.call(this, value);
                this._inputDom.style.lineHeight = String(value) + "px";
            };
            TextInput.prototype.validate = function () {
                if (this.readOnly)
                    return true;
                var value = (this.validateTrimmedValue) ? this.value.trim() : this.value;
                return (!this.required && this.value.length == 0) || this.regExp.test(value);
            };
            return TextInput;
        }(gf.display.DomDisplayObject));
        input.TextInput = TextInput;
    })(input = gf.input || (gf.input = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var input;
    (function (input) {
        var TextInput = (function (_super) {
            __extends(TextInput, _super);
            function TextInput(game, parent, name) {
                var _this = _super.call(this, game, parent, name) || this;
                _this.fontFamily = cuboro.DEFAULT_FONT;
                _this.fontSize = 13;
                _this.tfTitle = new gf.display.Text(_this.game);
                _this.tfTitle.style = cuboro.TEXT_STYLE_SMALL.clone();
                _this.tfTitle.x = cuboro.PADDING;
                _this.tfTitle.text = "";
                _this.addChild(_this.tfTitle);
                _this.border = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.border.width = 227;
                _this.border.height = 27;
                _this.border.tint = cuboro.COLOR_GREY;
                _this.border.y = _this.tfTitle.bottom;
                _this.addChild(_this.border);
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.width = 225;
                _this.bg.height = 25;
                _this.bg.x = 1;
                _this.bg.y = _this.border.y + 1;
                _this.addChild(_this.bg);
                _this.tfError = new gf.display.Text(_this.game);
                _this.tfError.style = cuboro.TEXT_STYLE_INPUT_ERROR.clone();
                _this.tfError.style.wordWrapWidth = _this.border.width - cuboro.PADDING * 2;
                _this.tfError.text = "";
                _this.tfError.x = cuboro.PADDING;
                _this.tfError.y = _this.border.bottom + 2;
                _this.addChild(_this.tfError);
                _this.paddingLeft = cuboro.PADDING;
                _this.paddingRight = cuboro.PADDING;
                _this._dom.style.marginTop = "18px";
                _this.width = _this.bg.width;
                _this.height = _this.bg.height;
                return _this;
            }
            TextInput.prototype.onChange = function () {
                _super.prototype.onChange.call(this);
                if (this.tfError.visible) {
                    this.hideError();
                }
            };
            TextInput.prototype.onInputBlur = function () {
                this.validate();
                _super.prototype.onInputBlur.call(this);
            };
            TextInput.prototype.hideError = function () {
                this.tfError.text = "";
                this.tfError.visible = false;
                this.border.tint = cuboro.COLOR_GREY;
            };
            TextInput.prototype.showError = function (text) {
                this.tfError.text = text;
                this.tfError.visible = true;
                this.border.tint = cuboro.COLOR_RED;
            };
            TextInput.prototype.validate = function () {
                this._inputDom.value = this.value.trim();
                if (!this.validation)
                    return true;
                return this.validation(this.value);
            };
            return TextInput;
        }(gf.input.TextInput));
        input.TextInput = TextInput;
    })(input = cuboro.input || (cuboro.input = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var ui;
    (function (ui) {
        var Button = (function (_super) {
            __extends(Button, _super);
            function Button(game) {
                var _this = _super.call(this, game) || this;
                _this.addListeners();
                _this.buttonMode = true;
                _this.interactive = true;
                _this._currentState = gf.OUT;
                _this._isEnabled = true;
                return _this;
            }
            Button.prototype.addListeners = function () {
                var _this = this;
                var usePointer = parseInt(PIXI.VERSION.split(".").join("")) < 452;
                this.on(usePointer ? "mouseover pointerover" : "mouseover", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._isOver = true;
                    _this._currentState = gf.OVER;
                    _this.setState(_this._currentState);
                    _this.over(e);
                    _this.emit(gf.OVER, e);
                });
                this.on(usePointer ? "mouseout pointerout" : "mouseout", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._isOver = false;
                    _this._currentState = gf.OUT;
                    _this.setState(_this._currentState);
                    _this.out(e);
                    _this.emit(gf.OUT, e);
                });
                this.on(usePointer ? "mousedown pointerdown touchstart" : "mousedown touchstart", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._isOver = true;
                    _this._currentState = gf.DOWN;
                    _this.setState(_this._currentState);
                    _this.down(e);
                    _this.emit(gf.DOWN, e);
                });
                this.on(usePointer ? "mouseup pointerup" : "mouseup", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._currentState = _this._isOver ? gf.OVER : gf.UP;
                    _this.setState(_this._currentState);
                    _this.up(e);
                    _this.emit(gf.UP, e);
                });
                this.on("touchend", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._currentState = gf.UP;
                    _this.setState(_this._currentState);
                    _this.up(e);
                    _this.emit(gf.UP, e);
                });
                this.on(usePointer ? "mouseupoutside pointerupoutside touchendoutside" : "mouseupoutside touchendoutside", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._isOver = false;
                    _this._currentState = gf.UP;
                    _this.setState(_this._currentState);
                    _this.upOutside(e);
                    _this.emit(gf.UP, e);
                });
                this.on("click", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this.click(e);
                    _this.emit(gf.CLICK, e);
                });
                this.on("tap", function (e) {
                    if (!_this._isEnabled)
                        return;
                    _this._isOver = false;
                    _this._currentState = gf.UP;
                    _this.setState(_this._currentState);
                    _this.click(e);
                    _this.emit(gf.CLICK, e);
                });
            };
            Button.prototype.setState = function (state) {
            };
            Button.prototype.over = function (e) {
            };
            Button.prototype.out = function (e) {
            };
            Button.prototype.down = function (e) {
            };
            Button.prototype.up = function (e) {
            };
            Button.prototype.upOutside = function (e) {
            };
            Button.prototype.click = function (e) {
            };
            Button.prototype.enable = function () {
                this.interactive = true;
                this.buttonMode = true;
                this._isEnabled = true;
                this.emit(gf.ENABLE);
            };
            Button.prototype.disable = function () {
                this.interactive = false;
                this.buttonMode = false;
                this._isEnabled = false;
                this.emit(gf.DISABLE);
            };
            Object.defineProperty(Button.prototype, "currentState", {
                get: function () {
                    return this._currentState;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "isOver", {
                get: function () {
                    return this._isOver;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Button.prototype, "isEnabled", {
                get: function () {
                    return this._isEnabled;
                },
                set: function (value) {
                    (value) ? this.enable() : this.disable();
                },
                enumerable: true,
                configurable: true
            });
            return Button;
        }(gf.display.Container));
        ui.Button = Button;
    })(ui = gf.ui || (gf.ui = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var CloseButton = (function (_super) {
            __extends(CloseButton, _super);
            function CloseButton(game) {
                var _this = _super.call(this, game) || this;
                _this.icon = new gf.display.Sprite(_this.game, "sprites", "icon_close");
                _this.icon.tint = cuboro.COLOR_DARK_GREY;
                _this.addChild(_this.icon);
                _this.hitArea = new PIXI.Circle(_this.icon.width >> 1, _this.icon.height >> 1, (_this.icon.width >> 1) + cuboro.PADDING * 2);
                return _this;
            }
            CloseButton.prototype.setState = function (state) {
                switch (this._currentState) {
                    case gf.DOWN:
                        this.icon.tint = cuboro.COLOR_GREY;
                        break;
                    case gf.OUT:
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.icon.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.icon.tint = cuboro.COLOR_YELLOW;
                        }
                        else {
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            return CloseButton;
        }(gf.ui.Button));
        ui.CloseButton = CloseButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var IconButton = (function (_super) {
            __extends(IconButton, _super);
            function IconButton(game, icon, label, isPrimary) {
                if (isPrimary === void 0) { isPrimary = true; }
                var _this = _super.call(this, game) || this;
                _this.interactiveChildren = false;
                _this._icon = icon;
                _this._label = label;
                _this._isPrimary = isPrimary;
                _this.bg = new gf.display.Sprite(game, PIXI.Texture.WHITE);
                _this.bg.width =
                    _this.bg.height = 65;
                _this.addChild(_this.bg);
                if (_this._icon)
                    _this.addIcon();
                if (_this._label)
                    _this.addLabel();
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                return _this;
            }
            IconButton.prototype.addIcon = function () {
                this.icon = new gf.display.Sprite(this.game, "sprites", "icon_" + this._icon);
                this.icon.anchor.set(0.5);
                this.icon.x = this.bg.width >> 1;
                this.icon.y = this.bg.height >> 1;
                this.addChild(this.icon);
            };
            IconButton.prototype.addLabel = function () {
                this.tfLabel = new gf.display.Text(this.game, this._label, cuboro.TEXT_STYLE_BUTTON_ICON.clone());
                this.tfLabel.anchor.set(0.5, 1);
                this.tfLabel.style.wordWrapWidth = this.bg.width;
                this.tfLabel.x = this.bg.width >> 1;
                this.tfLabel.y = this.bg.height;
                this.addChild(this.tfLabel);
            };
            IconButton.prototype.setState = function (state) {
                if (this._isSelected) {
                    if (this.bg.tint != cuboro.COLOR_YELLOW)
                        this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                if (this._isEnabled) {
                    if (this.icon)
                        this.icon.alpha = 1;
                    if (this.tfLabel)
                        this.tfLabel.alpha = 1;
                }
                else {
                    this.bg.tint = cuboro.COLOR_GREY;
                    if (this.icon) {
                        this.icon.alpha = 0.6;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                    }
                    if (this.tfLabel) {
                        this.tfLabel.alpha = 0.6;
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                    }
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        if (this.tfLabel)
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OUT:
                        this.bg.tint = (this._isPrimary) ? cuboro.COLOR_WHITE : cuboro.COLOR_LIGHT_GREY;
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        if (this.tfLabel)
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_WHITE;
                        if (this.tfLabel)
                            this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                            if (this.icon)
                                this.icon.tint = cuboro.COLOR_WHITE;
                            if (this.tfLabel)
                                this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.bg.tint = (this._isPrimary) ? cuboro.COLOR_WHITE : cuboro.COLOR_LIGHT_GREY;
                            if (this.icon)
                                this.icon.tint = cuboro.COLOR_DARK_GREY;
                            if (this.tfLabel)
                                this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            IconButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.setState(this.currentState);
            };
            IconButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.setState(this.currentState);
            };
            IconButton.prototype.forceState = function (state) {
                this._currentState = state;
                this.setState(state);
            };
            Object.defineProperty(IconButton.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (value == this._label)
                        return;
                    this._label = value;
                    if (!this.tfLabel)
                        this.addLabel();
                    this.tfLabel.text = this._label;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(IconButton.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    this._isSelected = value;
                    this._isOver = false;
                    this.setState(this._currentState);
                },
                enumerable: true,
                configurable: true
            });
            return IconButton;
        }(gf.ui.Button));
        ui.IconButton = IconButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var screens;
    (function (screens) {
        var Screen = (function (_super) {
            __extends(Screen, _super);
            function Screen(game) {
                var _this = _super.call(this, game) || this;
                _this.visible = false;
                _this._isActive = false;
                _this._isInitialized = false;
                return _this;
            }
            Screen.prototype.init = function () {
            };
            Screen.prototype.transitionIn = function () {
                var _this = this;
                if (!this._isInitialized) {
                    this.init();
                    this._isInitialized = true;
                    this.emit(gf.INITIALIZED);
                }
                this._isActive = true;
                this.alpha = 0;
                this.visible = true;
                TweenMax.to(this, 0.15, { alpha: 1, onComplete: function () { return _this.transitionInComplete(); } });
                this.emit(gf.TRANSITION_IN);
                this.onResize();
            };
            Screen.prototype.transitionOut = function () {
                var _this = this;
                this.emit(gf.TRANSITION_OUT);
                this._isActive = false;
                this.interactive = false;
                TweenMax.to(this, 0.15, { alpha: 0, onComplete: function () { return _this.transitionOutComplete(); } });
            };
            Screen.prototype.transitionInComplete = function () {
                this.emit(gf.TRANSITION_IN_COMPLETE);
                this.interactive = true;
            };
            Screen.prototype.transitionOutComplete = function () {
                this.visible = false;
                this.emit(gf.TRANSITION_OUT_COMPLETE);
            };
            Object.defineProperty(Screen.prototype, "isActive", {
                get: function () {
                    return this._isActive;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Screen.prototype, "isInitialized", {
                get: function () {
                    return this._isInitialized;
                },
                enumerable: true,
                configurable: true
            });
            return Screen;
        }(gf.display.Container));
        screens.Screen = Screen;
    })(screens = gf.screens || (gf.screens = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var overlays;
    (function (overlays) {
        var Overlay = (function (_super) {
            __extends(Overlay, _super);
            function Overlay() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return Overlay;
        }(gf.screens.Screen));
        overlays.Overlay = Overlay;
    })(overlays = gf.overlays || (gf.overlays = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var ui;
    (function (ui) {
        var NoClick = (function (_super) {
            __extends(NoClick, _super);
            function NoClick(game) {
                var _this = _super.call(this, game) || this;
                _this.interactive = true;
                _this.onResize();
                return _this;
            }
            NoClick.prototype.onResize = function () {
                this.hitArea = new PIXI.Rectangle(0, 0, this.game.width, this.game.height);
            };
            return NoClick;
        }(gf.display.Sprite));
        ui.NoClick = NoClick;
    })(ui = gf.ui || (gf.ui = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Overlay = (function (_super) {
            __extends(Overlay, _super);
            function Overlay() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Overlay.prototype.init = function () {
                this.addNoClick();
                this.addDim();
                this.addBg();
                this.addBtClose();
                this.addTitle();
            };
            Overlay.prototype.addNoClick = function () {
                this.noClick = new gf.ui.NoClick(this.game);
                this.addChild(this.noClick);
            };
            Overlay.prototype.addDim = function () {
                this.dim = new gf.display.Sprite(this.game, PIXI.Texture.WHITE);
                this.dim.tint = 0x000000;
                this.dim.alpha = 0.6;
                this.dim.y = this.game.stage.header.bg.height;
                this.addChild(this.dim);
            };
            Overlay.prototype.addBg = function () {
                this.bg = new gf.display.Sprite(this.game, PIXI.Texture.WHITE);
                this.bg.width = 270;
                this.bg.height = 315;
                this.bg.y = this.game.stage.header.bg.height + 60;
                this.addChild(this.bg);
            };
            Overlay.prototype.addBtClose = function () {
                this.btClose = new cuboro.ui.CloseButton(this.game);
                this.btClose.on(gf.CLICK, this.onClose, this);
                this.btClose.y = this.bg.y + cuboro.PADDING * 2 + 2;
                this.addChild(this.btClose);
            };
            Overlay.prototype.addTitle = function () {
                this.tfTitle = new gf.display.Text(this.game);
                this.tfTitle.style = cuboro.TEXT_STYLE_TITLE_TAB.clone();
                this.tfTitle.y = this.bg.y + cuboro.PADDING * 2;
                this.addChild(this.tfTitle);
            };
            Overlay.prototype.onClose = function () {
            };
            Overlay.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                if (this.bg)
                    this.bg.x = (this.game.width - this.bg.width) >> 1;
                if (this.btClose)
                    this.btClose.x = this.bg.right - this.btClose.width - cuboro.PADDING * 2;
                if (this.tfTitle)
                    this.tfTitle.x = this.bg.x + ((this.bg.width - this.tfTitle.width) >> 1);
                if (this.dim) {
                    this.dim.width = this.game.width;
                    this.dim.height = this.game.height - this.game.stage.header.bg.height;
                }
            };
            return Overlay;
        }(gf.overlays.Overlay));
        overlays.Overlay = Overlay;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Checkbox = (function (_super) {
            __extends(Checkbox, _super);
            function Checkbox(game, label) {
                var _this = _super.call(this, game) || this;
                _this.interactiveChildren = false;
                _this.bg = new gf.display.Sprite(game, "sprites", "checkbox_out");
                _this.addChild(_this.bg);
                _this.check = new gf.display.Sprite(game, "sprites", "icon_check");
                _this.check.anchor.set(0.5);
                _this.check.tint = cuboro.COLOR_DARK_GREY;
                _this.check.x = _this.bg.width >> 1;
                _this.check.y = _this.bg.height >> 1;
                _this.addChild(_this.check);
                if (label)
                    _this.label = label;
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                _this.on(gf.CLICK, function () {
                    _this.isChecked = !_this.isChecked;
                }, _this);
                return _this;
            }
            Checkbox.prototype.addLabel = function () {
                this.tfLabel = new gf.display.Text(this.game, "", cuboro.TEXT_STYLE_BUTTON_CHECKBOX.clone());
                this.tfLabel.x = this.bg.right + 5;
                this.tfLabel.y = 2;
                this.addChild(this.tfLabel);
            };
            Checkbox.prototype.setState = function (state) {
                this.check.visible = this._isChecked;
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.frameName = "checkbox_down";
                        break;
                    case gf.OUT:
                        this.bg.frameName = "checkbox_out";
                        break;
                    case gf.OVER:
                        this.bg.frameName = "checkbox_over";
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.frameName = "checkbox_over";
                        }
                        else {
                            this.bg.frameName = "checkbox_out";
                        }
                        break;
                }
            };
            Checkbox.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.alpha = 1;
                this.setState(this._currentState);
            };
            Checkbox.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.bg.frameName = "checkbox_over";
                this.alpha = 0.5;
            };
            Checkbox.prototype.forceState = function (state) {
                this._currentState = state;
                this.setState(state);
            };
            Object.defineProperty(Checkbox.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (value == this._label)
                        return;
                    if (!this.tfLabel)
                        this.addLabel();
                    this._label = value;
                    this.tfLabel.text = this._label;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Checkbox.prototype, "isChecked", {
                get: function () {
                    return this._isChecked;
                },
                set: function (value) {
                    this._isChecked = value;
                    this.setState(this._currentState);
                },
                enumerable: true,
                configurable: true
            });
            return Checkbox;
        }(gf.ui.Button));
        ui.Checkbox = Checkbox;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var input;
    (function (input) {
        var Form = (function (_super) {
            __extends(Form, _super);
            function Form(game, name) {
                var _this = _super.call(this, game, "form") || this;
                _this._additionalData = {};
                if (typeof name == "string")
                    _this._formName = name;
                _this.disableSubmitButtonByInvalidInputs = true;
                _this.on("change", function () { return _this.change(); });
                return _this;
            }
            Form.prototype.change = function () {
                if (this.disableSubmitButtonByInvalidInputs && this._submitButton)
                    (this.validate()) ? this._submitButton.enable() : this._submitButton.disable();
            };
            Form.prototype.createDom = function () {
                var _this = this;
                _super.prototype.createDom.call(this);
                this._formDom = this._dom;
                this._formDom.autocomplete = "on";
                this._formDom.action = "form/submit";
                this._formDom.method = "post";
                this._formDom.name = this._formName;
                if (typeof this._formName == "string")
                    this._formDom.name = this._formName;
                this._formDom.onsubmit = function (e) {
                    var activeElement = (!!document.activeElement) ? document.activeElement : document.body;
                    activeElement.blur();
                    if (typeof _this.onSubmit == "function")
                        _this.onSubmit(_this.data);
                    e.preventDefault();
                    return true;
                };
                var submitInput = document.createElement("button");
                submitInput.type = "submit";
                submitInput.name = "Submit";
                submitInput.style.opacity = "0";
                this._formDom.appendChild(submitInput);
            };
            Form.prototype.addData = function (key, value) {
                this._additionalData[key] = value;
            };
            Form.prototype.addDomChild = function (child) {
                _super.prototype.addDomChild.call(this, child);
                this.change();
            };
            Form.prototype.clear = function () {
                this._domChildren.forEach(function (domDisplay) {
                    if (domDisplay["value"])
                        domDisplay["value"] = "";
                });
            };
            Form.prototype.submit = function () {
                var event;
                if (typeof document.createEvent == "function") {
                    event = document.createEvent("Event");
                    event.initEvent("submit", true, true);
                }
                else {
                    event = new Event("submit");
                }
                this._formDom.dispatchEvent(event);
            };
            Object.defineProperty(Form.prototype, "data", {
                get: function () {
                    var dataList = $(this._formDom).serializeArray();
                    var data = {};
                    dataList.forEach(function (dataItem) {
                        data[dataItem.name] = dataItem.value;
                    });
                    for (var key in this._additionalData)
                        data[key] = this._additionalData[key];
                    return data;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Form.prototype, "submitButton", {
                get: function () {
                    return this._submitButton;
                },
                set: function (value) {
                    this._submitButton = value;
                    this.change();
                },
                enumerable: true,
                configurable: true
            });
            return Form;
        }(gf.input.DomContainer));
        input.Form = Form;
    })(input = gf.input || (gf.input = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Account = (function (_super) {
            __extends(Account, _super);
            function Account() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Account.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("account_title");
                this.tfInfo = new gf.display.Text(this.game, loc("account"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfInfo.style.wordWrap = true;
                this.tfInfo.style.wordWrapWidth = this.bg.width - 44;
                this.tfInfo.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfInfo);
                this.form = new gf.input.Form(this.game, "login");
                this.form.onSubmit = function () { return _this.onSave(); };
                this.addChild(this.form);
                this.username = new cuboro.input.TextInput(this.game, this.form, "username");
                this.username.maxLength = 20;
                this.username.placeholder = loc("placeholder_username");
                this.username.tabIndex = 1;
                this.username.tfTitle.text = loc("placeholder_username");
                this.username.validation = function (value) { return _this.usernameValidation(value); };
                this.username.y = this.tfInfo.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.username);
                this.email = new cuboro.input.TextInput(this.game, this.form, "email");
                this.email.maxLength = 100;
                this.email.placeholder = loc("placeholder_email");
                this.email.tabIndex = 2;
                this.email.tfTitle.text = loc("placeholder_email");
                this.email.type = "email";
                this.email.validation = function (value) { return _this.emailValidation(value); };
                this.email.y = this.username.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.email);
                this.cbNewsletter = new cuboro.ui.Checkbox(this.game, loc("bt_newsletter"));
                this.cbNewsletter.y = this.email.bottom + cuboro.PADDING * 2;
                this.cbNewsletter.tfLabel.style.wordWrap = true;
                this.cbNewsletter.tfLabel.style.wordWrapWidth = this.username.width - this.cbNewsletter.tfLabel.x;
                this.addChild(this.cbNewsletter);
                this.btSave = new cuboro.ui.TextButton(this.game, loc("bt_save"), true);
                this.btSave.on(gf.CLICK, this.form.submit, this.form);
                this.btSave.y = this.cbNewsletter.bottom + cuboro.PADDING * 2;
                this.btSave.setWidth(this.username.width);
                this.addChild(this.btSave);
                this.tfError = new gf.display.Text(this.game);
                this.tfError.style = cuboro.TEXT_STYLE_INPUT_ERROR.clone();
                this.tfError.style.wordWrapWidth = this.bg.width - 44;
                this.tfError.visible = false;
                this.tfError.y = this.btSave.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfError);
                this.bg.height = this.btSave.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Account.prototype.emailValidation = function (value) {
                this.email.hideError();
                var valid = false;
                if (kr3m.util.Validator.email(value))
                    valid = true;
                else
                    this.email.showError(loc("error_input_default"));
                return valid;
            };
            Account.prototype.usernameValidation = function (value) {
                this.username.hideError();
                var valid = false;
                if (value.length > 0)
                    valid = true;
                else
                    this.username.showError(loc("error_input_default"));
                return valid;
            };
            Account.prototype.onSave = function () {
                var _this = this;
                if (this.form.validate()) {
                    this.accountData.email = this.email.value;
                    this.accountData.user.name = this.username.value;
                    this.accountData.newsletter = this.cbNewsletter.isChecked;
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    casClient.saveUserAccount(this.accountData, function (status) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (status == kr3m.SUCCESS) {
                            _this.game.overlays.hide(cuboro.overlays.Account.NAME);
                            _this.tfError.visible = false;
                            var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                            message.text = loc("account_changed");
                        }
                        else {
                            _this.tfError.text = loc("error_account_changed");
                            _this.tfError.visible = true;
                        }
                        _this.onResize();
                    });
                }
            };
            Account.prototype.onClose = function () {
                track("Account-Close");
                this.game.overlays.hide(cuboro.overlays.Account.NAME);
            };
            Account.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.email.x =
                    this.username.x =
                        this.tfInfo.x =
                            this.btSave.x =
                                this.cbNewsletter.x = this.bg.x + 22;
                this.tfError.x = this.btSave.x + ((this.btSave.width - this.tfError.width) >> 1);
                if (this.tfError.visible) {
                    this.bg.height = this.tfError.bottom - this.bg.y + cuboro.PADDING * 4;
                }
                else {
                    this.bg.height = this.btSave.bottom - this.bg.y + cuboro.PADDING * 4;
                }
            };
            Account.prototype.transitionIn = function () {
                var _this = this;
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                casClient.getUserAccount(function (account) {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    _this.accountData = account;
                    _this.username.value = _this.accountData.user.name;
                    _this.email.value = _this.accountData.email;
                    _this.cbNewsletter.isChecked = _this.accountData.newsletter;
                    _this.form.validate();
                });
            };
            Account.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            Account.NAME = "account";
            return Account;
        }(cuboro.overlays.Overlay));
        overlays.Account = Account;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var SelectSetButton = (function (_super) {
            __extends(SelectSetButton, _super);
            function SelectSetButton(game, setName) {
                var _this = _super.call(this, game) || this;
                _this.setName = setName;
                _this.cb = new cuboro.ui.Checkbox(_this.game, loc("packshot_" + _this.setName));
                _this.cb.on("click tap", _this.onCheckbox, _this);
                _this.addChild(_this.cb);
                _this.packshot = new gf.display.Sprite(_this.game, "sprites-sets", _this.setName);
                _this.packshot.y = _this.cb.bottom;
                _this.packshot.interactive = true;
                _this.packshot.on("click tap", _this.onPackshot, _this);
                _this.addChild(_this.packshot);
                return _this;
            }
            SelectSetButton.prototype.onCheckbox = function () {
                this.emit(gf.CHANGE, this);
            };
            SelectSetButton.prototype.onPackshot = function () {
                this.cb.isChecked = !this.cb.isChecked;
                this.emit(gf.CHANGE, this);
            };
            SelectSetButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.interactiveChildren = true;
            };
            SelectSetButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.interactiveChildren = false;
            };
            Object.defineProperty(SelectSetButton.prototype, "isSelected", {
                get: function () {
                    return this.cb.isChecked;
                },
                set: function (value) {
                    this.cb.isChecked = value;
                },
                enumerable: true,
                configurable: true
            });
            return SelectSetButton;
        }(gf.ui.Button));
        ui.SelectSetButton = SelectSetButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var AddSets = (function (_super) {
            __extends(AddSets, _super);
            function AddSets() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            AddSets.prototype.init = function () {
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("add_sets");
                this.bg.width = 500;
                this.bg.height = 420;
                this.content = new gf.display.Container(this.game);
                this.content.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.content);
                this.listMask = new gf.display.Sprite(this.game, PIXI.Texture.WHITE);
                this.listMask.width = 456;
                this.content.addChild(this.listMask);
                this.scrollbar = new cuboro.ui.Scrollbar(this.game);
                this.content.addChild(this.scrollbar);
                this.list = new gf.display.Container(this.game);
                this.list.interactive = true;
                this.list.mask = this.listMask;
                this.content.addChild(this.list);
                this.btAbort = new cuboro.ui.TextButton(this.game, loc("bt_abort"), false);
                this.btAbort.on(gf.CLICK, this.onClose, this);
                this.btAbort.y = this.bg.bottom - this.btAbort.height - cuboro.PADDING;
                this.btAbort.autoFit();
                this.addChild(this.btAbort);
                this.btAddSets = new cuboro.ui.TextButton(this.game, loc("bt_add_sets"), true);
                this.btAddSets.on(gf.CLICK, this.onAddSets, this);
                this.btAddSets.y = this.btAbort.y;
                this.btAddSets.autoFit();
                this.addChild(this.btAddSets);
                this.tfSelected = new gf.display.Text(this.game, loc("new_track_selected", {
                    sets: 0,
                    sixpacks: 0
                }), cuboro.TEXT_STYLE_TITLE_TAB.clone());
                this.tfSelected.style.fontFamily = cuboro.DEFAULT_FONT;
                this.tfSelected.style.fontSize = 13;
                this.tfSelected.y = this.btAbort.y + ((this.btAbort.height - this.tfSelected.height) >> 1);
                this.addChild(this.tfSelected);
                this.listMask.height = this.btAbort.y - cuboro.PADDING * 2 - this.content.y;
                this.bg.height = this.btAbort.bottom - this.bg.y + cuboro.PADDING * 4;
                this.addSets();
            };
            AddSets.prototype.addSet = function (value) {
                var bt = new cuboro.ui.SelectSetButton(this.game, value);
                bt.on(gf.CHANGE, this.onSet, this);
                this.list.addChild(bt);
                this.items.push(bt);
            };
            AddSets.prototype.addSets = function () {
                var _this = this;
                this.items = [];
                var setOrder = [cuboro.SETS.STANDARD,
                    cuboro.SETS.BASIC,
                    cuboro.SETS.BUILD,
                    cuboro.SETS.DUO,
                    cuboro.SETS.METRO,
                    cuboro.SETS.MULTI,
                    cuboro.SETS.PLUS,
                    cuboro.SETS.PROFI,
                    cuboro.SETS.SIXPACK_DUO,
                    cuboro.SETS.SIXPACK_PROFI,
                    cuboro.SETS.SIXPACK_METRO,
                    cuboro.SETS.SIXPACK_MULTI,
                    cuboro.SETS.SIXPACK_PLUS];
                setOrder.forEach(function (value) {
                    _this.addSet(value);
                });
                this.arrange();
            };
            AddSets.prototype.onSet = function () {
                var sets = 0;
                var sixpacks = 0;
                this.items.forEach(function (value) {
                    if (value.isSelected) {
                        if (value.setName.indexOf("sixpack") != -1)
                            sixpacks++;
                        else
                            sets++;
                    }
                });
                this.tfSelected.text = loc("new_track_selected", { sets: sets, sixpacks: sixpacks });
            };
            AddSets.prototype.onAddSets = function () {
                var _this = this;
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                var cubesToLoad = [];
                this.items.forEach(function (value) {
                    if (value.isSelected && mTrack.data.sets.indexOf(value.setName) == -1) {
                        mTrack.data.sets.push(value.setName);
                        _this.bottomMenu.cubeList.addSet(value.setName);
                        _this.bottomMenu.cubeList.sets[value.setName].forEach(function (cube) {
                            cubesToLoad.push("cube_" + cube[0]);
                        });
                    }
                });
                var assetLoader = new cuboro.core.AssetLoader(this.game, this.bottomMenu.gameScreen.playground.assets);
                cubesToLoad.forEach(function (value) { return assetLoader.threeJSON(value, "models/" + value + ".json"); });
                assetLoader.once(gf.LOAD_COMPLETE, function () {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    _this.bottomMenu.cubeList.arrange(_this.bottomMenu.cubeList.lastWidth);
                    _this.bottomMenu.cubeList.updateUsed();
                    _this.bottomMenu.btAddSets.label = loc("bt_select_sets", { count: mTrack.data.sets.length });
                    _this.game.overlays.hide(cuboro.overlays.AddSets.NAME);
                });
                assetLoader.start();
            };
            AddSets.prototype.arrange = function () {
                if (this.items.length == 0)
                    return;
                var itemSize;
                this.list.y = this.listMask.y;
                itemSize = this.items[0].width;
                var width = this.listMask.width;
                var col = 0;
                var row = 0;
                var cols = Math.floor(width / (itemSize + cuboro.PADDING));
                this.items.forEach(function (value) {
                    if (col == cols) {
                        row++;
                        col = 0;
                    }
                    value.x = col * itemSize + col * cuboro.PADDING * 2;
                    value.y = row * itemSize + row * cuboro.PADDING;
                    col++;
                });
                this.scrollbar.x = cols * itemSize + cols * (cuboro.PADDING * 2);
                this.listMask.width = this.scrollbar.x;
                this.scrollbar.update(this.list, this.listMask, 0);
                this.scrollbar.visible = this.scrollbar.sizeScroll > this.scrollbar.sizeVisible;
            };
            AddSets.prototype.onClose = function () {
                track("AddSets-Close");
                this.game.overlays.hide(cuboro.overlays.AddSets.NAME);
            };
            AddSets.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.content.x =
                    this.btAbort.x = this.bg.x + 22;
                this.btAddSets.x = this.bg.right - this.btAddSets.width - 22;
                this.tfSelected.x = this.btAbort.right + cuboro.PADDING * 2;
            };
            AddSets.prototype.transitionIn = function () {
                var _this = this;
                _super.prototype.transitionIn.call(this);
                this.items.forEach(function (bt) {
                    bt.isSelected = false;
                });
                mTrack.data.sets.forEach(function (setName) {
                    _this.items.forEach(function (bt) {
                        if (bt.setName == setName) {
                            bt.isSelected = true;
                            bt.isEnabled = false;
                        }
                    });
                });
                this.onSet();
            };
            AddSets.NAME = "addSets";
            return AddSets;
        }(cuboro.overlays.Overlay));
        overlays.AddSets = AddSets;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var ChangePassword = (function (_super) {
            __extends(ChangePassword, _super);
            function ChangePassword() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ChangePassword.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("change_password_title");
                this.form = new gf.input.Form(this.game, "changePassword");
                this.form.onSubmit = function () { return _this.onChangePassword(); };
                this.addChild(this.form);
                this.tfInfo = new gf.display.Text(this.game, loc("change_password"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfInfo.style.wordWrap = true;
                this.tfInfo.style.wordWrapWidth = this.bg.width - 44;
                this.tfInfo.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfInfo);
                this.passwordOld = new cuboro.input.TextInput(this.game, this.form, "passwordOld");
                this.passwordOld.maxLength = 50;
                this.passwordOld.placeholder = loc("placeholder_password_old");
                this.passwordOld.tabIndex = 1;
                this.passwordOld.type = "password";
                this.passwordOld.tfTitle.text = loc("placeholder_password_old");
                this.passwordOld.validation = function (value) { return _this.passwordValidation(value, _this.passwordOld); };
                this.passwordOld.y = this.tfInfo.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.passwordOld);
                this.passwordNew = new cuboro.input.TextInput(this.game, this.form, "passwordNew");
                this.passwordNew.maxLength = 50;
                this.passwordNew.placeholder = loc("placeholder_password_new");
                this.passwordNew.tabIndex = 2;
                this.passwordNew.type = "password";
                this.passwordNew.tfTitle.text = loc("placeholder_password_new");
                this.passwordNew.validation = function (value) { return _this.passwordValidationNew(value, _this.passwordNew); };
                this.passwordNew.y = this.passwordOld.bottom + cuboro.PADDING;
                this.form.addChild(this.passwordNew);
                this.passwordNewRepeat = new cuboro.input.TextInput(this.game, this.form, "passwordNewRepeat");
                this.passwordNewRepeat.maxLength = 50;
                this.passwordNewRepeat.placeholder = loc("placeholder_password_new_repeat");
                this.passwordNewRepeat.tabIndex = 3;
                this.passwordNewRepeat.type = "password";
                this.passwordNewRepeat.tfTitle.text = loc("placeholder_password_new_repeat");
                this.passwordNewRepeat.validation = function (value) { return _this.passwordValidationNew(value, _this.passwordNewRepeat); };
                this.passwordNewRepeat.y = this.passwordNew.bottom + cuboro.PADDING;
                this.form.addChild(this.passwordNewRepeat);
                this.cbShowPasswords = new cuboro.ui.Checkbox(this.game, loc("bt_show_passwords"));
                this.cbShowPasswords.y = this.passwordNewRepeat.bottom + cuboro.PADDING;
                this.cbShowPasswords.on(gf.CLICK, this.onTogglePasswords, this);
                this.addChild(this.cbShowPasswords);
                this.btChangePassword = new cuboro.ui.TextButton(this.game, loc("bt_change_password2"), true);
                this.btChangePassword.on(gf.CLICK, this.onChangePassword, this);
                this.btChangePassword.y = this.cbShowPasswords.bottom + cuboro.PADDING * 2;
                this.btChangePassword.setWidth(this.passwordOld.width);
                this.addChild(this.btChangePassword);
                this.tfError = new gf.display.Text(this.game);
                this.tfError.style = cuboro.TEXT_STYLE_INPUT_ERROR.clone();
                this.tfError.style.wordWrapWidth = this.bg.width - 44;
                this.tfError.visible = false;
                this.tfError.y = this.btChangePassword.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfError);
                this.bg.height = this.btChangePassword.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            ChangePassword.prototype.passwordValidation = function (value, input) {
                input.hideError();
                var valid = false;
                if (value.length >= 6 && value.length <= 50)
                    valid = true;
                else
                    input.showError(loc("error_password"));
                return valid;
            };
            ChangePassword.prototype.passwordValidationNew = function (value, input) {
                this.passwordNew.hideError();
                this.passwordNewRepeat.hideError();
                var valid = false;
                if (value.length >= 6 && value.length <= 50) {
                    if (this.passwordNew.value == this.passwordNewRepeat.value) {
                        valid = true;
                    }
                    else {
                        input.showError(loc("error_password_mismatch"));
                    }
                }
                else
                    input.showError(loc("error_password"));
                return valid;
            };
            ChangePassword.prototype.onTogglePasswords = function () {
                this.passwordOld.type = (this.cbShowPasswords.isChecked) ? "text" : "password";
                this.passwordNew.type = (this.cbShowPasswords.isChecked) ? "text" : "password";
                this.passwordNewRepeat.type = (this.cbShowPasswords.isChecked) ? "text" : "password";
            };
            ChangePassword.prototype.onChangePassword = function () {
                var _this = this;
                if (this.form.validate()) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    casClient.setPassword(this.passwordOld.value, this.passwordNew.value, function (status) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (status == kr3m.SUCCESS) {
                            _this.game.overlays.hide(cuboro.overlays.ChangePassword.NAME);
                            _this.tfError.visible = false;
                            var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                            message.text = loc("change_password_changed");
                        }
                        else {
                            _this.tfError.text = loc("error_password_change");
                            _this.tfError.visible = true;
                        }
                        _this.onResize();
                    });
                }
            };
            ChangePassword.prototype.onClose = function () {
                track("ChangePassword-Close");
                this.game.overlays.hide(cuboro.overlays.ChangePassword.NAME);
            };
            ChangePassword.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.cbShowPasswords.x =
                    this.passwordNew.x =
                        this.passwordNewRepeat.x =
                            this.passwordOld.x =
                                this.btChangePassword.x =
                                    this.tfError.x =
                                        this.tfInfo.x = this.bg.x + 22;
                if (this.tfError.visible)
                    this.bg.height = this.tfError.bottom - this.bg.y + cuboro.PADDING * 4;
                else
                    this.bg.height = this.btChangePassword.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            ChangePassword.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
                this.passwordNew.value = "";
                this.passwordNewRepeat.value = "";
                this.passwordOld.value = "";
            };
            ChangePassword.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            ChangePassword.NAME = "changePassword";
            return ChangePassword;
        }(cuboro.overlays.Overlay));
        overlays.ChangePassword = ChangePassword;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var input;
    (function (input) {
        var TextArea = (function (_super) {
            __extends(TextArea, _super);
            function TextArea(game, parent, name) {
                var _this = _super.call(this, game, parent, "textarea") || this;
                _this._regExp = /(\w|\W)+/;
                _this.required = true;
                _this._inputDom.name = name;
                _this._italic = false;
                _this._bold = false;
                _this.validateTrimmedValue = true;
                _this.addChangeListeners();
                return _this;
            }
            TextArea.prototype.addChangeListeners = function () {
                var _this = this;
                this._inputDom.addEventListener("keyup", function (e) {
                    if (e.keyCode != 9)
                        _this.onChange();
                });
                this._inputDom.oninput = function () { return _this.onChange(); };
                $(this._inputDom).blur(function () { return _this.onInputBlur(); });
                $(this._inputDom).focus(function () { return _this.onInputFocus(); });
            };
            TextArea.prototype.createDom = function () {
                _super.prototype.createDom.call(this);
                this._inputDom = this._dom;
                this._inputDom.style.position = "absolute";
                this._inputDom.style.border = "none";
                this._inputDom.style.fontFamily = "Arial, Helvetica, sans-serif";
            };
            TextArea.prototype.onInputBlur = function () {
            };
            TextArea.prototype.onInputFocus = function () {
            };
            TextArea.prototype.setFocus = function () {
                var _this = this;
                setTimeout(function () { return $(_this._inputDom).focus(); }, 1);
            };
            TextArea.prototype.validate = function () {
                if (this.readOnly)
                    return true;
                var value = (this.validateTrimmedValue) ? this.value.trim() : this.value;
                return (!this.required && this.value.length == 0) || this.regExp.test(value);
            };
            Object.defineProperty(TextArea.prototype, "inputDom", {
                get: function () {
                    return this._inputDom;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "name", {
                get: function () {
                    return this._inputDom.name;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "regExp", {
                get: function () {
                    return this._regExp;
                },
                set: function (value) {
                    this._regExp = value;
                    this.onChange();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "readOnly", {
                get: function () {
                    return this._inputDom.readOnly;
                },
                set: function (value) {
                    this._inputDom.readOnly = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "value", {
                get: function () {
                    return this._inputDom.value;
                },
                set: function (value) {
                    if (this._inputDom.value != value)
                        this.onChange();
                    this._inputDom.value = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "placeholder", {
                get: function () {
                    return this._inputDom.placeholder;
                },
                set: function (value) {
                    this._inputDom.placeholder = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "fontFamily", {
                get: function () {
                    return this._inputDom.style.fontFamily;
                },
                set: function (value) {
                    this._inputDom.style.fontFamily = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "fontSize", {
                get: function () {
                    return this._fontSize;
                },
                set: function (value) {
                    this._inputDom.style.fontSize = String(value) + "px";
                    this._fontSize = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "color", {
                get: function () {
                    return this._color;
                },
                set: function (value) {
                    this._inputDom.style.color = "#" + value.toString(16);
                    this._color = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "italic", {
                get: function () {
                    return this._italic;
                },
                set: function (value) {
                    this._inputDom.style.fontStyle = (value) ? "italic" : "regular";
                    this._italic = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "bold", {
                get: function () {
                    return this._bold;
                },
                set: function (value) {
                    this._inputDom.style.fontWeight = (value) ? "bold" : "normal";
                    this._bold = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "maxLength", {
                get: function () {
                    return this._inputDom.maxLength ? this._inputDom.maxLength : 0;
                },
                set: function (value) {
                    this._inputDom.maxLength = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "cols", {
                get: function () {
                    return this._inputDom.cols;
                },
                set: function (value) {
                    this._inputDom.cols = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "rows", {
                get: function () {
                    return this._inputDom.rows;
                },
                set: function (value) {
                    this._inputDom.rows = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "wrap", {
                get: function () {
                    return this._inputDom.wrap;
                },
                set: function (value) {
                    this._inputDom.wrap = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextArea.prototype, "resize", {
                get: function () {
                    return this._inputDom.style.resize;
                },
                set: function (value) {
                    this._inputDom.style.resize = value;
                },
                enumerable: true,
                configurable: true
            });
            return TextArea;
        }(gf.display.DomDisplayObject));
        input.TextArea = TextArea;
    })(input = gf.input || (gf.input = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var input;
    (function (input) {
        var TextArea = (function (_super) {
            __extends(TextArea, _super);
            function TextArea(game, parent, name) {
                var _this = _super.call(this, game, parent, name) || this;
                _this.fontFamily = cuboro.DEFAULT_FONT;
                _this.fontSize = 13;
                _this.resize = gf.NONE;
                _this.tfTitle = new gf.display.Text(_this.game);
                _this.tfTitle.style = cuboro.TEXT_STYLE_SMALL.clone();
                _this.tfTitle.x = cuboro.PADDING;
                _this.tfTitle.text = "";
                _this.addChild(_this.tfTitle);
                _this.border = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.border.width = 227;
                _this.border.height = 27;
                _this.border.tint = cuboro.COLOR_GREY;
                _this.border.y = _this.tfTitle.bottom;
                _this.addChild(_this.border);
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.width = 225;
                _this.bg.height = 25;
                _this.bg.x = 1;
                _this.bg.y = _this.border.y + 1;
                _this.addChild(_this.bg);
                _this.tfError = new gf.display.Text(_this.game);
                _this.tfError.style = cuboro.TEXT_STYLE_INPUT_ERROR.clone();
                _this.tfError.style.wordWrapWidth = _this.border.width - cuboro.PADDING * 2;
                _this.tfError.text = "";
                _this.tfError.x = cuboro.PADDING;
                _this.tfError.y = _this.border.bottom + 2;
                _this.addChild(_this.tfError);
                _this.paddingLeft = cuboro.PADDING;
                _this.paddingRight = cuboro.PADDING;
                _this._dom.style.marginTop = "18px";
                _this.width = _this.bg.width;
                return _this;
            }
            TextArea.prototype.onChange = function () {
                _super.prototype.onChange.call(this);
                if (this.tfError.visible) {
                    this.hideError();
                }
            };
            TextArea.prototype.onInputBlur = function () {
                this.validate();
                this.emit(gf.BLUR);
            };
            TextArea.prototype.setRows = function (value) {
                this.rows = value;
                var h = this.fontSize * value;
                this.inputDom.style.height = h + "px";
                this.bg.height = h;
                this.border.height = this.bg.height + 2;
                this.tfError.y = this.border.bottom + 2;
            };
            TextArea.prototype.hideError = function () {
                this.tfError.text = "";
                this.tfError.visible = false;
                this.border.tint = cuboro.COLOR_GREY;
            };
            TextArea.prototype.showError = function (text) {
                this.tfError.text = text;
                this.tfError.visible = true;
                this.border.tint = cuboro.COLOR_RED;
            };
            TextArea.prototype.validate = function () {
                this._inputDom.value = this.value.trim();
                if (!this.validation)
                    return true;
                return this.validation(this.value);
            };
            Object.defineProperty(TextArea.prototype, "width", {
                get: function () {
                    return this.getLocalBounds().width;
                },
                set: function (value) {
                    this.setWidth(value);
                    this.bg.width = value;
                    this.border.width = value + 2;
                },
                enumerable: true,
                configurable: true
            });
            return TextArea;
        }(gf.input.TextArea));
        input.TextArea = TextArea;
    })(input = cuboro.input || (cuboro.input = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Contact = (function (_super) {
            __extends(Contact, _super);
            function Contact() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Contact.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("contact");
                this.form = new gf.input.Form(this.game, "contact");
                this.form.onSubmit = function () { return _this.onContact(); };
                this.addChild(this.form);
                this.tfInfo = new gf.display.Text(this.game, loc("contact_info"), cuboro.TEXT_STYLE_DEFAULT.clone());
                this.tfInfo.style.fontSize = 13;
                this.tfInfo.style.wordWrap = true;
                this.tfInfo.style.wordWrapWidth = this.bg.width - 44;
                this.tfInfo.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfInfo);
                this.username = new cuboro.input.TextInput(this.game, this.form, "username");
                this.username.maxLength = 100;
                this.username.placeholder = loc("placeholder_username");
                this.username.required = true;
                this.username.tabIndex = 1;
                this.username.tfTitle.text = loc("placeholder_username");
                this.username.validation = function (value) { return _this.usernameValidation(value); };
                this.username.y = this.tfInfo.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.username);
                this.email = new cuboro.input.TextInput(this.game, this.form, "email");
                this.email.maxLength = 100;
                this.email.placeholder = loc("placeholder_email");
                this.email.required = true;
                this.email.tabIndex = 2;
                this.email.tfTitle.text = loc("placeholder_email");
                this.email.type = "email";
                this.email.validation = function (value) { return _this.emailValidation(value); };
                this.email.y = this.username.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.email);
                this.message = new cuboro.input.TextArea(this.game, this.form, "message");
                this.message.placeholder = loc("placeholder_message");
                this.message.tabIndex = 3;
                this.message.tfTitle.text = loc("placeholder_message");
                this.message.validation = function (value) { return _this.messageValidation(value); };
                this.message.required = true;
                this.message.setRows(5);
                this.message.y = this.email.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.message);
                this.tfDisclaimer = new gf.display.Text(this.game, loc("contact_disclaimer"), cuboro.TEXT_STYLE_DEFAULT.clone());
                this.tfDisclaimer.style.fontSize = 13;
                this.tfDisclaimer.style.wordWrap = true;
                this.tfDisclaimer.style.wordWrapWidth = this.bg.width - 44;
                this.tfDisclaimer.y = this.message.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfDisclaimer);
                var btWidth = (this.bg.width - 44 - cuboro.PADDING * 2) >> 1;
                this.btSubmit = new cuboro.ui.TextButton(this.game, loc("bt_submit"), true);
                this.btSubmit.x = cuboro.PADDING;
                this.btSubmit.y = this.tfDisclaimer.bottom + cuboro.PADDING * 2;
                this.btSubmit.on(gf.CLICK, this.onContact, this);
                this.btSubmit.setWidth(btWidth);
                this.addChild(this.btSubmit);
                this.btAbort = new cuboro.ui.TextButton(this.game, loc("bt_abort"), false);
                this.btAbort.y = this.btSubmit.y;
                this.btAbort.on(gf.CLICK, this.onClose, this);
                this.btAbort.setWidth(btWidth);
                this.addChild(this.btAbort);
                this.bg.height = this.btAbort.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Contact.prototype.usernameValidation = function (value) {
                this.username.hideError();
                var valid = false;
                if (value.length > 0)
                    valid = true;
                else
                    this.username.showError(loc("error_input_default"));
                return valid;
            };
            Contact.prototype.emailValidation = function (value) {
                this.email.hideError();
                var valid = false;
                if (kr3m.util.Validator.email(value))
                    valid = true;
                else
                    this.email.showError(loc("error_input_default"));
                return valid;
            };
            Contact.prototype.messageValidation = function (value) {
                this.message.hideError();
                var valid = false;
                if (value.length > 0)
                    valid = true;
                else
                    this.message.showError(loc("error_input_default"));
                return valid;
            };
            Contact.prototype.onContact = function () {
                var _this = this;
                if (this.form.validate()) {
                    track("Contact-Submit");
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sMail.sendContact(this.username.value, this.email.value, this.message.value, function () {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        _this.game.overlays.hide(cuboro.overlays.Contact.NAME);
                    });
                }
            };
            Contact.prototype.onClose = function () {
                track("Contact-Close");
                this.game.overlays.hide(cuboro.overlays.Contact.NAME);
            };
            Contact.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.btSubmit.x =
                    this.username.x =
                        this.email.x =
                            this.message.x =
                                this.tfDisclaimer.x =
                                    this.tfInfo.x = this.bg.x + 22;
                this.btAbort.x = this.username.right - this.btAbort.width;
            };
            Contact.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
                this.username.value = "";
                this.email.value = "";
                this.message.value = "";
            };
            Contact.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            Contact.NAME = "contact";
            return Contact;
        }(cuboro.overlays.Overlay));
        overlays.Contact = Contact;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var FinishRegister = (function (_super) {
            __extends(FinishRegister, _super);
            function FinishRegister() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            FinishRegister.prototype.init = function () {
                _super.prototype.init.call(this);
                this.bg.width = 340;
                this.tfTitle.text = loc("finish_register_title");
                this.tfValidateTitle = new gf.display.Text(this.game, loc("finish_register_validate_title"), cuboro.TEXT_STYLE_DEFAULT_HEAVY.clone());
                this.tfValidateTitle.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfValidateTitle);
                this.tfValidate = new gf.display.Text(this.game, loc("finish_register_validate"), cuboro.TEXT_STYLE_DEFAULT.clone());
                this.tfValidate.style.fontSize = 13;
                this.tfValidate.style.wordWrap = true;
                this.tfValidate.style.wordWrapWidth = this.bg.width - 44;
                this.tfValidate.y = this.tfValidateTitle.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfValidate);
                this.tfResendTitle = new gf.display.Text(this.game, loc("finish_register_resend_title"), cuboro.TEXT_STYLE_DEFAULT_HEAVY.clone());
                this.tfResendTitle.y = this.tfValidate.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfResendTitle);
                this.tfResend = new gf.display.Text(this.game, loc("finish_register_resend"), cuboro.TEXT_STYLE_DEFAULT.clone());
                this.tfResend.style.fontSize = 13;
                this.tfResend.style.wordWrap = true;
                this.tfResend.style.wordWrapWidth = this.bg.width - 44;
                this.tfResend.y = this.tfResendTitle.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfResend);
                this.btResend = new cuboro.ui.TextButton(this.game, loc("bt_resend"), true);
                this.btResend.on(gf.CLICK, this.onResend, this);
                this.btResend.y = this.tfResend.bottom + cuboro.PADDING * 2;
                this.btResend.setWidth(220);
                this.addChild(this.btResend);
                this.bg.height = this.btResend.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            FinishRegister.prototype.onResend = function () {
                var _this = this;
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                casClient.resendValidationEmail(function (status) {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    if (status == kr3m.SUCCESS) {
                        _this.game.overlays.hide(cuboro.overlays.FinishRegister.NAME);
                    }
                });
            };
            FinishRegister.prototype.onClose = function () {
                track("FinishRegister-Close");
                this.game.overlays.hide(cuboro.overlays.FinishRegister.NAME);
            };
            Object.defineProperty(FinishRegister.prototype, "email", {
                set: function (value) {
                    this.tfValidate.text = loc("finish_register_validate", { email: value });
                },
                enumerable: true,
                configurable: true
            });
            FinishRegister.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.tfValidate.x =
                    this.tfValidateTitle.x =
                        this.tfResend.x =
                            this.tfResendTitle.x = this.bg.x + 22;
                this.btResend.x = this.bg.x + ((this.bg.width - this.btResend.width) >> 1);
            };
            FinishRegister.NAME = "finishRegister";
            return FinishRegister;
        }(cuboro.overlays.Overlay));
        overlays.FinishRegister = FinishRegister;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var ForgotPassword = (function (_super) {
            __extends(ForgotPassword, _super);
            function ForgotPassword() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            ForgotPassword.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("forgot_password");
                this.form = new gf.input.Form(this.game, "forgotPassword");
                this.form.onSubmit = function () { return _this.onForgotPassword(); };
                this.addChild(this.form);
                this.tfInfo = new gf.display.Text(this.game, loc("forgot_password_info"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfInfo.style.wordWrap = true;
                this.tfInfo.style.wordWrapWidth = 227;
                this.tfInfo.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfInfo);
                this.email = new cuboro.input.TextInput(this.game, this.form, "email");
                this.email.maxLength = 100;
                this.email.placeholder = loc("placeholder_email");
                this.email.tabIndex = 1;
                this.email.tfTitle.text = loc("placeholder_email");
                this.email.type = "email";
                this.email.validation = function (value) { return _this.emailValidation(value); };
                this.email.y = this.tfInfo.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.email);
                this.btRequestPassword = new cuboro.ui.TextButton(this.game, loc("bt_request_password"), true);
                this.btRequestPassword.on(gf.CLICK, this.onForgotPassword, this);
                this.btRequestPassword.y = this.email.bottom + cuboro.PADDING * 2;
                this.btRequestPassword.setWidth(this.email.width);
                this.addChild(this.btRequestPassword);
                this.btRegister = new cuboro.ui.TextButton(this.game, loc("bt_register"), false);
                this.btRegister.y = this.btRequestPassword.bottom + cuboro.PADDING * 2;
                this.btRegister.on(gf.CLICK, this.onRegister, this);
                this.btRegister.setWidth(this.email.width);
                this.addChild(this.btRegister);
                this.btLogin = new cuboro.ui.TextButton(this.game, loc("bt_back_to_login"), false);
                this.btLogin.y = this.btRegister.bottom + cuboro.PADDING;
                this.btLogin.on(gf.CLICK, this.onLogin, this);
                this.btLogin.setWidth(this.email.width);
                this.addChild(this.btLogin);
                this.bg.height = this.btLogin.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            ForgotPassword.prototype.emailValidation = function (value) {
                this.email.tfError.text = "";
                var valid = false;
                if (kr3m.util.Validator.email(value))
                    valid = true;
                else
                    this.email.tfError.text = loc("error_input_default");
                return valid;
            };
            ForgotPassword.prototype.onForgotPassword = function () {
                var _this = this;
                if (this.form.validate()) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    casClient.sendPasswordRecoverMail(this.email.value, function () {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        _this.game.overlays.hide(cuboro.overlays.ForgotPassword.NAME);
                        var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                        message.text = loc("forgot_password_send");
                    });
                }
            };
            ForgotPassword.prototype.onLogin = function () {
                this.game.overlays.hide(cuboro.overlays.ForgotPassword.NAME);
                this.game.overlays.show(cuboro.overlays.Login.NAME);
            };
            ForgotPassword.prototype.onRegister = function () {
                this.game.overlays.hide(cuboro.overlays.ForgotPassword.NAME);
                this.game.overlays.show(cuboro.overlays.Register.NAME);
            };
            ForgotPassword.prototype.onClose = function () {
                track("ForgotPassword-Close");
                this.game.overlays.hide(cuboro.overlays.ForgotPassword.NAME);
            };
            ForgotPassword.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.email.x =
                    this.btLogin.x =
                        this.btRegister.x =
                            this.btRequestPassword.x =
                                this.tfInfo.x = this.bg.x + 22;
            };
            ForgotPassword.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
            };
            ForgotPassword.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            ForgotPassword.NAME = "forgotPassword";
            return ForgotPassword;
        }(cuboro.overlays.Overlay));
        overlays.ForgotPassword = ForgotPassword;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Imprint = (function (_super) {
            __extends(Imprint, _super);
            function Imprint() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Imprint.prototype.init = function () {
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("imprint_title");
                this.tf = new gf.display.Text(this.game, loc("imprint"), cuboro.TEXT_STYLE_DEFAULT.clone());
                this.tf.style.fontSize = 13;
                this.tf.style.wordWrap = true;
                this.tf.style.wordWrapWidth = this.bg.width - 44;
                this.tf.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tf);
                this.bg.height = this.tf.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Imprint.prototype.onClose = function () {
                track("Imprint-Close");
                this.game.overlays.hide(cuboro.overlays.Imprint.NAME);
            };
            Imprint.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.tf.x = this.bg.x + 22;
            };
            Imprint.NAME = "imprint";
            return Imprint;
        }(cuboro.overlays.Overlay));
        overlays.Imprint = Imprint;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Loader = (function (_super) {
            __extends(Loader, _super);
            function Loader() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Loader.prototype.init = function () {
                this.addNoClick();
                this.addDim();
                this.animationContainer = new gf.display.Container(this.game);
                this.animationContainer.hAlign(gf.CENTER);
                this.animationContainer.vAlign(gf.CENTER, this.game, -5);
                this.addChild(this.animationContainer);
                this.animationBg = new gf.display.Sprite(this.game, PIXI.Texture.WHITE);
                this.animationBg.width = 100;
                this.animationBg.height = 130;
                this.animationContainer.addChild(this.animationBg);
                this.animation = new gf.display.Container(this.game);
                this.animation.x = 3;
                this.animation.y = 3;
                this.animationContainer.addChild(this.animation);
                this.tf = new gf.display.Text(this.game);
                this.tf.style = cuboro.TEXT_STYLE_SMALL.clone();
                this.tf.text = loc("please_wait");
                this.tf.hAlign(gf.CENTER, 100);
                this.tf.y = this.animationBg.height - this.tf.height - cuboro.PADDING;
                this.animationContainer.addChild(this.tf);
                this.quads = [];
                var quad = this.getQuad();
                var space1 = quad.width + 2;
                var space2 = quad.width * 2 + 4;
                this.data = [
                    { x: 0, y: 0 },
                    { x: space1, y: 0 },
                    { x: space2, y: 0 },
                    { x: space2, y: space1 },
                    { x: space2, y: space2 },
                    { x: space1, y: space2 },
                    { x: 0, y: space2 },
                    { x: 0, y: space1 },
                ];
                for (var i = 0; i < 7; ++i) {
                    quad = this.getQuad();
                    quad.x = this.data[i].x;
                    quad.y = this.data[i].y;
                    this.animation.addChild(quad);
                    this.quads.push(quad);
                }
                quad = this.getQuad();
                quad.x = space1;
                quad.y = space1;
                this.animation.addChild(quad);
            };
            Loader.prototype.getQuad = function () {
                var quad = new gf.display.Sprite(this.game, PIXI.Texture.WHITE);
                quad.tint = cuboro.COLOR_YELLOW;
                quad.width = 30;
                quad.height = 30;
                return quad;
            };
            Loader.prototype.timeout = function () {
                var message = this.game.overlays.show(cuboro.overlays.Message.NAME);
                message.text = loc("error_offline");
                this.transitionOut();
            };
            Loader.prototype.animateQuad = function (currentIndex) {
                var _this = this;
                var quad = this.quads[currentIndex];
                var nextIndex = ((currentIndex - 1) < 0) ? this.quads.length - 1 : currentIndex - 1;
                var nextPosition = this.getNextPosition(quad.x, quad.y);
                this.tween = TweenMax.to(quad, 0.25, {
                    x: nextPosition.x, y: nextPosition.y
                });
                this.delayedCall = TweenMax.delayedCall(0.1, function () {
                    _this.animateQuad(nextIndex);
                });
            };
            Loader.prototype.getNextPosition = function (x, y) {
                var _this = this;
                var result = null;
                this.data.forEach(function (value, index) {
                    if (value.x == x && value.y == y) {
                        if (index + 1 > _this.data.length - 1) {
                            result = new PIXI.Point(_this.data[0].x, _this.data[0].y);
                        }
                        else {
                            result = new PIXI.Point(_this.data[index + 1].x, _this.data[index + 1].y);
                        }
                        return true;
                    }
                });
                return result;
            };
            Loader.prototype.transitionIn = function () {
                var _this = this;
                _super.prototype.transitionIn.call(this);
                if (!this.tween && !this.delayedCall) {
                    this.animateQuad(6);
                }
                else {
                    this.tween.resume();
                    this.delayedCall.resume();
                }
                window.clearTimeout(this.timeoutId);
                this.timeoutId = window.setTimeout(function () { return _this.timeout(); }, 15000);
            };
            Loader.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                window.clearTimeout(this.timeoutId);
            };
            Loader.prototype.transitionOutComplete = function () {
                _super.prototype.transitionOutComplete.call(this);
                this.tween.pause();
                this.delayedCall.pause();
            };
            Loader.NAME = "loader";
            return Loader;
        }(cuboro.overlays.Overlay));
        overlays.Loader = Loader;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Login = (function (_super) {
            __extends(Login, _super);
            function Login() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Login.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("login");
                this.form = new gf.input.Form(this.game, "login");
                this.form.onSubmit = function () { return _this.onLogin(); };
                this.addChild(this.form);
                this.email = new cuboro.input.TextInput(this.game, this.form, "email");
                this.email.maxLength = 100;
                this.email.placeholder = loc("placeholder_email");
                this.email.tabIndex = 1;
                this.email.tfTitle.text = loc("placeholder_email");
                this.email.type = "email";
                this.email.required = true;
                this.email.validation = function (value) { return _this.emailValidation(value); };
                this.email.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.form.addChild(this.email);
                this.password = new cuboro.input.TextInput(this.game, this.form, "password");
                this.password.maxLength = 50;
                this.password.placeholder = loc("placeholder_password_login");
                this.password.tabIndex = 2;
                this.password.type = "password";
                this.password.required = true;
                this.password.tfTitle.text = loc("placeholder_password_login");
                this.password.validation = function (value) { return _this.passwordValidation(value); };
                this.password.y = this.email.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.password);
                this.cbShowPassword = new cuboro.ui.Checkbox(this.game, loc("bt_show_password"));
                this.cbShowPassword.y = this.password.bottom + cuboro.PADDING;
                this.cbShowPassword.on(gf.CLICK, this.onTogglePassword, this);
                this.addChild(this.cbShowPassword);
                this.cbAlwaysLogin = new cuboro.ui.Checkbox(this.game, loc("bt_always_login"));
                this.cbAlwaysLogin.y = this.cbShowPassword.bottom + cuboro.PADDING;
                this.addChild(this.cbAlwaysLogin);
                this.btLogin = new cuboro.ui.TextButton(this.game, loc("bt_login"), true);
                this.btLogin.on(gf.CLICK, this.form.submit, this.form);
                this.btLogin.x = gf.utils.Align.centerX(this.btLogin, this.width);
                this.btLogin.y = this.cbAlwaysLogin.bottom + cuboro.PADDING;
                this.btLogin.setWidth(this.email.width);
                this.addChild(this.btLogin);
                this.tfError = new gf.display.Text(this.game);
                this.tfError.style = cuboro.TEXT_STYLE_INPUT_ERROR.clone();
                this.tfError.style.align = gf.CENTER;
                this.tfError.style.wordWrapWidth = this.bg.width - 44;
                this.tfError.visible = false;
                this.tfError.y = this.btLogin.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfError);
                this.tfRegister = new gf.display.Text(this.game, loc("login_register"), cuboro.TEXT_STYLE_TITLE_TAB.clone());
                this.tfRegister.style.fontSize = 13;
                this.tfRegister.y = this.btLogin.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfRegister);
                this.btRegister = new cuboro.ui.TextButton(this.game, loc("bt_register"), false);
                this.btRegister.y = this.tfRegister.bottom + cuboro.PADDING;
                this.btRegister.on(gf.CLICK, this.onRegister, this);
                this.btRegister.setWidth(this.email.width);
                this.addChild(this.btRegister);
                this.btForgotPassword = new cuboro.ui.TextButton(this.game, loc("bt_forgot_password"), false);
                this.btForgotPassword.on(gf.CLICK, this.onForgotPassword, this);
                this.btForgotPassword.y = this.btRegister.bottom + cuboro.PADDING * 2;
                this.btForgotPassword.setWidth(this.email.width);
                this.addChild(this.btForgotPassword);
                this.bg.height = this.btForgotPassword.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Login.prototype.emailValidation = function (value) {
                this.email.hideError();
                var valid = false;
                if (kr3m.util.Validator.email(value))
                    valid = true;
                else
                    this.email.showError(loc("error_input_default"));
                return valid;
            };
            Login.prototype.passwordValidation = function (value) {
                this.password.hideError();
                var valid = false;
                if (value.length >= 6 && value.length <= 50)
                    valid = true;
                else
                    this.password.showError(loc("error_password"));
                return valid;
            };
            Login.prototype.onForgotPassword = function () {
                this.game.overlays.hide(cuboro.overlays.Login.NAME);
                this.game.overlays.show(cuboro.overlays.ForgotPassword.NAME);
            };
            Login.prototype.onRegister = function () {
                this.game.overlays.hide(cuboro.overlays.Login.NAME);
                this.game.overlays.show(cuboro.overlays.Register.NAME);
            };
            Login.prototype.onLogin = function () {
                var _this = this;
                if (this.form.validate()) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    casClient.loginEmail(this.email.value, this.password.value, function (status) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (status == kr3m.SUCCESS) {
                            _this.game.overlays.hide(cuboro.overlays.Login.NAME);
                            _this.tfError.visible = false;
                        }
                        else {
                            _this.tfError.text = loc("error_login_failed");
                            _this.tfError.visible = true;
                        }
                        _this.onResize();
                    });
                }
            };
            Login.prototype.onTogglePassword = function () {
                this.password.type = (this.cbShowPassword.isChecked) ? "text" : "password";
            };
            Login.prototype.onClose = function () {
                track("Login-Close");
                this.game.overlays.hide(cuboro.overlays.Login.NAME);
            };
            Login.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.email.x =
                    this.password.x =
                        this.cbShowPassword.x =
                            this.btForgotPassword.x =
                                this.btLogin.x =
                                    this.btRegister.x =
                                        this.cbAlwaysLogin.x = this.bg.x + 22;
                this.tfRegister.x = this.btRegister.x + ((this.btRegister.width - this.tfRegister.width) >> 1);
                if (this.tfError.visible) {
                    this.tfError.x = this.btRegister.x + ((this.btRegister.width - this.tfError.width) >> 1);
                    this.tfRegister.y = this.tfError.bottom + cuboro.PADDING * 4;
                }
                else {
                    this.tfRegister.y = this.btLogin.bottom + cuboro.PADDING * 4;
                }
                this.btRegister.y = this.tfRegister.bottom + cuboro.PADDING;
                this.btForgotPassword.y = this.btRegister.bottom + cuboro.PADDING * 2;
                this.bg.height = this.btForgotPassword.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Login.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
            };
            Login.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            Login.NAME = "login";
            return Login;
        }(cuboro.overlays.Overlay));
        overlays.Login = Login;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Message = (function (_super) {
            __extends(Message, _super);
            function Message() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Message.prototype.init = function () {
                _super.prototype.init.call(this);
                this.dim.interactive = true;
                this.dim.on("click tap", this.onClose, this);
                this.tfMessage = new gf.display.Text(this.game);
                this.tfMessage.style = cuboro.TEXT_STYLE_DEFAULT.clone();
                this.tfMessage.style.align = gf.CENTER;
                this.tfMessage.style.fontSize = 13;
                this.tfMessage.style.wordWrap = true;
                this.tfMessage.style.wordWrapWidth = this.bg.width - 44;
                this.tfMessage.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfMessage);
            };
            Message.prototype.onClose = function () {
                this.game.overlays.hide(cuboro.overlays.Message.NAME);
            };
            Message.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.tfMessage.x = this.bg.x + ((this.bg.width - this.tfMessage.width) >> 1);
                this.bg.height = this.tfMessage.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Message.prototype.transitionOutComplete = function () {
                _super.prototype.transitionOutComplete.call(this);
                this.tfTitle.text = "";
                this.tfMessage.text = "";
            };
            Object.defineProperty(Message.prototype, "text", {
                set: function (value) {
                    this.tfMessage.text = value;
                    this.onResize();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Message.prototype, "title", {
                set: function (value) {
                    this.tfTitle.text = value;
                    this.onResize();
                },
                enumerable: true,
                configurable: true
            });
            Message.NAME = "message";
            return Message;
        }(cuboro.overlays.Overlay));
        overlays.Message = Message;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Slice3 = (function (_super) {
            __extends(Slice3, _super);
            function Slice3(game, firstSize, secondSize, key, frameName, direction) {
                if (direction === void 0) { direction = gf.HORIZONTAL; }
                var _this = this;
                var h = direction == gf.HORIZONTAL;
                _this = _super.call(this, game, h ? firstSize : 10, h ? 10 : firstSize, h ? secondSize : 10, h ? 10 : secondSize, key, frameName) || this;
                return _this;
            }
            return Slice3;
        }(gf.display.Slice9));
        display.Slice3 = Slice3;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TextButton = (function (_super) {
            __extends(TextButton, _super);
            function TextButton(game, label, isPrimary) {
                var _this = _super.call(this, game) || this;
                _this.isPrimary = isPrimary;
                _this.bg = new gf.display.Slice3(game, 10, 80, "sprites", (_this.isPrimary) ? "bt_text_out" : "bt_text_sek_out");
                _this.addChild(_this.bg);
                _this.tfLabel = new gf.display.Text(game, "", cuboro.TEXT_STYLE_BUTTON_TEXT.clone());
                _this.tfLabel.anchor.y = 0.5;
                _this.tfLabel.x = 10;
                _this.tfLabel.y = _this.bg.height >> 1;
                _this.addChild(_this.tfLabel);
                _this.label = label;
                _this.setState(gf.OUT);
                return _this;
            }
            TextButton.prototype.setState = function (state) {
                this.tfLabel.alpha = 1;
                if (!this.isEnabled) {
                    this.bg.frameName = "bt_text_disabled";
                    this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                    this.tfLabel.alpha = 0.5;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.frameName = "bt_text_down";
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OUT:
                        this.bg.frameName = (this.isPrimary) ? "bt_text_out" : "bt_text_sek_out";
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.frameName = "bt_text_over";
                        this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.frameName = "bt_text_over";
                            this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.bg.frameName = (this.isPrimary) ? "bt_text_out" : "bt_text_sek_out";
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            TextButton.prototype.setWidth = function (value) {
                this.bg.width = value;
                this.tfLabel.hAlign(gf.CENTER, value);
                this.hitArea = this.getLocalBounds();
            };
            TextButton.prototype.autoFit = function (padding) {
                if (padding === void 0) { padding = cuboro.PADDING; }
                this.bg.width = this.tfLabel.width + padding * 2;
                this.tfLabel.hAlign(gf.CENTER, this.bg.width);
            };
            TextButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.setState(this._currentState);
            };
            TextButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.setState(this._currentState);
            };
            Object.defineProperty(TextButton.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (value == this._label)
                        return;
                    this._label = value;
                    this.tfLabel.text = this._label;
                    this.bg.width = Math.round(this.tfLabel.width) + 20;
                    this.hitArea = this.getLocalBounds();
                },
                enumerable: true,
                configurable: true
            });
            return TextButton;
        }(gf.ui.Button));
        ui.TextButton = TextButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var LowQuality = (function (_super) {
            __extends(LowQuality, _super);
            function LowQuality() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            LowQuality.prototype.init = function () {
                _super.prototype.init.call(this);
                this.btReload = new cuboro.ui.TextButton(this.game, loc("bt_reload"), false);
                this.btReload.on(gf.CLICK, this.onReload, this);
                this.addChild(this.btReload);
                this.text = loc("hint_low_quality");
                this.title = loc("hint_low_quality_title", { name: loc("app_title") });
            };
            LowQuality.prototype.onReload = function () {
                track("LowQuality-Reload");
                location.href = window.location.href + ((window.location.href.indexOf("?") == -1) ? "?" : "&") + "lowquality=1";
            };
            LowQuality.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.btReload.x = this.bg.x + ((this.bg.width - this.btReload.width) >> 1);
                this.btReload.y = this.tfMessage.bottom + cuboro.PADDING * 2;
                this.bg.height = this.btReload.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            LowQuality.NAME = "lowquality";
            return LowQuality;
        }(cuboro.overlays.Message));
        overlays.LowQuality = LowQuality;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var NewComment = (function (_super) {
            __extends(NewComment, _super);
            function NewComment() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            NewComment.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.form = new gf.input.Form(this.game, "newComment");
                this.form.onSubmit = function () { return _this.onSubmit(); };
                this.addChild(this.form);
                this.tfTitle.text = loc("comment_new_title");
                this.tfInfo = new gf.display.Text(this.game, loc("comment_info"), cuboro.TEXT_STYLE_DEFAULT.clone());
                this.tfInfo.style.fontSize = 13;
                this.tfInfo.style.wordWrap = true;
                this.tfInfo.style.wordWrapWidth = this.bg.width - 44;
                this.tfInfo.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfInfo);
                this.message = new cuboro.input.TextArea(this.game, this.form, "comment");
                this.message.placeholder = loc("placeholder_comment");
                this.message.tabIndex = 3;
                this.message.tfTitle.text = loc("placeholder_comment");
                this.message.validation = function (value) { return _this.messageValidation(value); };
                this.message.required = true;
                this.message.setRows(5);
                this.message.y = this.tfInfo.bottom + cuboro.PADDING * 2;
                this.message.maxLength = 500;
                this.form.addChild(this.message);
                var btWidth = (this.bg.width - 44 - cuboro.PADDING * 2) >> 1;
                this.btSubmit = new cuboro.ui.TextButton(this.game, loc("bt_submit"), true);
                this.btSubmit.x = cuboro.PADDING;
                this.btSubmit.y = this.message.bottom + cuboro.PADDING * 2;
                this.btSubmit.on(gf.CLICK, this.onSubmit, this);
                this.btSubmit.setWidth(btWidth);
                this.addChild(this.btSubmit);
                this.btAbort = new cuboro.ui.TextButton(this.game, loc("bt_abort"), false);
                this.btAbort.y = this.btSubmit.y;
                this.btAbort.on(gf.CLICK, this.onClose, this);
                this.btAbort.setWidth(btWidth);
                this.addChild(this.btAbort);
                this.bg.height = this.btAbort.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            NewComment.prototype.messageValidation = function (value) {
                this.message.hideError();
                var valid = false;
                if (value.length > 0)
                    valid = true;
                else
                    this.message.showError(loc("error_input_default"));
                return valid;
            };
            NewComment.prototype.onSubmit = function () {
                var _this = this;
                if (this.form.validate()) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sComment.saveTrackComment(this.trackId, this.message.value, function () {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        _this.game.overlays.hide(cuboro.overlays.NewComment.NAME);
                    });
                }
            };
            NewComment.prototype.onClose = function () {
                this.game.overlays.hide(cuboro.overlays.NewComment.NAME);
            };
            NewComment.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.btSubmit.x =
                    this.tfInfo.x =
                        this.message.x = this.bg.x + 22;
                this.btAbort.x = this.bg.x + (this.bg.width - this.btAbort.width - 22);
            };
            NewComment.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
                this.message.value = "";
            };
            NewComment.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            NewComment.NAME = "newComment";
            return NewComment;
        }(cuboro.overlays.Overlay));
        overlays.NewComment = NewComment;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Publish = (function (_super) {
            __extends(Publish, _super);
            function Publish() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Publish.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("publish_title");
                this.bg.width = 400;
                this.form = new gf.input.Form(this.game, "forgotPassword");
                this.form.onSubmit = function () { return _this.onNext(); };
                this.addChild(this.form);
                this.progress = new gf.display.Sprite(this.game, "sprites", "progress_1");
                this.progress.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.addChild(this.progress);
                this.trackName = new cuboro.input.TextInput(this.game, this.form, "trackName");
                this.trackName.maxLength = 30;
                this.trackName.placeholder = loc("placeholder_track");
                this.trackName.tabIndex = 1;
                this.trackName.tfTitle.text = loc("placeholder_track");
                this.trackName.y = this.progress.bottom + cuboro.PADDING * 2;
                this.trackName.validation = function (value) { return _this.trackNameValidation(value); };
                this.trackName.on(gf.BLUR, this.onTrackName, this);
                this.form.addChild(this.trackName);
                this.tfTrackNameValid = new gf.display.Text(this.game, loc("publish_trackname_accepted"), cuboro.TEXT_STYLE_INPUT_SUCCESS.clone());
                this.tfTrackNameValid.style.wordWrapWidth = this.trackName.tfError.style.wordWrapWidth;
                this.tfTrackNameValid.x = this.trackName.tfError.x;
                this.tfTrackNameValid.y = this.trackName.tfError.y;
                this.tfTrackNameValid.visible = false;
                this.trackName.addChild(this.tfTrackNameValid);
                var btWidth = (this.trackName.width >> 1) - cuboro.PADDING * 2;
                this.btBack = new cuboro.ui.TextButton(this.game, loc("bt_back"), false);
                this.btBack.on(gf.CLICK, this.onBack, this);
                this.btBack.setWidth(btWidth);
                this.addChild(this.btBack);
                this.btNext = new cuboro.ui.TextButton(this.game, loc("bt_next"), true);
                this.btNext.on(gf.CLICK, this.onNext, this);
                this.btNext.setWidth(btWidth);
                this.addChild(this.btNext);
                this.btPublish = new cuboro.ui.TextButton(this.game, loc("bt_publish2"), true);
                this.btPublish.on(gf.CLICK, this.onPublish, this);
                this.btPublish.autoFit();
                this.btPublish.y = this.btBack.y;
                this.addChild(this.btPublish);
                this.tfReviewTitle = new gf.display.Text(this.game, loc("publish_review_title"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfReviewTitle.style.fontFamily = cuboro.DEFAULT_FONT_HEAVY;
                this.tfReviewTitle.y = this.progress.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfReviewTitle);
                this.tfReview = new gf.display.Text(this.game, loc("publish_review"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfReview.style.lineHeight = 16;
                this.tfReview.y = this.tfReviewTitle.bottom + cuboro.PADDING;
                this.addChild(this.tfReview);
                this.tfReviewValues = new gf.display.Text(this.game, loc("publish_review_values"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfReviewValues.style.lineHeight = 16;
                this.tfReviewValues.y = this.tfReview.y;
                this.addChild(this.tfReviewValues);
                this.tfInfo = new gf.display.Text(this.game, loc("publish_info"), cuboro.TEXT_STYLE_SMALL.clone());
                this.tfInfo.style.wordWrap = true;
                this.tfInfo.style.wordWrapWidth = this.bg.width - 44;
                this.tfInfo.y = this.tfReview.bottom + cuboro.PADDING * 4;
                this.addChild(this.tfInfo);
                this.step = 1;
            };
            Publish.prototype.update = function () {
                this.tfReviewValues.text = mTrack.name + "\n" +
                    locDate("publish_date", mTrack.lastSavedWhen) + "\n" +
                    mTrack.data.evaluation.scoreTotal.toString();
            };
            Publish.prototype.trackNameValidation = function (value) {
                this.trackName.hideError();
                var valid = false;
                if (value.length >= 3)
                    valid = true;
                else
                    this.trackName.showError(loc("error_input_track_name"));
                return valid;
            };
            Publish.prototype.onTrackName = function (cb) {
                var _this = this;
                if (this.form.validate()) {
                    this.trackName.hideError();
                    this.tfTrackNameValid.visible = false;
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sTrack.isNameUnique(mTrack.id, this.trackName.value, function (isUnique) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (isUnique) {
                            _this.tfTrackNameValid.visible = true;
                            mTrack.name = _this.trackName.value;
                            _this.game.stage.header.trackMenu.trackName.value = _this.trackName.value;
                            _this.update();
                            if (cb)
                                cb(true);
                        }
                        else {
                            _this.trackName.showError(loc("error_track_name_taken"));
                            if (cb)
                                cb(false);
                        }
                    });
                }
            };
            Publish.prototype.onBack = function () {
                this.step--;
            };
            Publish.prototype.onNext = function () {
                var _this = this;
                if (this._step == 1) {
                    this.onTrackName(function (isUnique) {
                        console.log("isUnique " + isUnique);
                        if (isUnique)
                            _this.step++;
                    });
                }
            };
            Publish.prototype.onClose = function () {
                track("Publish-Close");
                this.game.overlays.hide(cuboro.overlays.Publish.NAME);
            };
            Publish.prototype.onPublish = function () {
                var _this = this;
                if (mTrack.id) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sTrack.publish(mTrack.id, mTrack.name, function (status) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        _this.game.overlays.hide(cuboro.overlays.Publish.NAME);
                        if (status == kr3m.SUCCESS) {
                            _this.game.stage.header.trackMenu.checkPublish();
                            var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                            message.text = loc("track_published");
                        }
                        else {
                            var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                            message.text = loc("error_track_publish");
                        }
                    });
                }
            };
            Publish.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.btBack.x =
                    this.tfInfo.x =
                        this.tfReview.x =
                            this.tfReviewTitle.x = this.bg.x + 22;
                this.trackName.x = this.bg.x + ((this.bg.width - this.trackName.width) >> 1);
                this.tfReviewValues.x = this.tfReview.right + cuboro.PADDING;
                this.progress.x = this.bg.x + ((this.bg.width - this.progress.width) >> 1);
                this.btNext.x = this.bg.right - this.btNext.width - 22;
                this.btPublish.x = this.bg.right - this.btPublish.width - 22;
            };
            Publish.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.step = 1;
                this.trackName.value = mTrack.name;
                this.update();
                this.onTrackName();
            };
            Publish.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            Object.defineProperty(Publish.prototype, "step", {
                get: function () {
                    return this._step;
                },
                set: function (value) {
                    this._step = Math.min(2, Math.max(1, value));
                    this.progress.frameName = "progress_" + this._step;
                    this.btPublish.visible = this._step == 2;
                    this.tfInfo.visible = this.btPublish.visible;
                    this.tfReview.visible = this.btPublish.visible;
                    this.tfReviewValues.visible = this.btPublish.visible;
                    this.tfReviewTitle.visible = this.btPublish.visible;
                    this.btNext.visible = this._step == 1;
                    if (this.step == 1) {
                        this.form.showDom();
                        this.trackName.visible = true;
                        this.btBack.y =
                            this.btNext.y = this.trackName.bottom + cuboro.PADDING * 4;
                        this.bg.height = this.btNext.bottom - this.bg.y + cuboro.PADDING * 4;
                    }
                    else {
                        this.form.hideDom();
                        this.trackName.visible = false;
                        this.btBack.y =
                            this.btPublish.y = this.tfInfo.bottom + cuboro.PADDING * 4;
                        this.bg.height = this.btPublish.bottom - this.bg.y + cuboro.PADDING * 4;
                    }
                    this.btBack.visible = this.step == 2;
                },
                enumerable: true,
                configurable: true
            });
            Publish.NAME = "publish";
            return Publish;
        }(cuboro.overlays.Overlay));
        overlays.Publish = Publish;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var Register = (function (_super) {
            __extends(Register, _super);
            function Register() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Register.prototype.init = function () {
                var _this = this;
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("register");
                this.form = new gf.input.Form(this.game, "register");
                this.form.onSubmit = function () { return _this.onRegister(); };
                this.addChild(this.form);
                this.username = new cuboro.input.TextInput(this.game, this.form, "username");
                this.username.maxLength = 20;
                this.username.placeholder = loc("placeholder_username");
                this.username.tabIndex = 1;
                this.username.tfTitle.text = loc("placeholder_username");
                this.username.validation = function (value) { return _this.usernameValidation(value); };
                this.username.y = this.tfTitle.bottom + cuboro.PADDING * 4;
                this.form.addChild(this.username);
                this.email = new cuboro.input.TextInput(this.game, this.form, "email");
                this.email.maxLength = 100;
                this.email.placeholder = loc("placeholder_email");
                this.email.tabIndex = 2;
                this.email.tfTitle.text = loc("placeholder_email");
                this.email.type = "email";
                this.email.validation = function (value) { return _this.emailValidation(value); };
                this.email.y = this.username.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.email);
                this.password = new cuboro.input.TextInput(this.game, this.form, "password");
                this.password.maxLength = 50;
                this.password.placeholder = loc("placeholder_password_register");
                this.password.tabIndex = 3;
                this.password.type = "password";
                this.password.validation = function (value) { return _this.passwordValidation(value); };
                this.password.tfTitle.text = loc("placeholder_password_login");
                this.password.y = this.email.bottom + cuboro.PADDING * 2;
                this.form.addChild(this.password);
                this.cbShowPassword = new cuboro.ui.Checkbox(this.game, loc("bt_show_password"));
                this.cbShowPassword.y = this.password.bottom + cuboro.PADDING;
                this.cbShowPassword.on(gf.CLICK, this.onTogglePassword, this);
                this.addChild(this.cbShowPassword);
                this.cbNewsletter = new cuboro.ui.Checkbox(this.game, loc("bt_newsletter"));
                this.cbNewsletter.y = this.cbShowPassword.bottom + cuboro.PADDING * 2;
                this.cbNewsletter.tfLabel.style.wordWrap = true;
                this.cbNewsletter.tfLabel.style.wordWrapWidth = this.username.width - this.cbNewsletter.tfLabel.x;
                this.addChild(this.cbNewsletter);
                this.btRegister = new cuboro.ui.TextButton(this.game, loc("bt_register"), true);
                this.btRegister.on(gf.CLICK, this.form.submit, this.form);
                this.btRegister.y = this.cbNewsletter.bottom + cuboro.PADDING * 2;
                this.btRegister.setWidth(this.username.width);
                this.addChild(this.btRegister);
                this.btAlreadyRegistered = new cuboro.ui.TextButton(this.game, loc("bt_already_registered"), false);
                this.btAlreadyRegistered.on(gf.CLICK, this.onLogin, this);
                this.btAlreadyRegistered.y = this.btRegister.bottom + cuboro.PADDING;
                this.btAlreadyRegistered.setWidth(this.username.width);
                this.addChild(this.btAlreadyRegistered);
                this.tfError = new gf.display.Text(this.game);
                this.tfError.style = cuboro.TEXT_STYLE_INPUT_ERROR.clone();
                this.tfError.style.align = gf.CENTER;
                this.tfError.style.wordWrapWidth = this.bg.width - 44;
                this.tfError.visible = false;
                this.tfError.y = this.btAlreadyRegistered.bottom + cuboro.PADDING * 2;
                this.addChild(this.tfError);
                this.bg.height = this.btAlreadyRegistered.bottom - this.bg.y + cuboro.PADDING * 4;
            };
            Register.prototype.emailValidation = function (value) {
                this.email.hideError();
                var valid = false;
                if (kr3m.util.Validator.email(value))
                    valid = true;
                else
                    this.email.showError(loc("error_input_default"));
                return valid;
            };
            Register.prototype.passwordValidation = function (value) {
                this.password.hideError();
                var valid = false;
                if (value.length >= 6 && value.length <= 50)
                    valid = true;
                else
                    this.password.showError(loc("error_password"));
                return valid;
            };
            Register.prototype.usernameValidation = function (value) {
                this.username.hideError();
                var valid = false;
                if (value.length > 0)
                    valid = true;
                else
                    this.username.showError(loc("error_input_default"));
                return valid;
            };
            Register.prototype.onLogin = function () {
                this.game.overlays.hide(cuboro.overlays.Register.NAME);
                this.game.overlays.show(cuboro.overlays.Login.NAME);
            };
            Register.prototype.onRegister = function () {
                var _this = this;
                if (this.form.validate()) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    casClient.registerEmail(this.username.value, this.email.value, this.password.value, this.cbNewsletter.isChecked, {}, function (status) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (status == kr3m.SUCCESS) {
                            _this.game.overlays.hide(cuboro.overlays.Register.NAME);
                            _this.game.overlays.show(cuboro.overlays.FinishRegister.NAME);
                            _this.tfError.visible = false;
                        }
                        else {
                            _this.tfError.text = loc("error_register_failed");
                            _this.tfError.visible = true;
                        }
                        _this.onResize();
                    });
                }
            };
            Register.prototype.onTogglePassword = function () {
                this.password.type = (this.cbShowPassword.isChecked) ? "text" : "password";
            };
            Register.prototype.onClose = function () {
                track("Register-Close");
                this.game.overlays.hide(cuboro.overlays.Register.NAME);
            };
            Register.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.username.x =
                    this.email.x =
                        this.password.x =
                            this.cbShowPassword.x =
                                this.btRegister.x =
                                    this.btAlreadyRegistered.x =
                                        this.cbNewsletter.x =
                                            this.cbShowPassword.x = this.bg.x + 22;
                if (this.tfError.visible) {
                    this.tfError.x = this.btRegister.x + ((this.btRegister.width - this.tfError.width) >> 1);
                    this.bg.height = this.tfError.bottom - this.bg.y + cuboro.PADDING * 4;
                }
                else {
                    this.bg.height = this.btAlreadyRegistered.bottom - this.bg.y + cuboro.PADDING * 4;
                }
            };
            Register.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.form.showDom();
            };
            Register.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.form.hideDom();
            };
            Register.NAME = "register";
            return Register;
        }(cuboro.overlays.Overlay));
        overlays.Register = Register;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TabButton = (function (_super) {
            __extends(TabButton, _super);
            function TabButton(game, label) {
                var _this = _super.call(this, game) || this;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.height = 40;
                _this.addChild(_this.bg);
                _this.tfLabel = new gf.display.Text(_this.game, label, cuboro.TEXT_STYLE_BUTTON_TAB.clone());
                _this.tfLabel.x = 20;
                _this.tfLabel.y = 10;
                _this.addChild(_this.tfLabel);
                _this.setState(_this.currentState);
                return _this;
            }
            TabButton.prototype.setState = function (state) {
                this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                if (!this._isEnabled) {
                    this.tfLabel.style.fill = cuboro.COLOR_MID_GREY;
                    return;
                }
                if (this._isSelected) {
                    this.bg.tint = cuboro.COLOR_WHITE;
                    if (this.tfLabel.style.fontFamily != cuboro.TEXT_STYLE_BUTTON_TAB_SELECTED.fontFamily)
                        this.tfLabel.style = cuboro.TEXT_STYLE_BUTTON_TAB_SELECTED.clone();
                    return;
                }
                else {
                    if (this.tfLabel.style.fontFamily != cuboro.TEXT_STYLE_BUTTON_TAB.fontFamily)
                        this.tfLabel.style = cuboro.TEXT_STYLE_BUTTON_TAB.clone();
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_GREY;
                        break;
                    case gf.OUT:
                        this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_MID_GREY;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_MID_GREY;
                        }
                        else {
                            this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        }
                        break;
                }
            };
            TabButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.setState(this._currentState);
            };
            TabButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.setState(this._currentState);
            };
            Object.defineProperty(TabButton.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    if (value == this._isSelected)
                        return;
                    this._isSelected = value;
                    this.setState(this.currentState);
                },
                enumerable: true,
                configurable: true
            });
            return TabButton;
        }(gf.ui.Button));
        ui.TabButton = TabButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Graphics = (function (_super) {
            __extends(Graphics, _super);
            function Graphics(game) {
                var _this = _super.call(this) || this;
                _this.game = game;
                _this.name = "";
                _this.alignData = new gf.utils.AlignData();
                _this.userData = {};
                return _this;
            }
            Graphics.prototype.c = function () {
                this.clear();
                return this;
            };
            Graphics.prototype.mt = function (x, y) {
                this.moveTo(x, y);
                return this;
            };
            Graphics.prototype.lt = function (x, y) {
                this.lineTo(x, y);
                return this;
            };
            Graphics.prototype.f = function (color, alpha) {
                this.beginFill(color, alpha);
                return this;
            };
            Graphics.prototype.ef = function () {
                this.endFill();
                return this;
            };
            Graphics.prototype.dc = function (x, y, radius) {
                this.drawCircle(x, y, radius);
                return this;
            };
            Graphics.prototype.dr = function (x, y, width, height) {
                this.drawRect(x, y, width, height);
                return this;
            };
            Graphics.prototype.rr = function (x, y, width, height, radius) {
                this.drawRoundedRect(x, y, width, height, radius);
                return this;
            };
            Graphics.prototype.ls = function (lineWidth, color, alpha) {
                this.lineStyle(lineWidth, color, alpha);
                return this;
            };
            Graphics.prototype.hAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.hAlign(this, align, alignTo, offset);
            };
            Graphics.prototype.vAlign = function (align, alignTo, offset) {
                if (offset === void 0) { offset = 0; }
                gf.utils.Align.vAlign(this, align, alignTo, offset);
            };
            Graphics.prototype.onResize = function () {
                gf.utils.Align.onResize(this);
            };
            Graphics.prototype.on = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.on.call(_this, e, fn, context); });
                return this;
            };
            Graphics.prototype.off = function (events, fn, once) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.off.call(_this, e, fn, once); });
                return this;
            };
            Graphics.prototype.once = function (events, fn, context) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.once.call(_this, e, fn, context); });
                return this;
            };
            Graphics.prototype.removeAllListeners = function (events) {
                var _this = this;
                if (!events)
                    return this;
                events.split(" ").forEach(function (e) { return _super.prototype.removeAllListeners.call(_this, e); });
                return this;
            };
            Object.defineProperty(Graphics.prototype, "angle", {
                get: function () {
                    return gf.utils.Angle.getAngle(this);
                },
                set: function (value) {
                    gf.utils.Angle.setAngle(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "scaleX", {
                get: function () {
                    return gf.utils.Scale.getScaleX(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleX(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "scaleY", {
                get: function () {
                    return gf.utils.Scale.getScaleY(this);
                },
                set: function (value) {
                    gf.utils.Scale.setScaleY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "scaleXY", {
                set: function (value) {
                    gf.utils.Scale.setScaleXY(this, value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "left", {
                get: function () {
                    return gf.utils.Align.left(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "right", {
                get: function () {
                    return gf.utils.Align.right(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "top", {
                get: function () {
                    return gf.utils.Align.top(this);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Graphics.prototype, "bottom", {
                get: function () {
                    return gf.utils.Align.bottom(this);
                },
                enumerable: true,
                configurable: true
            });
            return Graphics;
        }(PIXI.Graphics));
        display.Graphics = Graphics;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        utils.MOUSE_WHEEL = "mouseWheel";
        var MouseWheel = (function (_super) {
            __extends(MouseWheel, _super);
            function MouseWheel() {
                var _this = _super.call(this) || this;
                _this.events = ("onwheel" in document || document["documentMode"] >= 9) ? ["wheel"] : ["mousewheel", "DomMouseScroll", "MozMousePixelScroll"];
                _this.mouseWheel = function (e) {
                    _this.onWheel(e);
                };
                if (document.addEventListener) {
                    for (var i = _this.events.length; i;) {
                        window.addEventListener(_this.events[--i], _this.mouseWheel, false);
                    }
                }
                else {
                    document.onmousewheel = _this.mouseWheel;
                }
                return _this;
            }
            MouseWheel.prototype.onWheel = function (e) {
                e.preventDefault();
                var orgEvent = e || window.event;
                var absDelta, delta, deltaX, deltaY = 0;
                e.type = "mousewheel";
                if ("detail" in orgEvent) {
                    deltaY = orgEvent.detail * -1;
                }
                if ("wheelDelta" in orgEvent) {
                    deltaY = orgEvent.wheelDelta;
                }
                if ("wheelDeltaY" in orgEvent) {
                    deltaY = orgEvent.wheelDeltaY;
                }
                if ("wheelDeltaX" in orgEvent) {
                    deltaX = orgEvent.wheelDeltaX * -1;
                }
                if ("axis" in orgEvent && orgEvent.axis === orgEvent.HORIZONTAL_AXIS) {
                    deltaX = deltaY * -1;
                    deltaY = 0;
                }
                delta = deltaY === 0 ? deltaX : deltaY;
                if ("deltaY" in orgEvent) {
                    deltaY = orgEvent.deltaY * -1;
                    delta = deltaY;
                }
                if ("deltaX" in orgEvent) {
                    deltaX = orgEvent.deltaX;
                    if (deltaY === 0) {
                        delta = deltaX * -1;
                    }
                }
                if (deltaY === 0 && deltaX === 0) {
                    return;
                }
                absDelta = Math.max(Math.abs(deltaY), Math.abs(deltaX));
                if (!this.lowestDelta || absDelta < this.lowestDelta) {
                    this.lowestDelta = absDelta;
                }
                e.delta = Math[delta >= 1 ? "floor" : "ceil"](delta / this.lowestDelta);
                e.deltaX = Math[deltaX >= 1 ? "floor" : "ceil"](deltaX / this.lowestDelta);
                e.deltaY = Math[deltaY >= 1 ? "floor" : "ceil"](deltaY / this.lowestDelta);
                this.emit(gf.utils.MOUSE_WHEEL, e);
            };
            return MouseWheel;
        }(PIXI.utils.EventEmitter));
        utils.MouseWheel = MouseWheel;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var ui;
    (function (ui) {
        var SimpleScrollBar = (function (_super) {
            __extends(SimpleScrollBar, _super);
            function SimpleScrollBar(game, direction) {
                if (direction === void 0) { direction = gf.VERTICAL; }
                var _this = _super.call(this, game) || this;
                _this.interactive = true;
                _this._direction = direction;
                _this._offsetX = 0;
                _this._offsetY = 0;
                _this._scrollPos = 0;
                _this._sizeScroll = 0;
                _this._sizeVisible = 0;
                _this._thumbMinSize = 50;
                _this._thumbMaxSize = Infinity;
                _this.defaultThumb = new gf.display.Graphics(_this.game);
                _this.defaultThumb.interactive = true;
                _this.defaultThumb.buttonMode = true;
                _this.defaultTrack = new gf.display.Graphics(_this.game);
                _this.addTrack(_this.defaultTrack);
                _this.addThumb(_this.defaultThumb);
                _this.mouseWheel = new gf.utils.MouseWheel();
                _this.enable();
                var usePointer = parseInt(PIXI.VERSION.split(".").join("")) < 452;
                if (usePointer && _this.game.client.config.isMobile) {
                    _this.on("pointerdown", function (e) { return _this.onDragStart(e); });
                    _this.on("pointerup pointerupoutside", function (e) { return _this.onDragEnd(e); });
                    _this.on("pointermove", function (e) { return _this.onDragMove(e, true); });
                }
                return _this;
            }
            SimpleScrollBar.prototype.onDragStart = function (e) {
                this._dragStart = e.data.global.clone();
                this._startPos = this._scrollPos;
                this._dragging = true;
            };
            SimpleScrollBar.prototype.onDragEnd = function (e) {
                this._dragging = false;
            };
            SimpleScrollBar.prototype.onDragMove = function (e, invert) {
                if (invert === void 0) { invert = false; }
                if (this._dragging) {
                    var pos = e.data.global.clone();
                    var dif = this.isVertical ? pos.y - this._dragStart.y : pos.x - this._dragStart.x;
                    this.updateScrollPos(invert ? this._startPos - dif : this._startPos + dif);
                }
            };
            SimpleScrollBar.prototype.onMouseWheel = function (e) {
                this.updateScrollPos(this._scrollPos + ((e.delta > 0) ? -20 : 20));
            };
            SimpleScrollBar.prototype.updateScrollPos = function (value) {
                this._scrollPos = Math.max(0, Math.min(value, this._scrollMax));
                this.scroll();
            };
            SimpleScrollBar.prototype.drawThumb = function () {
                this.defaultThumb.c().f(0x000000, 0.5).rr(0, 0, this.isVertical ? 8 : this._thumbSize, this.isVertical ? this._thumbSize : 8, 4).ef();
            };
            SimpleScrollBar.prototype.drawTrack = function () {
                this.defaultTrack.c().f(0x000000, 0.15).rr(0, 0, this.isVertical ? 8 : this._sizeVisible, this.isVertical ? this._sizeVisible : 8, 4).ef();
            };
            SimpleScrollBar.prototype.addThumb = function (value) {
                var _this = this;
                if (this._thumb === value)
                    return;
                if (!this.game.client.config.isMobile) {
                    if (this._thumb) {
                        if (this._thumb == this.defaultThumb)
                            this._thumb.visible = false;
                        this._thumb.off("pointerdown", function (e) { return _this.onDragStart(e); });
                        this._thumb.off("pointerup pointerupoutside", function (e) { return _this.onDragEnd(e); });
                        this._thumb.off("pointermove", function (e) { return _this.onDragMove(e); });
                    }
                }
                this._thumb = value;
                this._thumb.buttonMode = true;
                this._thumb.on("pointerdown", function (e) { return _this.onDragStart(e); });
                this._thumb.on("pointerup pointerupoutside", function (e) { return _this.onDragEnd(e); });
                this._thumb.on("pointermove", function (e) { return _this.onDragMove(e); });
                this._thumb = value;
                this.addChild(this._thumb);
                this.scroll();
            };
            SimpleScrollBar.prototype.addTrack = function (value) {
                if (this._track === value)
                    return;
                if (this._track) {
                    if (this._track == this.defaultTrack)
                        this._track.visible = false;
                }
                this._track = value;
                this.addChild(this._track);
                this.scroll();
            };
            SimpleScrollBar.prototype.enable = function () {
                var _this = this;
                this.mouseWheel.on(gf.utils.MOUSE_WHEEL, function (e) { return _this.onMouseWheel(e); }, this);
            };
            SimpleScrollBar.prototype.disable = function () {
                this.mouseWheel.removeAllListeners(gf.utils.MOUSE_WHEEL);
            };
            SimpleScrollBar.prototype.scroll = function () {
                var _this = this;
                if (!this._thumb || !this._track || !this.toScroll || !this.scrollMask)
                    return;
                this._thumbSize = Math.max(this._thumbMinSize, Math.min(this._thumbMaxSize, this._sizeVisible, this.sizeVisible / this._sizeScroll * this.sizeVisible));
                this._scrollMax = this._sizeVisible - this._thumbSize;
                if (this._thumb == this.defaultThumb) {
                    this.drawThumb();
                }
                if (this._track == this.defaultTrack) {
                    this.drawTrack();
                }
                if (this.visible) {
                    var value = (this._scrollMax > 0) ? (this._scrollPos / this._scrollMax) * (this.sizeScroll - this.sizeVisible) : 0;
                    if (this.isVertical) {
                        TweenMax.to(this._thumb, 0.25, { y: this._scrollPos });
                        TweenMax.to(this.toScroll, 0.25, {
                            y: this.scrollMask.y - value,
                            onUpdate: function () { return _this.emit(gf.CHANGE); }
                        });
                    }
                    else {
                        TweenMax.to(this._thumb, 0.25, { x: this._scrollPos });
                        TweenMax.to(this.toScroll, 0.25, {
                            x: this.scrollMask.x - value,
                            onUpdate: function () { return _this.emit(gf.CHANGE); }
                        });
                    }
                }
            };
            SimpleScrollBar.prototype.update = function (toScroll, mask, marginX, marginY) {
                if (marginX === void 0) { marginX = 0; }
                if (marginY === void 0) { marginY = 0; }
                this.toScroll = toScroll;
                this.scrollMask = mask;
                if (this.isVertical) {
                    this._track.x = this._thumb.x = this.scrollMask.width + marginX;
                    this.x = this.scrollMask.x;
                    this.y = this.scrollMask.y + marginY;
                    this.sizeVisible = this.scrollMask.height - marginY * 2;
                    this.sizeScroll = this.toScroll.height + this._offsetY;
                }
                else {
                    this.x = this.scrollMask.x + marginX;
                    this.y = this.scrollMask.y;
                    this._track.y = this._thumb.y = this.scrollMask.height + marginY;
                    this.sizeVisible = this.scrollMask.width - marginX * 2;
                    this.sizeScroll = this.toScroll.width + this._offsetX;
                }
                this.emit(gf.UPDATE);
                this.visible = this.sizeScroll > this.sizeVisible;
                this.scroll();
            };
            SimpleScrollBar.prototype.updateToContentPosition = function () {
                var f = -(this.toScroll.y - this.scrollMask.y) / (this.toScroll.height - this.scrollMask.height);
                this._scrollPos = (this.sizeVisible - this._thumbSize) * f;
                if (this.isVertical) {
                    TweenMax.to(this._thumb, 0.25, { y: this._scrollPos });
                }
                else {
                    TweenMax.to(this._thumb, 0.25, { x: this._scrollPos });
                }
            };
            Object.defineProperty(SimpleScrollBar.prototype, "sizeScroll", {
                get: function () {
                    return this._sizeScroll;
                },
                set: function (value) {
                    if (this._sizeScroll === value)
                        return;
                    this._sizeScroll = value;
                    this.scroll();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SimpleScrollBar.prototype, "sizeVisible", {
                get: function () {
                    return this._sizeVisible;
                },
                set: function (value) {
                    if (this._sizeVisible === value)
                        return;
                    this._sizeVisible = value;
                    this.scroll();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SimpleScrollBar.prototype, "thumbMaxSize", {
                get: function () {
                    return this._thumbMaxSize;
                },
                set: function (value) {
                    this._thumbMaxSize = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SimpleScrollBar.prototype, "direction", {
                get: function () {
                    return this._direction;
                },
                set: function (value) {
                    if (this._direction === value)
                        return;
                    this._direction = value;
                    this.scroll();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SimpleScrollBar.prototype, "offsetX", {
                get: function () {
                    return this._offsetX;
                },
                set: function (value) {
                    this._offsetX = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SimpleScrollBar.prototype, "offsetY", {
                get: function () {
                    return this._offsetY;
                },
                set: function (value) {
                    this._offsetY = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(SimpleScrollBar.prototype, "isVertical", {
                get: function () {
                    return this._direction === gf.VERTICAL;
                },
                enumerable: true,
                configurable: true
            });
            return SimpleScrollBar;
        }(gf.display.Container));
        ui.SimpleScrollBar = SimpleScrollBar;
    })(ui = gf.ui || (gf.ui = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Scrollbar = (function (_super) {
            __extends(Scrollbar, _super);
            function Scrollbar(game, direction) {
                if (direction === void 0) { direction = gf.VERTICAL; }
                var _this = _super.call(this, game, direction) || this;
                _this._thumbMinSize = 18;
                _this._thumbMaxSize = 100;
                if (_this.isVertical)
                    _this.defaultThumb.c().f(0xffffff).dr(0, 0, 18, 18).ef();
                else
                    _this.defaultThumb.c().f(0xffffff).dr(0, 0, 18, 18).ef();
                _this.defaultThumb.tint = cuboro.COLOR_DARK_GREY;
                _this.defaultThumb.on("mouseover", function () {
                    _this.defaultThumb.tint = cuboro.COLOR_LIGHT_GREY;
                    _this.game.renderState = 2;
                });
                _this.defaultThumb.on("mouseout", function () {
                    _this.defaultThumb.tint = cuboro.COLOR_DARK_GREY;
                    _this.game.renderState = 2;
                });
                _this.defaultThumb.on("mousedown touchstart", function () {
                    _this.defaultThumb.tint = cuboro.COLOR_GREY;
                    _this.game.renderState = 2;
                });
                _this.defaultThumb.on("mouseup", function () {
                    _this.defaultThumb.tint = cuboro.COLOR_LIGHT_GREY;
                    _this.game.renderState = 2;
                });
                _this.defaultThumb.on("touchend", function () {
                    _this.defaultThumb.tint = cuboro.COLOR_DARK_GREY;
                    _this.game.renderState = 2;
                });
                _this.defaultThumb.on("mouseupoutside touchendoutside", function () {
                    _this.defaultThumb.tint = cuboro.COLOR_DARK_GREY;
                    _this.game.renderState = 2;
                });
                _this.defaultTrack.interactive = true;
                if (_this.isVertical)
                    _this.defaultTrack.c().f(cuboro.COLOR_LIGHT_GREY).dr(7, 0, 3, 300).ef();
                else
                    _this.defaultTrack.c().f(cuboro.COLOR_LIGHT_GREY).dr(0, 7, 300, 3).ef();
                _this.defaultTrack.on("mouseup touchend", function (e) { return _this.onTrack(e); });
                return _this;
            }
            Scrollbar.prototype.onTrack = function (e) {
                var point = e.data.getLocalPosition(this.defaultTrack);
                var pos = this.isVertical ? point.y / this.defaultTrack.height : point.x / this.defaultTrack.width;
                this.updateScrollPos(pos * this._scrollMax);
            };
            Scrollbar.prototype.drawThumb = function () {
                this.defaultThumb.width = this.isVertical ? 18 : this._thumbSize;
                this.defaultThumb.height = this.isVertical ? this._thumbSize : 18;
            };
            Scrollbar.prototype.drawTrack = function () {
                this.defaultTrack.width = this.isVertical ? 3 : this._sizeVisible;
                this.defaultTrack.height = this.isVertical ? this._sizeVisible : 3;
            };
            Scrollbar.prototype.enable = function () {
            };
            Scrollbar.prototype.disable = function () {
            };
            return Scrollbar;
        }(gf.ui.SimpleScrollBar));
        ui.Scrollbar = Scrollbar;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Tab = (function (_super) {
                __extends(Tab, _super);
                function Tab(game) {
                    var _this = _super.call(this, game) || this;
                    _this.interactive = true;
                    _this._minY = 0;
                    _this.contentMask = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                    _this.addChild(_this.contentMask);
                    _this.content = new gf.display.Container(_this.game);
                    _this.content.interactive = true;
                    _this.content.on("touchstart mousedown", _this.onDown, _this);
                    _this.content.mask = _this.contentMask;
                    _this.addChild(_this.content);
                    _this.bounds = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                    _this.content.addChild(_this.bounds);
                    _this.scrollbar = new cuboro.ui.Scrollbar(_this.game);
                    _this.scrollbar.on(gf.UPDATE, _this.onScrollbar, _this);
                    _this.addChild(_this.scrollbar);
                    return _this;
                }
                Tab.prototype.onScrollbar = function () {
                    this.bounds.width =
                        this.bounds.height = 1;
                    this._minY = this.contentMask.y - this.content.height + this.contentMask.height;
                    this.bounds.width = this.contentMask.width;
                    this.bounds.height = this.scrollbar.sizeScroll;
                };
                Tab.prototype.onDown = function (e) {
                    if (this._isDragging)
                        return;
                    if (!this.scrollbar.visible)
                        return;
                    this.on("mouseup mouseupoutside touchend touchendoutside", this.onUp, this);
                    this._dragDistance = 0;
                    this.onMove(e);
                };
                Tab.prototype.onMove = function (e) {
                    if (this._isDragging) {
                        var py = e.data.global.y - this._dragStart;
                        this.content.y = Math.min(this.contentMask.y, Math.max(this._minY, this._startY + py));
                        this.scrollbar.updateToContentPosition();
                    }
                    else {
                        this._isDragging = true;
                        this._dragStart = e.data.global.y;
                        this._startY = this.content.y;
                        this.on("mousemove touchmove", this.onMove, this);
                        this.emit(gf.DRAG_START);
                    }
                };
                Tab.prototype.onUp = function () {
                    if (this._isDragging) {
                        this._isDragging = false;
                        this.removeAllListeners("mousemove mouseup mouseupoutside touchmove touchend touchendoutside");
                    }
                };
                Tab.prototype.updateSize = function (width, height) {
                    this.contentMask.width = width;
                    this.contentMask.height = height;
                    var marginX = -(this.scrollbar.defaultThumb.width + cuboro.PADDING);
                    var marginY = cuboro.PADDING;
                    this.scrollbar.y = this.content.y;
                    this.scrollbar.update(this.content, this.contentMask, marginX, marginY);
                };
                Tab.prototype.show = function () {
                    this.visible = true;
                };
                Tab.prototype.hide = function () {
                    this.visible = false;
                };
                return Tab;
            }(gf.display.Container));
            tabs.Tab = Tab;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Tabs = (function (_super) {
            __extends(Tabs, _super);
            function Tabs(game) {
                var _this = _super.call(this, game) || this;
                _this.interactive = true;
                _this.isSmall = false;
                _this.sameWidth = true;
                _this.spacing = 0;
                _this.maxWidth = _this.game.width;
                _this._tabs = [];
                _this._tabButtons = [];
                _this.tabButtons = new gf.display.Container(_this.game);
                _this.tabButtons.interactive = true;
                _this.addChild(_this.tabButtons);
                _this.tabContent = new gf.display.Container(_this.game);
                _this.tabContent.interactive = true;
                _this.tabContent.y = 40;
                _this.addChild(_this.tabContent);
                return _this;
            }
            Tabs.prototype.onTabButton = function (tabButton) {
                if (tabButton.isSelected)
                    return;
                this.current = tabButton.tab;
            };
            Tabs.prototype.resizeTabButtons = function () {
                var _this = this;
                if (this.sameWidth) {
                    var buttonWidth_1 = (this.maxWidth - ((this._tabButtons.length - 1) * this.spacing)) / this._tabButtons.length;
                    var x_1 = 0;
                    this._tabButtons.forEach(function (value) {
                        value.bg.width = buttonWidth_1;
                        value.x = x_1;
                        x_1 += buttonWidth_1 + _this.spacing;
                    });
                }
                else {
                    var x_2 = 0;
                    this._tabButtons.forEach(function (value) {
                        value.bg.width = value.tfLabel.width + 40;
                        value.x = x_2;
                        x_2 += value.tfLabel.width + 40 + _this.spacing;
                    });
                }
            };
            Tabs.prototype.add = function (tab, btLabel) {
                var _this = this;
                if (btLabel) {
                    var bt_1 = new cuboro.ui.TabButton(this.game, btLabel);
                    bt_1.on(gf.CLICK, function () { return _this.onTabButton(bt_1); });
                    bt_1.tab = tab;
                    if (this.isSmall) {
                        bt_1.bg.height = 27;
                        bt_1.tfLabel.style.fontSize = 13;
                        bt_1.tfLabel.y = 6;
                    }
                    this.tabButtons.addChild(bt_1);
                    this._tabButtons.push(bt_1);
                }
                this.tabContent.addChild(tab);
                this._tabs.push(tab);
                this.resizeTabButtons();
            };
            Tabs.prototype.updateSize = function (width, height) {
                this.size = new PIXI.Point(width, height);
                this._tabs.forEach(function (value) {
                    value.updateSize(width, height);
                });
                this.resizeTabButtons();
            };
            Tabs.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.resizeTabButtons();
            };
            Tabs.prototype.getTabButtonByContent = function (content) {
                var bt = null;
                this._tabButtons.forEach(function (value) {
                    if (value.tab == content) {
                        bt = value;
                        return;
                    }
                });
                return bt;
            };
            Object.defineProperty(Tabs.prototype, "current", {
                get: function () {
                    return this._current;
                },
                set: function (value) {
                    var _this = this;
                    this._current = value;
                    this._tabButtons.forEach(function (bt) {
                        bt.isSelected = (bt.tab == value);
                        if (_this.isSmall) {
                            bt.tfLabel.style.fontSize = 13;
                        }
                        if (bt.isSelected)
                            bt.tab.show();
                        else
                            bt.tab.hide();
                    });
                    this.emit(gf.CHANGE, this._current);
                },
                enumerable: true,
                configurable: true
            });
            return Tabs;
        }(gf.display.Container));
        ui.Tabs = Tabs;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var ReportAbuseButton = (function (_super) {
            __extends(ReportAbuseButton, _super);
            function ReportAbuseButton(game) {
                var _this = _super.call(this, game) || this;
                _this.icon = new gf.display.Sprite(_this.game, "sprites", "icon_report_abuse");
                _this.addChild(_this.icon);
                _this.tfLabel = new gf.display.Text(_this.game, loc("bt_report_abuse"), cuboro.TEXT_STYLE_SMALL.clone());
                _this.tfLabel.x = _this.icon.right + cuboro.PADDING;
                _this.addChild(_this.tfLabel);
                _this.icon.y = (_this.tfLabel.height - _this.icon.height) >> 1;
                return _this;
            }
            ReportAbuseButton.prototype.setState = function (state) {
                this.tfLabel.alpha = 1;
                this.icon.alpha = 1;
                if (!this.isEnabled) {
                    this.tfLabel.alpha = 0.5;
                    this.icon.alpha = 0.5;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.tfLabel.style.fill = cuboro.COLOR_GREY;
                        this.icon.tint = cuboro.COLOR_GREY;
                        break;
                    case gf.OUT:
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.tfLabel.style.fill = cuboro.COLOR_YELLOW;
                        this.icon.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.tfLabel.style.fill = cuboro.COLOR_YELLOW;
                            this.icon.tint = cuboro.COLOR_YELLOW;
                        }
                        else {
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            ReportAbuseButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.setState(this._currentState);
            };
            ReportAbuseButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.setState(this._currentState);
            };
            return ReportAbuseButton;
        }(gf.ui.Button));
        ui.ReportAbuseButton = ReportAbuseButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Comment = (function (_super) {
            __extends(Comment, _super);
            function Comment(game, comment) {
                var _this = _super.call(this, game) || this;
                _this.comment = comment;
                var date = locDate("comment_date", _this.comment.createdWhen);
                var title = loc("comment_title", { username: _this.comment.name, date: date });
                _this.tfTitle = new gf.display.Text(_this.game, title);
                _this.tfTitle.style = cuboro.TEXT_STYLE_SMALL_HEAVY.clone();
                _this.addChild(_this.tfTitle);
                _this.tfText = new gf.display.Text(_this.game, _this.comment.comment);
                _this.tfText.style = cuboro.TEXT_STYLE_SMALL.clone();
                _this.addChild(_this.tfText);
                _this.btReportAbuse = new cuboro.ui.ReportAbuseButton(_this.game);
                _this.btReportAbuse.on(gf.CLICK, _this.onReportAbuse, _this);
                _this.btReportAbuse.isEnabled = mUser.isLoggedIn();
                _this.addChild(_this.btReportAbuse);
                return _this;
            }
            Comment.prototype.onReportAbuse = function () {
                var _this = this;
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                sComment.reportAbuse(this.comment.id, function () {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                    message.text = loc("abuse_reported");
                });
            };
            Object.defineProperty(Comment.prototype, "text", {
                get: function () {
                    return this._text;
                },
                set: function (value) {
                    this._text = value;
                    this.tfText.text = this._text;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Comment.prototype, "title", {
                get: function () {
                    return this._title;
                },
                set: function (value) {
                    this._title = value;
                    this.tfTitle.text = this._title;
                    this.tfText.y = this.tfTitle.bottom;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Comment.prototype, "wordWrapWidth", {
                get: function () {
                    return this.tfText.style.wordWrapWidth;
                },
                set: function (value) {
                    this.tfText.style.breakWords = true;
                    this.tfText.style.wordWrap = true;
                    this.tfText.style.wordWrapWidth = value - this.tfText.x;
                    this.tfTitle.style.wordWrap = true;
                    this.tfTitle.style.wordWrapWidth = value - this.btReportAbuse.width - cuboro.PADDING * 2;
                    this.tfText.y = this.tfTitle.bottom;
                    this.btReportAbuse.x = value - this.btReportAbuse.width - cuboro.PADDING;
                },
                enumerable: true,
                configurable: true
            });
            return Comment;
        }(gf.display.Container));
        ui.Comment = Comment;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Comments = (function (_super) {
                __extends(Comments, _super);
                function Comments(game) {
                    var _this = _super.call(this, game) || this;
                    _this.contentMask.width = 480 - _this.scrollbar.width - 20;
                    _this.contentMask.height = 180;
                    _this.contentMask.x = 20;
                    _this.scrollbar.y = _this.contentMask.y;
                    _this.content.x = _this.contentMask.x;
                    _this.content.y = _this.contentMask.y;
                    _this.btNewComment = new cuboro.ui.TextButton(_this.game, loc("bt_new_comment"), true);
                    _this.btNewComment.on(gf.CLICK, _this.onNewComment, _this);
                    _this.btNewComment.x = 500 - _this.btNewComment.width - 20;
                    _this.btNewComment.y = _this.contentMask.bottom + cuboro.PADDING;
                    _this.btNewComment.isEnabled = mUser.isLoggedIn();
                    _this.addChild(_this.btNewComment);
                    _this.tfNoComments = new gf.display.Text(_this.game, loc("comments_empty"), cuboro.TEXT_STYLE_SMALL.clone());
                    _this.tfNoComments.x = gf.utils.Align.centerX(_this.tfNoComments, 500);
                    _this.tfNoComments.y = gf.utils.Align.centerY(_this.tfNoComments, _this.contentMask.height);
                    _this.tfNoComments.visible = false;
                    _this.addChild(_this.tfNoComments);
                    mUser.on("loggedIn", _this.onLogin, _this);
                    mUser.on("logout", _this.onLogout, _this);
                    console.log(_this);
                    return _this;
                }
                Comments.prototype.onLogin = function () {
                    this.btNewComment.isEnabled = true;
                    this.items.forEach(function (value) {
                        value.btReportAbuse.isEnabled = true;
                    });
                };
                Comments.prototype.onLogout = function () {
                    this.btNewComment.isEnabled = false;
                    this.items.forEach(function (value) {
                        value.btReportAbuse.isEnabled = false;
                    });
                };
                Comments.prototype.addItem = function (value) {
                    var comment = new cuboro.ui.Comment(this.game, value);
                    comment.wordWrapWidth = this.contentMask.width;
                    this.content.addChild(comment);
                    this.items.push(comment);
                };
                Comments.prototype.onNewComment = function () {
                    var _this = this;
                    var comments = this.game.overlays.show(cuboro.overlays.NewComment.NAME);
                    comments.once(gf.TRANSITION_OUT, function () { return _this.update(_this.track); }, this);
                    comments.trackId = this.track.id;
                };
                Comments.prototype.arrange = function () {
                    this.tfNoComments.visible = (this.items.length == 0);
                    this.content.y = this.contentMask.y;
                    var height = 0;
                    this.items.forEach(function (value) {
                        value.y = height;
                        height += value.height + cuboro.PADDING * 2;
                    });
                    this.scrollbar.update(this.content, this.contentMask);
                };
                Comments.prototype.reset = function () {
                    this.content.removeChildren();
                    this.items = [];
                };
                Comments.prototype.updateSize = function (width, height) {
                };
                Comments.prototype.update = function (track) {
                    var _this = this;
                    this.track = track;
                    this.reset();
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sComment.getTrackComment(this.track.id, function (comments) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        comments.forEach(function (value) {
                            _this.addItem(value);
                        });
                        _this.arrange();
                    });
                };
                return Comments;
            }(cuboro.ui.tabs.Tab));
            tabs.Comments = Comments;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var HistoryItem = (function (_super) {
            __extends(HistoryItem, _super);
            function HistoryItem(game, track, type) {
                var _this = _super.call(this, game) || this;
                _this.track = track;
                _this.type = type;
                _this.bg = new gf.display.Slice3(_this.game, 10, 10, "sprites", "bt_text_disabled");
                _this.bg.width = 460 - 18 - cuboro.PADDING;
                _this.addChild(_this.bg);
                var dummy = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                dummy.width = _this.bg.width;
                dummy.height = _this.bg.height;
                _this.addChild(dummy);
                _this.icon = new gf.display.Sprite(_this.game, "sprites", "icon_successor");
                _this.icon.tint = cuboro.COLOR_DARK_GREY;
                _this.icon.y = 1;
                _this.addChild(_this.icon);
                if (_this.type == cuboro.HISTORY.PREDECESSOR)
                    _this.icon.frameName = "icon_predecessor";
                _this.tfTrackName = new gf.display.Text(_this.game, _this.track.name, cuboro.TEXT_STYLE_SMALL.clone());
                _this.tfTrackName.x = _this.icon.right + cuboro.PADDING * 2;
                _this.tfTrackName.y = 6;
                _this.addChild(_this.tfTrackName);
                _this.tfOwner = new gf.display.Text(_this.game, _this.track.owner.name, cuboro.TEXT_STYLE_SMALL.clone());
                _this.tfOwner.x = 200;
                _this.tfOwner.y = _this.tfTrackName.y;
                _this.addChild(_this.tfOwner);
                _this.tfScore = new gf.display.Text(_this.game, _this.track.scoreTotal.toString(), cuboro.TEXT_STYLE_SMALL.clone());
                _this.tfScore.x = _this.bg.width - _this.tfScore.width - cuboro.PADDING * 2;
                _this.tfScore.y = _this.tfOwner.y;
                _this.addChild(_this.tfScore);
                _this.icon.visible = _this.type != cuboro.HISTORY.CURRENT;
                _this.bg.visible = _this.icon.visible;
                _this.tfTrackName.truncate(_this.tfOwner.x - _this.tfTrackName.x - cuboro.PADDING * 2);
                _this.tfOwner.truncate(_this.tfScore.x - _this.tfOwner.x - cuboro.PADDING * 2);
                return _this;
            }
            return HistoryItem;
        }(gf.display.Container));
        ui.HistoryItem = HistoryItem;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var History = (function (_super) {
                __extends(History, _super);
                function History(game) {
                    var _this = _super.call(this, game) || this;
                    _this.iconPredecessor = new gf.display.Sprite(_this.game, "sprites", "icon_predecessor");
                    _this.iconPredecessor.tint = cuboro.COLOR_DARK_GREY;
                    _this.iconPredecessor.x = 20;
                    _this.addChild(_this.iconPredecessor);
                    _this.tfPredecessor = new gf.display.Text(_this.game, loc("track_predecessor"), cuboro.TEXT_STYLE_SMALL.clone());
                    _this.tfPredecessor.x = _this.iconPredecessor.right + cuboro.PADDING;
                    _this.tfPredecessor.y = (_this.iconPredecessor.height - _this.tfPredecessor.height) >> 1;
                    _this.addChild(_this.tfPredecessor);
                    _this.iconSuccessor = new gf.display.Sprite(_this.game, "sprites", "icon_successor");
                    _this.iconSuccessor.tint = cuboro.COLOR_DARK_GREY;
                    _this.iconSuccessor.x = _this.tfPredecessor.right + cuboro.PADDING * 4;
                    _this.addChild(_this.iconSuccessor);
                    _this.tfSuccessor = new gf.display.Text(_this.game, loc("track_successor"), cuboro.TEXT_STYLE_SMALL.clone());
                    _this.tfSuccessor.x = _this.iconSuccessor.right + cuboro.PADDING;
                    _this.tfSuccessor.y = _this.tfPredecessor.y;
                    _this.addChild(_this.tfSuccessor);
                    _this.contentMask.width = 480 - _this.scrollbar.width - 20;
                    _this.contentMask.x = 20;
                    _this.contentMask.y = _this.iconPredecessor.bottom + cuboro.PADDING;
                    _this.contentMask.height = 180 - _this.contentMask.y + 27 + cuboro.PADDING;
                    _this.scrollbar.y = _this.contentMask.y;
                    _this.content.x = _this.contentMask.x;
                    _this.content.y = _this.contentMask.y;
                    return _this;
                }
                History.prototype.arrange = function () {
                    this.content.y = this.contentMask.y;
                    this.items.forEach(function (value, index) {
                        value.y = index * value.height + index * cuboro.PADDING;
                    });
                    this.scrollbar.update(this.content, this.contentMask);
                };
                History.prototype.reset = function () {
                    this.content.removeChildren();
                    this.items = [];
                };
                History.prototype.addItem = function (track, type) {
                    var item = new cuboro.ui.HistoryItem(this.game, track, type);
                    this.content.addChild(item);
                    this.items.push(item);
                };
                History.prototype.updateSize = function (width, height) {
                };
                History.prototype.update = function (track) {
                    var _this = this;
                    this.track = track;
                    this.reset();
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sTrack.getHistory(this.track.id, function (response) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        response.previousTracks.forEach(function (value) {
                            _this.addItem(value, cuboro.HISTORY.PREDECESSOR);
                        });
                        _this.addItem(_this.track, cuboro.HISTORY.CURRENT);
                        response.forwardTracks.forEach(function (value) {
                            _this.addItem(value, cuboro.HISTORY.SUCCESSOR);
                        });
                        _this.arrange();
                    });
                };
                return History;
            }(cuboro.ui.tabs.Tab));
            tabs.History = History;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Scores = (function (_super) {
                __extends(Scores, _super);
                function Scores(game) {
                    var _this = _super.call(this, game) || this;
                    var lineHeight = 18;
                    _this.tfTitleType = new gf.display.Text(_this.game, loc("cube_info_type"), cuboro.TEXT_STYLE_SMALL_HEAVY.clone());
                    _this.tfTitleType.x = 20;
                    _this.content.addChild(_this.tfTitleType);
                    _this.tfTitleCount = new gf.display.Text(_this.game, loc("cube_info_count"), cuboro.TEXT_STYLE_SMALL_HEAVY.clone());
                    _this.content.addChild(_this.tfTitleCount);
                    _this.tfTitleValue = new gf.display.Text(_this.game, loc("cube_info_value"), cuboro.TEXT_STYLE_SMALL_HEAVY.clone());
                    _this.content.addChild(_this.tfTitleValue);
                    _this.tfTitleScore = new gf.display.Text(_this.game, loc("cube_info_score"), cuboro.TEXT_STYLE_SMALL_HEAVY.clone());
                    _this.content.addChild(_this.tfTitleScore);
                    _this.tfCubeTitles = new gf.display.Text(_this.game, loc("cube_info"), cuboro.TEXT_STYLE_SMALL.clone());
                    _this.tfCubeTitles.style.lineHeight = lineHeight;
                    _this.tfCubeTitles.x = 20;
                    _this.tfCubeTitles.y = _this.tfTitleType.bottom + cuboro.PADDING;
                    _this.content.addChild(_this.tfCubeTitles);
                    _this.tfCubeValues = new gf.display.Text(_this.game);
                    _this.tfCubeValues.style = cuboro.TEXT_STYLE_SMALL.clone();
                    _this.tfCubeValues.style.align = gf.RIGHT;
                    _this.tfCubeValues.style.lineHeight = lineHeight;
                    _this.tfCubeValues.y = _this.tfCubeTitles.y;
                    _this.content.addChild(_this.tfCubeValues);
                    _this.tfCubeScores = new gf.display.Text(_this.game, loc("cube_info_scores"), cuboro.TEXT_STYLE_SMALL.clone());
                    _this.tfCubeScores.y = _this.tfCubeTitles.y;
                    _this.tfCubeScores.style.lineHeight = lineHeight;
                    _this.content.addChild(_this.tfCubeScores);
                    _this.tfCubeScoresValues = new gf.display.Text(_this.game);
                    _this.tfCubeScoresValues.style = cuboro.TEXT_STYLE_SMALL.clone();
                    _this.tfCubeScoresValues.style.lineHeight = lineHeight;
                    _this.tfCubeScoresValues.y = _this.tfCubeTitles.y;
                    _this.content.addChild(_this.tfCubeScoresValues);
                    _this.tfTitleTotal = new gf.display.Text(_this.game, loc("cube_info_total"), cuboro.TEXT_STYLE_SMALL_HEAVY.clone());
                    _this.tfTitleTotal.x = _this.tfCubeTitles.x;
                    _this.tfTitleTotal.y = _this.tfCubeTitles.bottom + cuboro.PADDING * 2;
                    _this.content.addChild(_this.tfTitleTotal);
                    _this.tfTitleTotalScore = new gf.display.Text(_this.game);
                    _this.tfTitleTotalScore.style = cuboro.TEXT_STYLE_SMALL_HEAVY.clone();
                    _this.tfTitleTotalScore.y = _this.tfTitleTotal.y;
                    _this.content.addChild(_this.tfTitleTotalScore);
                    _this.tfCubeValues.x = _this.tfTitleCount.x = _this.tfCubeTitles.right + cuboro.PADDING * 2;
                    _this.tfCubeScores.x = _this.tfTitleValue.x = _this.tfTitleCount.right + cuboro.PADDING * 2;
                    _this.tfCubeScoresValues.x = _this.tfTitleScore.x = _this.tfTitleTotalScore.x = _this.tfTitleValue.right + cuboro.PADDING * 4;
                    return _this;
                }
                Scores.prototype.update = function (track) {
                    if (!track.data.evaluation.track[4])
                        track.data.evaluation.track[4] = 0;
                    if (!track.data.evaluation.scoreTrack[4])
                        track.data.evaluation.scoreTrack[4] = 0;
                    this.tfCubeValues.text = track.data.evaluation.cubes + "\n" +
                        track.data.evaluation.track[0] + "\n" +
                        track.data.evaluation.track[1] + "\n" +
                        track.data.evaluation.track[2] + "\n" +
                        track.data.evaluation.track[3] + "\n" +
                        track.data.evaluation.track[4] + "\n" +
                        track.data.evaluation.substructure;
                    this.tfCubeScoresValues.text = "= " + track.data.evaluation.scoreCubes + "\n= " +
                        track.data.evaluation.scoreTrack[0] + "\n= " +
                        track.data.evaluation.scoreTrack[1] + "\n= " +
                        track.data.evaluation.scoreTrack[2] + "\n= " +
                        track.data.evaluation.scoreTrack[3] + "\n= " +
                        track.data.evaluation.scoreTrack[4] + "\n= " +
                        track.data.evaluation.scoreSubstructure;
                    this.tfTitleTotalScore.text = "= " + track.data.evaluation.scoreTotal;
                };
                return Scores;
            }(cuboro.ui.tabs.Tab));
            tabs.Scores = Scores;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var FacebookButton = (function (_super) {
            __extends(FacebookButton, _super);
            function FacebookButton(game) {
                return _super.call(this, game, "fb") || this;
            }
            FacebookButton.prototype.setState = function (state) {
            };
            return FacebookButton;
        }(cuboro.ui.IconButton));
        ui.FacebookButton = FacebookButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Social = (function () {
            function Social() {
            }
            Social.getUrl = function (network, shareUrl, ogUrl, ogDescription, ogTitle, ogImage) {
                if (ogDescription) {
                    if (network == gf.utils.Social.GPLUS)
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogdescription=" : "&ogdescription=") + encodeURIComponent(ogDescription);
                    else
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogdescription=" : "&ogdescription=") + ogDescription;
                }
                if (ogTitle) {
                    if (network == gf.utils.Social.GPLUS)
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogtitle=" : "&ogtitle=") + encodeURIComponent(ogTitle);
                    else
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogtitle=" : "&ogtitle=") + ogTitle;
                }
                if (ogUrl) {
                    if (network == gf.utils.Social.GPLUS)
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogurl=" : "&ogurl=") + encodeURIComponent(ogUrl);
                    else
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogurl=" : "&ogurl=") + ogUrl;
                }
                if (ogImage) {
                    if (network == gf.utils.Social.GPLUS)
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogimage=" : "&ogimage=") + encodeURIComponent(ogImage);
                    else
                        shareUrl += ((shareUrl.indexOf("?") == -1) ? "?ogimage=" : "&ogimage=") + ogImage;
                }
                return shareUrl;
            };
            Social.share = function (network, value) {
                switch (network) {
                    case gf.utils.Social.FACEBOOK:
                        window.open("https://www.facebook.com/sharer/sharer.php?u=" + encodeURIComponent(value), "_blank");
                        break;
                    case gf.utils.Social.GPLUS:
                        window.open("https://plus.google.com/share?url=" + encodeURIComponent(value), "_blank");
                        break;
                    case gf.utils.Social.XING:
                        window.open("https://www.xing.com/spi/shares/new?url=" + encodeURIComponent(value), "_blank");
                        break;
                    case gf.utils.Social.TWITTER:
                        window.open("https://twitter.com/intent/tweet?text=" + encodeURIComponent(value), "_blank");
                        break;
                    case gf.utils.Social.WHATSAPP:
                        top.location.href = "WhatsApp://send?text=" + value;
                        break;
                    case gf.utils.Social.MAIL:
                        top.location.href = "mailto:" + value;
                        break;
                }
            };
            Social.FACEBOOK = "facebook";
            Social.GPLUS = "gplus";
            Social.MAIL = "mail";
            Social.TWITTER = "twitter";
            Social.WHATSAPP = "whatsapp";
            Social.XING = "xing";
            return Social;
        }());
        utils.Social = Social;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Share = (function (_super) {
                __extends(Share, _super);
                function Share(game) {
                    var _this = _super.call(this, game) || this;
                    _this.btMail = new cuboro.ui.IconButton(_this.game, "email", loc("bt_share_email"), false);
                    _this.btMail.on(gf.CLICK, _this.onMail, _this);
                    _this.btMail.x = 20;
                    _this.addChild(_this.btMail);
                    _this.btFacebook = new cuboro.ui.FacebookButton(_this.game);
                    _this.btFacebook.on(gf.CLICK, _this.onFacebook, _this);
                    _this.btFacebook.x = _this.btMail.right + cuboro.PADDING * 2;
                    _this.addChild(_this.btFacebook);
                    return _this;
                }
                Share.prototype.onMail = function () {
                    var _this = this;
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    var url = this.game.client.config.ogUrl + "?tid=" + this.track.id;
                    casClient.getShortUrl(url, function (shortUrl) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        var ogTitle = loc("share_og_title");
                        var ogMessage = loc("share_og_mail", {
                            username: mUser.isLoggedIn() ? mUser.getUser().name : "",
                            shorturl: shortUrl
                        });
                        var mail = "?subject=" + encodeURIComponent(ogTitle) + "&body=" + encodeURIComponent(ogMessage);
                        gf.utils.Social.share(gf.utils.Social.MAIL, mail);
                    });
                };
                Share.prototype.onFacebook = function () {
                    var network = gf.utils.Social.FACEBOOK;
                    var shareUrl = this.game.client.config.shareUrl;
                    var ogUrl = this.game.client.config.ogUrl;
                    var ogDescription = loc("share_og_description");
                    var ogTitle = loc("share_og_title");
                    var ogImage = this.game.client.config.ogUrl + this.track.imageUrl;
                    var url = gf.utils.Social.getUrl(network, shareUrl, ogUrl, ogDescription, ogTitle, ogImage);
                    gf.utils.Social.share(gf.utils.Social.FACEBOOK, url);
                };
                Share.prototype.update = function (track) {
                    this.track = track;
                };
                return Share;
            }(cuboro.ui.tabs.Tab));
            tabs.Share = Share;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TrackPreview = (function (_super) {
            __extends(TrackPreview, _super);
            function TrackPreview(game, url) {
                var _this = _super.call(this, game) || this;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.width = 150;
                _this.bg.height = 150;
                _this.addChild(_this.bg);
                _this.preview = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                _this.preview.width = 150;
                _this.preview.height = 150;
                _this.addChild(_this.preview);
                if (url) {
                    _this.url = url;
                }
                return _this;
            }
            TrackPreview.GenerateTexture = function (playground, size, callback) {
                if (size === void 0) { size = 150; }
                var pos = playground.controls.settings.camera.position.clone();
                playground.camera.position.set(20, 17, 20);
                playground.camera.lookAt(playground.controls.settings.lookAt);
                playground.canvas.renderer.render(playground.scene, playground.camera);
                var content = playground.canvas.renderer.domElement.toDataURL();
                var img = new Image();
                img.src = content;
                img.onload = function () {
                    var c = new PIXI.Container();
                    var t = new PIXI.Texture(new PIXI.BaseTexture(img, PIXI.SCALE_MODES.LINEAR, 2));
                    var s = new PIXI.Sprite(t);
                    s.width = size;
                    s.height = size;
                    c.addChild(s);
                    var rt = playground.game.renderer.generateTexture(c, PIXI.SCALE_MODES.LINEAR, 2);
                    playground.camera.position.set(pos.x, pos.y, pos.z);
                    playground.camera.lookAt(playground.controls.settings.lookAt);
                    if (callback) {
                        callback(rt);
                    }
                };
            };
            TrackPreview.GetBase64 = function (playground, size, callback) {
                if (size === void 0) { size = 150; }
                this.GenerateTexture(playground, size, function (texture) {
                    callback(playground.game.renderer.extract.base64(texture));
                });
            };
            Object.defineProperty(TrackPreview.prototype, "url", {
                get: function () {
                    return this._url;
                },
                set: function (value) {
                    if (!value)
                        return;
                    this._url = value;
                    this.preview.texture = PIXI.Texture.fromImage(value);
                },
                enumerable: true,
                configurable: true
            });
            return TrackPreview;
        }(gf.display.Container));
        ui.TrackPreview = TrackPreview;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TrackInfo = (function (_super) {
            __extends(TrackInfo, _super);
            function TrackInfo(game) {
                var _this = _super.call(this, game) || this;
                _this.previewBg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.previewBg.tint = cuboro.COLOR_GREY;
                _this.previewBg.width = 152;
                _this.previewBg.height = _this.previewBg.width;
                _this.addChild(_this.previewBg);
                _this.preview = new cuboro.ui.TrackPreview(_this.game);
                _this.preview.x = 1;
                _this.preview.y = _this.preview.x;
                _this.addChild(_this.preview);
                var lineHeight = 18;
                _this.tfTitles = new gf.display.Text(_this.game, loc("track_info"), cuboro.TEXT_STYLE_SMALL.clone());
                _this.tfTitles.style.lineHeight = lineHeight;
                _this.tfTitles.x = 150 + cuboro.PADDING * 3;
                _this.tfTitles.y = _this.preview.y + cuboro.PADDING;
                _this.addChild(_this.tfTitles);
                _this.tfValues = new gf.display.Text(_this.game);
                _this.tfValues.style = cuboro.TEXT_STYLE_SMALL.clone();
                _this.tfValues.style.align = gf.RIGHT;
                _this.tfValues.style.lineHeight = lineHeight;
                _this.tfValues.x = _this.tfTitles.right + cuboro.PADDING;
                _this.tfValues.y = _this.tfTitles.y;
                _this.addChild(_this.tfValues);
                return _this;
            }
            TrackInfo.prototype.reset = function () {
                this.tfValues.text = loc("track_info_values", {
                    creator: "-",
                    elementScore: "-",
                    scoreTotal: "-",
                    trackname: "-"
                });
            };
            TrackInfo.prototype.update = function (track) {
                var scoreTotal = "-";
                var scoreElement = "-";
                var creator = "-";
                var date = "-";
                if (track.data.evaluation) {
                    if (track.data.evaluation.scoreTotal) {
                        scoreTotal = track.data.evaluation.scoreTotal.toString();
                    }
                    if (track.data.evaluation.cubes > 0) {
                        var score = track.data.evaluation.scoreTrack.reduce(function (pv, cv) { return pv + cv; }, 0) + track.data.evaluation.scoreSubstructure;
                        var cubes = track.data.evaluation.track.reduce(function (pv, cv) { return pv + cv; }, 0) + track.data.evaluation.substructure;
                        var rounded = (score > 0) ? Math.round((score / cubes) * 10) / 10 : 0;
                        scoreElement = rounded.toFixed(1).replace(".", ",");
                    }
                }
                if (track.owner) {
                    creator = track.owner.name;
                }
                if (track.lastSavedWhen) {
                    date = locDate("track_info_last_saved", track.lastSavedWhen);
                }
                this.tfValues.text = loc("track_info_values", {
                    creator: creator,
                    date: date,
                    scoreElement: scoreElement,
                    scoreTotal: scoreTotal,
                    trackname: track.name
                });
                if (track.imageUrl) {
                    this.preview.url = track.imageUrl;
                }
            };
            return TrackInfo;
        }(gf.display.Container));
        ui.TrackInfo = TrackInfo;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var TrackDetails = (function (_super) {
            __extends(TrackDetails, _super);
            function TrackDetails() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            TrackDetails.prototype.init = function () {
                _super.prototype.init.call(this);
                this.tfTitle.text = loc("tab_track_details");
                this.trackInfo = new cuboro.ui.TrackInfo(this.game);
                this.trackInfo.y = this.tfTitle.bottom + cuboro.PADDING * 2;
                this.addChild(this.trackInfo);
                this.tabScores = new cuboro.ui.tabs.Scores(this.game);
                this.tabHistory = new cuboro.ui.tabs.History(this.game);
                this.tabComments = new cuboro.ui.tabs.Comments(this.game);
                this.tabShare = new cuboro.ui.tabs.Share(this.game);
                this.tabs = new cuboro.ui.Tabs(this.game);
                this.tabs.maxWidth = 500;
                this.tabs.isSmall = true;
                this.tabs.sameWidth = false;
                this.tabs.spacing = cuboro.PADDING;
                this.tabs.add(this.tabScores, loc("bt_track_scores"));
                this.tabs.add(this.tabHistory, loc("bt_track_history"));
                this.tabs.add(this.tabComments, loc("bt_track_comments"));
                this.tabs.add(this.tabShare, loc("bt_track_share"));
                this.tabs.y = this.trackInfo.bottom + cuboro.PADDING * 2;
                this.tabs.current = this.tabScores;
                this.tabs.updateSize(500, 215);
                this.tabs.on(gf.CHANGE, this.onTab, this);
                this.addChild(this.tabs);
                this.btDuplicate = new cuboro.ui.TextButton(this.game, loc("bt_track_duplicate"), false);
                this.btDuplicate.on(gf.CLICK, this.onDuplicate, this);
                this.btDuplicate.y = this.tabs.bottom + cuboro.PADDING * 2;
                this.addChild(this.btDuplicate);
                this.btDelete = new cuboro.ui.TextButton(this.game, loc("bt_track_delete"), false);
                this.btDelete.on(gf.CLICK, this.onDelete, this);
                this.btDelete.y = this.btDuplicate.y;
                this.addChild(this.btDelete);
                this.btUnpublish = new cuboro.ui.TextButton(this.game, loc("bt_track_unpublish"), false);
                this.btUnpublish.on(gf.CLICK, this.onUnpublish, this);
                this.btUnpublish.y = this.btDuplicate.y;
                this.addChild(this.btUnpublish);
                this.btLoad = new cuboro.ui.TextButton(this.game, loc("bt_track_load"), true);
                this.btLoad.on(gf.CLICK, this.onLoad, this);
                this.btLoad.y = this.btDuplicate.y;
                this.addChild(this.btLoad);
                this.bg.width = 500;
                this.bg.height = 480;
            };
            TrackDetails.prototype.onTab = function (tab) {
                switch (tab) {
                    case this.tabComments:
                        this.tabComments.update(this._track);
                        break;
                    case this.tabHistory:
                        this.tabHistory.update(this._track);
                        break;
                    case this.tabScores:
                        break;
                    case this.tabShare:
                        this.tabShare.update(this._track);
                        this.tabShare.show();
                        break;
                }
                if (tab != this.tabShare)
                    this.tabShare.hide();
                this.btDuplicate.visible =
                    this.btDelete.visible =
                        this.btUnpublish.visible =
                            this.btLoad.visible = tab == this.tabScores;
            };
            TrackDetails.prototype.onDuplicate = function () {
                cuboro.core.Loader.loadTrack(this.game, this._track, true);
                this.game.overlays.hide(cuboro.overlays.TrackDetails.NAME);
            };
            TrackDetails.prototype.onUnpublish = function () {
                var _this = this;
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                sTrack.unpublish(this._track.id, function (status) {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    if (status == kr3m.SUCCESS) {
                        _this.update();
                        _this.reloadGallery();
                        var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                        message.text = loc("track_unpublished");
                    }
                    else {
                        var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                        message.text = loc("error_track_unpublish");
                    }
                });
            };
            TrackDetails.prototype.reloadGallery = function () {
                if (this.game.screens.currentName != cuboro.screens.Start.NAME)
                    return;
                var startScreen = this.game.screens.current;
                startScreen.tabGallery.getPage(startScreen.tabGallery.galleryFilters);
            };
            TrackDetails.prototype.onDelete = function () {
                var _this = this;
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                sTrack.delete(this._track.id, function (status) {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    if (status == kr3m.SUCCESS) {
                        _this.game.overlays.hide(cuboro.overlays.TrackDetails.NAME);
                        _this.reloadGallery();
                    }
                    else {
                        var message = _this.game.overlays.show(cuboro.overlays.Message.NAME);
                        message.text = loc("error_delete_track");
                    }
                });
            };
            TrackDetails.prototype.onLoad = function () {
                cuboro.core.Loader.loadTrack(this.game, this._track, false);
                this.game.overlays.hide(cuboro.overlays.TrackDetails.NAME);
            };
            TrackDetails.prototype.onClose = function () {
                this.game.overlays.hide(cuboro.overlays.TrackDetails.NAME);
            };
            TrackDetails.prototype.update = function () {
                var _this = this;
                if (!this.visible)
                    return;
                this.trackInfo.update(this._track);
                this.tabScores.update(this._track);
                this.btUnpublish.isEnabled = false;
                this.btDelete.isEnabled = (mUser.isLoggedIn() && this._track.owner.id == mUser.getUserId());
                if (this.btDelete.isEnabled) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sTrack.isPublished(this._track.id, function (response) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (response) {
                            _this.btDelete.isEnabled = false;
                            _this.btUnpublish.isEnabled = true;
                        }
                    });
                }
                this.trackInfo.tfValues.x = this.trackInfo.tfTitles.right + cuboro.PADDING;
            };
            TrackDetails.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.tabs.current = this.tabScores;
            };
            TrackDetails.prototype.transitionOut = function () {
                _super.prototype.transitionOut.call(this);
                this.tabShare.hide();
            };
            TrackDetails.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.btDuplicate.x =
                    this.trackInfo.x = this.bg.x + 20;
                this.tabs.x = this.bg.x;
                this.btDelete.x = this.btDuplicate.right + cuboro.PADDING;
                this.btUnpublish.x = this.btDelete.right + cuboro.PADDING;
                this.btLoad.x = this.bg.right - this.btLoad.width - 20;
            };
            Object.defineProperty(TrackDetails.prototype, "track", {
                get: function () {
                    return this._track;
                },
                set: function (value) {
                    this._track = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            TrackDetails.NAME = "trackDetails";
            return TrackDetails;
        }(cuboro.overlays.Overlay));
        overlays.TrackDetails = TrackDetails;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var overlays;
    (function (overlays) {
        var TrackDetailsIngame = (function (_super) {
            __extends(TrackDetailsIngame, _super);
            function TrackDetailsIngame() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            TrackDetailsIngame.prototype.init = function () {
                _super.prototype.init.call(this);
                this.btDuplicate.visible = false;
                this.btDelete.visible = false;
                this.btLoad.visible = false;
            };
            TrackDetailsIngame.prototype.onTab = function (tab) {
                switch (tab) {
                    case this.tabComments:
                        this.tabComments.update(mTrack);
                        break;
                    case this.tabHistory:
                        this.tabHistory.update(mTrack);
                        break;
                    case this.tabScores:
                        break;
                    case this.tabShare:
                        this.tabShare.update(mTrack);
                        this.tabShare.show();
                        break;
                }
                if (tab != this.tabShare)
                    this.tabShare.hide();
                this.btUnpublish.visible = tab == this.tabScores;
            };
            TrackDetailsIngame.prototype.onClose = function () {
                this.game.overlays.hide(cuboro.overlays.TrackDetailsIngame.NAME);
            };
            TrackDetailsIngame.prototype.update = function () {
                var _this = this;
                this._track = mTrack;
                this.trackInfo.update(mTrack);
                this.tabScores.update(mTrack);
                this.btUnpublish.isEnabled = false;
                if (mUser.isLoggedIn() && mTrack.owner.id == mUser.getUserId()) {
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    sTrack.isPublished(mTrack.id, function (response) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (response) {
                            _this.btUnpublish.isEnabled = true;
                        }
                    });
                }
                this.trackInfo.tfValues.x = this.trackInfo.tfTitles.right + cuboro.PADDING;
                this.onTab(this.tabScores);
            };
            TrackDetailsIngame.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.btUnpublish.x = this.bg.x + 20;
            };
            TrackDetailsIngame.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.update();
                this.tabs.getTabButtonByContent(this.tabComments).isEnabled =
                    this.tabs.getTabButtonByContent(this.tabHistory).isEnabled =
                        this.tabs.getTabButtonByContent(this.tabShare).isEnabled = !!mTrack.id;
            };
            TrackDetailsIngame.NAME = "trackDetailsIngame";
            return TrackDetailsIngame;
        }(cuboro.overlays.TrackDetails));
        overlays.TrackDetailsIngame = TrackDetailsIngame;
    })(overlays = cuboro.overlays || (cuboro.overlays = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Interaction = (function (_super) {
            __extends(Interaction, _super);
            function Interaction(game) {
                var _this = _super.call(this, game) || this;
                _this.hitArea = new PIXI.Rectangle(0, 0, _this.game.width, _this.game.height);
                _this.interactive = true;
                _this.on("mousemove", function (e) {
                    _this.emit("onMouseMove", e.data.originalEvent);
                });
                _this.on("mousedown rightdown", function (e) {
                    _this.emit("onMouseDown", e.data.originalEvent);
                });
                _this.on("mouseup mouseupoutside rightup rightupoutside", function (e) {
                    _this.emit("onMouseUp", e.data.originalEvent);
                });
                _this.on("mouseout", function (e) {
                    _this.emit("onMouseOut", e.data.originalEvent);
                });
                _this.on("click tap", function (e) {
                    _this.emit("onClick", e.data.originalEvent);
                });
                _this.on("touchstart", function (e) {
                    _this.emit("onTouchStart", e.data.originalEvent);
                });
                _this.on("touchend touchendoutside", function (e) {
                    _this.emit("onTouchEnd", e.data.originalEvent);
                });
                _this.on("touchmove", function (e) {
                    _this.emit("onTouchMove", e.data.originalEvent);
                });
                document.addEventListener("contextmenu", function (e) {
                    e.preventDefault();
                }, false);
                document.addEventListener("mousewheel", function (e) {
                    e.preventDefault();
                    _this.emit("onMouseWheel", e);
                }, false);
                document.addEventListener("DOMMouseScroll", function (e) {
                    e.preventDefault();
                    _this.emit("onMouseWheel", e);
                }, false);
                return _this;
            }
            Interaction.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.hitArea = new PIXI.Rectangle(0, 0, this.game.width, this.game.height);
            };
            return Interaction;
        }(gf.display.Sprite));
        core.Interaction = Interaction;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    gf.RENDER_AUTO = 0;
    gf.RENDER_CANVAS = 1;
    gf.RENDER_WEBGL = 2;
    gf.LEFT = "left";
    gf.CENTER = "center";
    gf.RIGHT = "right";
    gf.TOP = "top";
    gf.BOTTOM = "bottom";
    gf.JUSTIFY = "justify";
    gf.NONE = "none";
    gf.CHANGE = "change";
    gf.COMPLETE = "complete";
    gf.HORIZONTAL = "horizontal";
    gf.VERTICAL = "vertical";
    gf.OVER = "over";
    gf.OUT = "out";
    gf.DOWN = "down";
    gf.UP = "up";
    gf.SELECTED = "selected";
    gf.HIGHLIGHT = "highlight";
    gf.ACCEPTED = "accepted";
    gf.PENDING = "pending";
    gf.SUCCESS = "success";
    gf.RENDER_TYPE_DEFAULT = "default";
    gf.RENDER_TYPE_ON_CHANGE = "onChange";
    gf.REQUEST_EPISODE = "requestEpisode";
    gf.REQUEST_LIVES = "requestLives";
    gf.SOUND_FX = "fx";
    gf.SOUND_MUSIC = "music";
    gf.BLUR = "gameBlur";
    gf.CLICK = "clickOrTap";
    gf.DATA = "storageData";
    gf.DISABLE = "disable";
    gf.DRAG_CHANGE = "dragChange";
    gf.DRAG_START = "dragStart";
    gf.DRAG_STOP = "dragStop";
    gf.ENABLE = "enable";
    gf.FOCUS = "gameFocus";
    gf.INITIALIZED = "initialized";
    gf.LANDSCAPE = "landscape";
    gf.LOAD_COMPLETE = "loadComplete";
    gf.LOAD_ERROR = "loadError";
    gf.LOAD_PROGRESS = "loadProgress";
    gf.LOGIN = "login";
    gf.LOGOUT = "logout";
    gf.MUSIC_LOADED = "musicLoaded";
    gf.PORTRAIT = "portrait";
    gf.RESIZE = "resize";
    gf.RUNNING = "running";
    gf.SCREEN = "screen";
    gf.TIMER = "timer";
    gf.TIMER_COMPLETE = "timerComplete";
    gf.TRANSITION_IN = "transitionIn";
    gf.TRANSITION_IN_COMPLETE = "transitionInComplete";
    gf.TRANSITION_OUT = "transitionOut";
    gf.TRANSITION_OUT_COMPLETE = "transitionOutComplete";
    gf.UPDATE = "update";
    gf.VENDORS = ["ms", "moz", "webkit", "o", ""];
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Parser = (function () {
            function Parser() {
            }
            Parser.Level = function (data) {
                return null;
            };
            Parser.BitmapFont = function (xmlData, key) {
                var data = {};
                var info = xmlData.getElementsByTagName("info")[0];
                var common = xmlData.getElementsByTagName("common")[0];
                data.font = info.getAttribute("face");
                data.size = parseInt(info.getAttribute("size"), 10);
                data.lineHeight = parseInt(common.getAttribute("lineHeight"), 10);
                data.chars = {};
                var letters = xmlData.getElementsByTagName("char");
                var i;
                for (i = 0; i < letters.length; i++) {
                    var charCode = parseInt(letters[i].getAttribute("id"), 10);
                    var textureRect = new PIXI.Rectangle(parseInt(letters[i].getAttribute("x"), 10), parseInt(letters[i].getAttribute("y"), 10), parseInt(letters[i].getAttribute("width"), 10), parseInt(letters[i].getAttribute("height"), 10));
                    data.chars[charCode] =
                        {
                            xOffset: parseInt(letters[i].getAttribute("xoffset"), 10),
                            yOffset: parseInt(letters[i].getAttribute("yoffset"), 10),
                            xAdvance: parseInt(letters[i].getAttribute("xadvance"), 10),
                            kerning: {},
                            texture: PIXI.utils.TextureCache[key] = new PIXI.Texture(PIXI.utils.BaseTextureCache[key], textureRect)
                        };
                }
                var kernings = xmlData.getElementsByTagName("kerning");
                for (i = 0; i < kernings.length; i++) {
                    var first = parseInt(kernings[i].getAttribute("first"), 10);
                    var second = parseInt(kernings[i].getAttribute("second"), 10);
                    data.chars[second].kerning[first] = parseInt(kernings[i].getAttribute("amount"), 10);
                }
                return data;
            };
            Parser.XML = function (data) {
                var xml;
                try {
                    if (window["DOMParser"]) {
                        var domparser = new DOMParser();
                        xml = domparser.parseFromString(data, "text/xml");
                    }
                    else {
                        xml = new ActiveXObject("Microsoft.XMLDOM");
                        xml.async = false;
                        xml.loadXML(data);
                    }
                }
                catch (e) {
                    xml = null;
                }
                if (!xml || !xml.documentElement || xml.getElementsByTagName("parsererror").length) {
                    return null;
                }
                else {
                    return xml;
                }
            };
            Parser.JSONDataHash = function (game, json) {
                if (!json.frames) {
                    logWarning("gf.utils.Parser.JSONDataHash: Invalid Texture Atlas JSON given, missing \"frames\" object");
                    return;
                }
                var data = new gf.utils.FrameData();
                var resolution = game.client.config.assetsResolution;
                var frames = json.frames;
                var uid;
                var i = 0;
                for (var key in frames) {
                    uid = PIXI.utils.uid();
                    data.addFrame(new gf.utils.Frame(i, frames[key], key, uid, resolution));
                    i++;
                }
                return data;
            };
            return Parser;
        }());
        utils.Parser = Parser;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Cache = (function () {
            function Cache(game) {
                this.game = game;
                this._images = {};
                this._textures = {};
                this._sounds = {};
                this._videos = {};
                this._json = {};
                this._svg = {};
                this._xml = {};
                this._bitmapFont = {};
                this._renderTextures = {};
                this.addDefaultImage();
            }
            Cache.prototype.addDefaultImage = function () {
                var img = new Image();
                img.src = "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7";
                this._images["__default"] = { url: null, data: img };
                this._images["__default"].frame = new gf.utils.Frame(0, {
                    frame: { x: 0, y: 0, w: 1, h: 1 },
                    sourceSize: { w: 1, h: 1 }
                }, "__default", PIXI.utils.uid(), 1);
                this._images["__default"].frameData = new gf.utils.FrameData();
                this._images["__default"].frameData.addFrame(this._images["__default"].frame);
                PIXI.utils.BaseTextureCache["__default"] = new PIXI.BaseTexture(img, PIXI.SCALE_MODES.LINEAR);
                PIXI.utils.TextureCache["__default"] = new PIXI.Texture(PIXI.utils.BaseTextureCache["__default"]);
                this._textures["__default"] = PIXI.utils.TextureCache["__default"];
            };
            Cache.prototype.addTextureAtlas = function (key, url, data, atlasData) {
                this._images[key] = { url: url, data: data };
                PIXI.utils.BaseTextureCache[key] = new PIXI.BaseTexture(data, PIXI.SCALE_MODES.LINEAR, this.game.client.config.assetsResolution);
                PIXI.utils.TextureCache[key] = new PIXI.Texture(PIXI.utils.BaseTextureCache[key]);
                this._images[key].frameData = gf.utils.Parser.JSONDataHash(this.game, atlasData);
            };
            Cache.prototype.addFrameData = function (key, data) {
                if (!this._images[key])
                    return;
                this._images[key].frameData = gf.utils.Parser.JSONDataHash(this.game, data);
            };
            Cache.prototype.addBitmapFont = function (key, url, data, xmlData) {
                this._images[key] = { url: url, data: data };
                PIXI.utils.BaseTextureCache[key] = new PIXI.BaseTexture(data, PIXI.SCALE_MODES.LINEAR, this.game.client.config.assetsResolution);
                PIXI.utils.TextureCache[key] = new PIXI.Texture(PIXI.utils.BaseTextureCache[key]);
                PIXI.extras.BitmapText.fonts[key] = gf.utils.Parser.BitmapFont(xmlData, key);
                this._bitmapFont[key] = PIXI.extras.BitmapText.fonts[key];
            };
            Cache.prototype.addTexture = function (key, texture) {
                this._textures[key] = texture;
            };
            Cache.prototype.addRenderTexture = function (key, texture) {
                this._renderTextures[key] = texture;
            };
            Cache.prototype.addJSON = function (key, url, data) {
                this._json[key] = { url: url, data: data };
            };
            Cache.prototype.addXML = function (key, url, data) {
                this._xml[key] = { url: url, data: data };
            };
            Cache.prototype.addSVG = function (key, url, data) {
                this._svg[key] = { url: url, data: data };
            };
            Cache.prototype.addImage = function (key, url, data) {
                this._images[key] = { url: url, data: data };
                this._images[key].frame = new gf.utils.Frame(0, {
                    frame: { x: 0, y: 0, w: data.width, h: data.height },
                    sourceSize: { w: data.width, h: data.height }
                }, key, PIXI.utils.uid(), this.game.client.config.assetsResolution);
                this._images[key].frameData = new gf.utils.FrameData();
                this._images[key].frameData.addFrame(this._images[key].frame);
                PIXI.utils.BaseTextureCache[key] = new PIXI.BaseTexture(data, PIXI.SCALE_MODES.LINEAR, this.game.client.config.assetsResolution);
                PIXI.utils.TextureCache[key] = new PIXI.Texture(PIXI.utils.BaseTextureCache[key]);
            };
            Cache.prototype.addSound = function (key, url, data, json) {
                this._sounds[key] =
                    {
                        url: url,
                        data: data,
                        json: json
                    };
            };
            Cache.prototype.addVideo = function (key, url) {
                this._videos[key] = url;
            };
            Cache.prototype.getSound = function (key) {
                if (this._sounds[key]) {
                    return this._sounds[key];
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.cache.getSound: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getVideo = function (key) {
                if (this._videos[key]) {
                    return this._videos[key];
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.cache.getVideo: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getRenderTexture = function (key) {
                if (this._renderTextures[key]) {
                    return this._renderTextures[key];
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getRenderTexture: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getImage = function (key) {
                if (this._images[key]) {
                    return this._images[key].data;
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getImage: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getImageUrl = function (key) {
                if (this._images[key]) {
                    return this._images[key].url;
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getImageUrl: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getSVG = function (key) {
                if (this._svg[key]) {
                    return this._svg[key];
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getSVG: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getFrameData = function (key) {
                if (this._images[key]) {
                    return this._images[key].frameData;
                }
                return null;
            };
            Cache.prototype.updateFrameData = function (key, frameData) {
                if (this._images[key]) {
                    this._images[key].frameData = frameData;
                }
            };
            Cache.prototype.getFrameByIndex = function (key, frame) {
                if (this._images[key]) {
                    return this._images[key].frameData.getFrame(frame);
                }
                return null;
            };
            Cache.prototype.getFrameByName = function (key, frame) {
                if (this._images[key]) {
                    return this._images[key].frameData.getFrameByName(frame);
                }
                return null;
            };
            Cache.prototype.getFrame = function (key) {
                if (this._images[key]) {
                    return this._images[key].frame;
                }
                return null;
            };
            Cache.prototype.getTextureByFrameName = function (key, frame) {
                if (this._images[key] && this._images[key][frame]) {
                    var rect = this.getFrameData(key).getFrameByName(frame).frame;
                    return new PIXI.Texture(PIXI.utils.TextureCache[key], rect, rect.clone());
                }
                return null;
            };
            Cache.prototype.getTextureFrame = function (key) {
                if (this._textures[key]) {
                    return this._textures[key].frame;
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getTextureFrame: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getTexture = function (key) {
                if (this._textures[key]) {
                    return this._textures[key];
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getTexture: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getFrameCount = function (key) {
                if (this._images[key]) {
                    return this._images[key].frameData.total;
                }
                return 0;
            };
            Cache.prototype.checkJSON = function (key) {
                return (this._json[key]) ? true : false;
            };
            Cache.prototype.getJSON = function (key) {
                if (this._json[key]) {
                    return this._json[key].data;
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getJSON: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            Cache.prototype.getXML = function (key) {
                if (this._xml[key]) {
                    return this._xml[key].data;
                }
                else {
                    if (this.game.client.config.debug)
                        logWarning("gf.core.Cache.getXML: Invalid key: \"" + key + "\"");
                    return null;
                }
            };
            return Cache;
        }());
        core.Cache = Cache;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var Client = (function () {
        function Client() {
        }
        return Client;
    }());
    gf.Client = Client;
})(gf || (gf = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var Draggable = (function (_super) {
            __extends(Draggable, _super);
            function Draggable(game) {
                var _this = _super.call(this, game) || this;
                _this.canDragX = true;
                _this.canDragY = true;
                _this.interactive = true;
                _this._dragDistance = new PIXI.Point();
                _this._minX = _this._minY = -Number.MAX_VALUE;
                _this._maxX = _this._maxY = Number.MAX_VALUE;
                _this._startPosition = new PIXI.Point();
                _this._velocity = new PIXI.Point();
                _this.isDraggable = true;
                _this.smoothScrollEnabled = true;
                _this._isDragging = false;
                _this.on("touchstart mousedown", function (e) {
                    _this.onDown(e);
                });
                return _this;
            }
            Draggable.prototype.onDown = function (e) {
                var _this = this;
                if (!this._isDraggable)
                    return;
                if (this._isDragging)
                    return;
                this.on("mouseup mouseupoutside touchend touchendoutside", function (e) {
                    _this.onUp(e);
                });
                if (this.smoothScroll) {
                    this.smoothScroll.kill();
                }
                this._dragDistance.set(0, 0);
                this.onDragStart(e.data);
            };
            Draggable.prototype.onMove = function (e) {
                if (this._isDragging) {
                    this.onDragMove(e.data);
                }
                else {
                    this.onDragStart(e.data);
                }
            };
            Draggable.prototype.onUp = function (e) {
                if (this._isDragging) {
                    this.onDragStop(e.data);
                    this.removeAllListeners("mousemove mouseup mouseupoutside touchmove touchend touchendoutside");
                }
            };
            Draggable.prototype.onDragStart = function (data) {
                var _this = this;
                this._isDragging = true;
                this._dragStart = data.global.clone();
                this._startPosition.set(this.x, this.y);
                this.on("mousemove touchmove", function (e) {
                    _this.onMove(e);
                });
                this.emit(gf.DRAG_START);
            };
            Draggable.prototype.onDragMove = function (data) {
                if (this._isDragging) {
                    var prevX = this.x;
                    var prevY = this.y;
                    this.setPosition(data.global.clone());
                    this.emit(gf.DRAG_CHANGE, this.position.x, this.position.y);
                    this._velocity.set(this.x - prevX, this.y - prevY);
                }
            };
            Draggable.prototype.onDragStop = function (data) {
                var _this = this;
                this._isDragging = false;
                if (this.smoothScrollEnabled) {
                    this.smoothScroll = TweenMax.to(this._velocity, gf.utils.Maths.distance(this._velocity.x, this._velocity.y, 0, 0), {
                        x: 0,
                        y: 0,
                        ease: Linear.easeOut,
                        onUpdate: function () {
                            if (_this.canDragX) {
                                _this.x = Math.min(_this._maxX, Math.max(_this._minX, _this._velocity.x + _this.x));
                            }
                            if (_this.canDragY) {
                                _this.y = Math.min(_this._maxY, Math.max(_this._minY, _this._velocity.y + _this.y));
                            }
                            _this.emit(gf.DRAG_CHANGE, _this.x, _this.y);
                        },
                        onComplete: function () {
                            _this.emit(gf.DRAG_STOP);
                        },
                        useFrames: true
                    });
                }
                else {
                    this.x = Math.min(this._maxX, Math.max(this._minX, this.x));
                    this.y = Math.min(this._maxY, Math.max(this._minY, this.y));
                    this.emit(gf.DRAG_CHANGE, this.x, this.y);
                    this.emit(gf.DRAG_STOP);
                }
            };
            Draggable.prototype.setPosition = function (position) {
                if (this.canDragX && this._minX < this._maxX) {
                    var px = position.x - this._dragStart.x;
                    this._dragDistance.x = px;
                    this.x = Math.min(this._maxX, Math.max(this._minX, this._startPosition.x + px));
                }
                if (this.canDragY && this._minY < this._maxY) {
                    var py = position.y - this._dragStart.y;
                    this._dragDistance.y = py;
                    this.y = Math.min(this._maxY, Math.max(this._minY, this._startPosition.y + py));
                }
            };
            Draggable.prototype.move = function (x, y) {
                if (x === void 0) { x = 0; }
                if (y === void 0) { y = 0; }
                this.x = Math.min(this._maxX, Math.max(this._minX, this.x + x));
                this.y = Math.min(this._maxY, Math.max(this._minY, this.y + y));
                this.emit(gf.DRAG_CHANGE, this.position.x, this.position.y);
            };
            Draggable.prototype.forceStopDrag = function () {
                if (this._isDragging) {
                    this.onDragStop(null);
                    this.removeAllListeners("mousemove touchmove");
                }
            };
            Object.defineProperty(Draggable.prototype, "dragDistance", {
                get: function () {
                    return this._dragDistance;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Draggable.prototype, "maxX", {
                get: function () {
                    return this._maxX;
                },
                set: function (value) {
                    this._maxX = value;
                    this.x = Math.min(this._maxX, Math.max(this._minX, this.x));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Draggable.prototype, "maxY", {
                get: function () {
                    return this._maxY;
                },
                set: function (value) {
                    this._maxY = value;
                    this.y = Math.min(this._maxY, Math.max(this._minY, this._velocity.y + this.y));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Draggable.prototype, "minX", {
                get: function () {
                    return this._minX;
                },
                set: function (value) {
                    this._minX = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Draggable.prototype, "minY", {
                get: function () {
                    return this._minY;
                },
                set: function (value) {
                    this._minY = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Draggable.prototype, "isDraggable", {
                get: function () {
                    return this._isDraggable;
                },
                set: function (value) {
                    this._isDraggable = value;
                    this.interactive = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Draggable.prototype, "isDragging", {
                get: function () {
                    return this._isDragging;
                },
                enumerable: true,
                configurable: true
            });
            return Draggable;
        }(gf.display.Container));
        display.Draggable = Draggable;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var overlays;
    (function (overlays) {
        var Episodes = (function (_super) {
            __extends(Episodes, _super);
            function Episodes() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Episodes.prototype.init = function () {
            };
            Episodes.prototype.addBtInvite = function () {
                if (this.btInvite)
                    this.btInvite.on(gf.CLICK, this.onInvite, this);
            };
            Episodes.prototype.addBtBack = function () {
                if (this.btBack)
                    this.btBack.on(gf.CLICK, this.onBack, this);
            };
            Episodes.prototype.onBack = function () {
                track("Episodes-Back");
                this.game.overlays.hide(this.name);
            };
            Episodes.prototype.onCounter = function () {
            };
            Episodes.prototype.onInvite = function () {
                var _this = this;
                track({ eventAction: "Episodes-Invite", eventLabel: "CAS" });
                var episode = this.game.episodes.next;
                if (!episode)
                    return;
                if (this.game.user.isLoggedIn) {
                    this.game.overlays.show("loader");
                    var options = new cas.vo.RequestOptions();
                    options.receiverHeadline = loc("episodes_receiver_headline", { episode: episode.id });
                    options.receiverMessage = loc("episodes_receiver_message", {
                        episode: episode.id,
                        name: this.game.user.name
                    });
                    options.senderMessage = loc("episodes_sender_message", {
                        message: options.receiverMessage,
                        episode: episode.id
                    });
                    options.acceptedMessage = loc("episodes_accepted_message", { episode: episode.id });
                    options.imageUrl = this.game.client.config.ogUrl + "/img/cas_episode.png";
                    options.customData =
                        {
                            type: gf.REQUEST_EPISODE,
                            episode: episode.id,
                            user: {
                                id: this.game.user.id,
                                imageUrl: this.game.user.imageUrl,
                                name: this.game.user.name
                            }
                        };
                    casClient.ui.showRequestDialog(options, function () { return _this.game.overlays.hide("loader"); });
                }
                else {
                    this.game.user.login(function () {
                        if (_this.game.user.isLoggedIn)
                            _this.onInvite();
                    });
                }
            };
            Episodes.prototype.onUser = function (user, index) {
            };
            Episodes.prototype.update = function (episode) {
                var _this = this;
                this.game.episodes.startActivationCountdown(episode);
                var users = this.game.episodes.getActivationsByEpisode(episode);
                if (users && users.length > 0) {
                    users.forEach(function (user, index) { return _this.onUser(user, index); });
                }
            };
            Episodes.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.game.episodes.on(gf.model.COOLDOWN_CHANGE, this.onCounter, this);
                this.game.episodes.on(gf.model.COOLDOWN_COMPLETE, this.onCounter, this);
                this.onCounter();
            };
            Episodes.prototype.transitionOutComplete = function () {
                _super.prototype.transitionOutComplete.call(this);
                this.game.episodes.off(gf.model.COOLDOWN_CHANGE, this.onCounter, this);
                this.game.episodes.off(gf.model.COOLDOWN_COMPLETE, this.onCounter, this);
            };
            Episodes.NAME = "episodes";
            return Episodes;
        }(gf.overlays.Overlay));
        overlays.Episodes = Episodes;
    })(overlays = gf.overlays || (gf.overlays = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var TileVO = (function () {
            function TileVO() {
                this.level = 0;
                this.map = 0;
            }
            return TileVO;
        }());
        vo.TileVO = TileVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var ui;
    (function (ui) {
        var trail;
        (function (trail) {
            trail.LEVEL_SELECT = "levelSelect";
            var Trail = (function (_super) {
                __extends(Trail, _super);
                function Trail(game) {
                    var _this = _super.call(this, game) || this;
                    _this.interactive = true;
                    _this.lastLevel = -1;
                    _this.init();
                    return _this;
                }
                Trail.prototype.init = function () {
                    this.addTrailContainer();
                    this.build();
                    this.game.storage.on(gf.DATA, this.onStorageData, this);
                };
                Trail.prototype.onStorageData = function () {
                    this.tiles.forEach(function (value) { return value.update(); });
                };
                Trail.prototype.addTrailContainer = function () {
                    this.container = new gf.display.Draggable(this.game);
                    this.container.canDragX = false;
                    this.addChild(this.container);
                };
                Trail.prototype.getEpisodeByLevel = function (level) {
                    var episode = 1;
                    this.game.levels.data.episodes.forEach(function (value) {
                        if (value.levels.indexOf(level) != -1) {
                            episode = value.id;
                            return true;
                        }
                    });
                    return episode;
                };
                Trail.prototype.getPosition = function () {
                    if (this.positionIndex == this.game.levels.data.positions.length) {
                        this.positionIndex = 0;
                        this.mapIndex++;
                    }
                    var position = this.game.levels.data.positions[this.positionIndex];
                    this.positionIndex++;
                    return new PIXI.Point(position[0] / this.game.client.config.assetsResolution, position[1] / this.game.client.config.assetsResolution);
                };
                Trail.prototype.addTile = function (level, episode) {
                    var tileVO = new gf.vo.TileVO();
                    tileVO.level = level;
                    tileVO.episode = episode;
                    var position = this.getPosition();
                    tileVO.x = position.x;
                    tileVO.y = position.y;
                    tileVO.map = this.mapIndex;
                    var tile = new this.game.client.config.TrailTileClass(this.game, tileVO);
                    tile.onLevelSelect.add(this.selectLevel, this);
                    this.container.addChild(tile);
                    this.tiles.push(tile);
                };
                Trail.prototype.build = function () {
                    this.mapIndex = 1;
                    this.positionIndex = 0;
                    this.tiles = [];
                    var episode;
                    var lastEpisode = 1;
                    for (var level = 0; level <= this.game.levels.levelCount - 1; ++level) {
                        episode = this.getEpisodeByLevel(level);
                        if (episode != lastEpisode) {
                            this.addTile(-1, episode);
                            lastEpisode = episode;
                        }
                        this.addTile(level, episode);
                    }
                };
                Trail.prototype.selectLevel = function (tileVO) {
                    var _this = this;
                    if (Math.abs(this.container.dragDistance.y) > 10)
                        return;
                    if (tileVO.level == -1 || !this.game.episodes.isEpisodeUnlocked(tileVO.episode)) {
                        var episodes = this.game.overlays.show("episodes");
                        episodes.update(tileVO.episode);
                    }
                    else {
                        this.game.levels.loadLevel(tileVO.level, function () {
                            _this.game.levels.currentLevel = _this.game.levels.getLevelVO(tileVO.level);
                            _this.emit(gf.ui.trail.LEVEL_SELECT);
                        });
                    }
                };
                Trail.prototype.update = function () {
                    var _this = this;
                    this.tiles.forEach(function (tile) {
                        tile.update();
                        if (tile.tileVO.level == _this.game.user.progress.getProgress().level && tile.tileVO.level > _this.lastLevel) {
                            _this.moveToTile(tile);
                            _this.lastLevel = tile.tileVO.level;
                        }
                    });
                };
                Trail.prototype.move = function (value) {
                    this.container.move(0, value);
                };
                Trail.prototype.moveToTile = function (tile) {
                    var ty = -tile.y * this.container.scale.x + (this.game.height >> 1);
                    TweenMax.to(this.container, 0.5, {
                        y: Math.min(this.container.maxY, Math.max(this.container.minY, ty)),
                        ease: Quad.easeInOut
                    });
                };
                Trail.prototype.onResize = function () {
                    this.container.minY = this.game.height;
                    this.container.maxY = this.game.height + (this.container.height - this.game.height);
                    this.container.y = Math.min(this.container.maxY, Math.max(this.container.minY, this.container.y));
                    _super.prototype.onResize.call(this);
                };
                return Trail;
            }(gf.display.Container));
            trail.Trail = Trail;
        })(trail = ui.trail || (ui.trail = {}));
    })(ui = gf.ui || (gf.ui = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Config = (function (_super) {
            __extends(Config, _super);
            function Config() {
                var _this = _super.call(this) || this;
                _this.FooterClass = null;
                _this.HeaderClass = null;
                _this.TrailClass = gf.ui.trail.Trail;
                _this.appName = "";
                _this.assetsResolution = 2;
                _this.cacheBuster = "";
                _this.canvasDomId = "";
                _this.consoleExists = !(typeof console === "undefined" || typeof log === "undefined" || typeof log.apply === "undefined");
                _this.custom = {};
                _this.customerUrl = "";
                _this.debug = false;
                _this.forceCanvas = false;
                _this.forceWebGL = false;
                _this.hasEndless = true;
                _this.hasFooter = true;
                _this.hasHeader = true;
                _this.hasInbox = true;
                _this.hasLives = true;
                _this.hasLogin = true;
                _this.hasRaffle = false;
                _this.highscoreLimit = 7;
                _this.isIframe = false;
                _this.isMobile = PIXI.utils.isMobile.tablet || PIXI.utils.isMobile.phone;
                _this.language = "de";
                _this.musicUrl = "";
                _this.muteFxDefault = false;
                _this.muteMusicDefault = false;
                _this.ogUrl = "";
                _this.queries = {};
                _this.renderType = gf.RENDER_TYPE_DEFAULT;
                _this.resolution = gf.utils.Resolution.getResolution();
                _this.roundPixels = false;
                _this.shareUrl = "";
                _this.targetWindow = window;
                _this.transparent = true;
                _this.unlockedLevels = 1;
                _this.useCAS = true;
                _this.version = "";
                var queryValues = kr3m.util.Browser.getQueryValues();
                for (var name_1 in queryValues) {
                    if (typeof _this[name_1] != "undefined")
                        _this[name_1] = queryValues[name_1];
                }
                return _this;
            }
            Config.prototype.addAssets = function (main) {
            };
            Config.prototype.onRun = function (game) {
            };
            return Config;
        }(PIXI.utils.EventEmitter));
        core.Config = Config;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Overlays = (function (_super) {
            __extends(Overlays, _super);
            function Overlays(game) {
                var _this = _super.call(this, game) || this;
                _this.name = "overlays";
                _this._overlays = {};
                _this.interactive = true;
                return _this;
            }
            Overlays.prototype.add = function (name, overlay) {
                this._overlays[name] = overlay;
                overlay.name = name;
                this.addChild(overlay);
            };
            Overlays.prototype.init = function () {
                this.game.stage.addChild(this);
                if (!this.game.client.config.overlays)
                    return;
                var overlay;
                for (var i = 0; i < this.game.client.config.overlays.length; ++i) {
                    overlay = this.game.client.config.overlays[i];
                    if (overlay.name && overlay.class)
                        this.add(overlay.name, new overlay.class(this.game));
                    else
                        this.add(overlay.NAME, new overlay(this.game));
                }
            };
            Overlays.prototype.show = function (name) {
                var overlay = this.getOverlay(name);
                if (!overlay) {
                    logWarning("Error: gf.core.Overlays.show(). No overlay found with name: " + name);
                    return;
                }
                this.swapChildren(this.getChildAt(this.children.length - 1), overlay);
                overlay.transitionIn();
                return overlay;
            };
            Overlays.prototype.hide = function (name) {
                var overlay = this.getOverlay(name);
                if (overlay) {
                    this.getOverlay(name).transitionOut();
                    return this.getOverlay(name);
                }
                return null;
            };
            Overlays.prototype.getOverlay = function (name) {
                if (!this._overlays[name])
                    logWarning("Error: gf.core.Overlays.getOverlay(). No overlay with name \"" + name + "\" found.");
                return this._overlays[name];
            };
            Overlays.prototype.onResize = function () {
                var overlay;
                for (var name_2 in this._overlays) {
                    overlay = this._overlays[name_2];
                    if (overlay.isActive) {
                        this._overlays[name_2].onResize();
                    }
                }
            };
            return Overlays;
        }(gf.display.Container));
        core.Overlays = Overlays;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Scale = (function (_super) {
            __extends(Scale, _super);
            function Scale(game) {
                var _this = _super.call(this) || this;
                _this._lastMaxHeight = 0;
                _this._orientation = 0;
                _this.game = game;
                _this._orientation = 0;
                return _this;
            }
            Scale.prototype.init = function () {
                var _this = this;
                $(window).on("orientationchange resize", function () {
                    setTimeout(function () {
                        _this.checkOrientation();
                        if ((PIXI.utils.isMobile.tablet || PIXI.utils.isMobile.phone) && !navigator["isCocoonJS"])
                            _this.setMaxHeight(0);
                    }, 500);
                    _this.checkOrientation();
                });
                var isIframe = false;
                try {
                    if (top.location.href != window.location.href) {
                        isIframe = true;
                    }
                }
                catch (e) {
                }
                if ((PIXI.utils.isMobile.tablet || PIXI.utils.isMobile.phone) && !navigator["isCocoonJS"] && !isIframe) {
                    $(window).on("focus", function () {
                        $(_this.game.canvas).hide();
                        setTimeout(function () {
                            $(_this.game.canvas).show();
                            _this.checkOrientation();
                            _this.setMaxHeight(0);
                        }, 100);
                    });
                    this.setMaxHeight(0);
                }
                this.checkOrientation();
            };
            Scale.prototype.getScreenOrientation = function () {
                var screen = window.screen;
                var orientation = screen["orientation"] || screen["mozOrientation"] || screen["msOrientation"];
                if (orientation && typeof orientation.type === "string") {
                    return (orientation.type.indexOf("portrait") != -1) ? 0 : 90;
                }
                else if (typeof orientation === "string") {
                    return (orientation.indexOf("portrait") != -1) ? 0 : 90;
                }
                if (window.matchMedia) {
                    if (window.matchMedia("(orientation: portrait)").matches) {
                        return 0;
                    }
                    else if (window.matchMedia("(orientation: landscape)").matches) {
                        return 90;
                    }
                    else {
                        return (this.height > this.width) ? 0 : 90;
                    }
                }
                return (this.height > this.width) ? 0 : 90;
            };
            Scale.prototype.checkOrientation = function () {
                this._orientation = this.getScreenOrientation();
                if (this._wasLandscape && this.isPortrait) {
                    this.emit(gf.PORTRAIT, this._orientation, false, true);
                }
                else if (!this._wasLandscape && this.isLandscape) {
                    this.emit(gf.LANDSCAPE, this._orientation, true, false);
                }
                this._wasLandscape = this.isLandscape;
                this.updateSize();
            };
            Scale.prototype.updateSize = function () {
                this.game.renderer.resize(this.parentWidth, this.parentHeight);
                this.game.resize();
                window.scrollTo(window.scrollX, 0);
            };
            Scale.prototype.setMaxHeight = function (count) {
                var _this = this;
                if (window.innerHeight) {
                    if (this._lastMaxHeight != window.innerHeight) {
                        this._lastMaxHeight = window.innerHeight;
                        var element = document.getElementById("kr3m");
                        if (element) {
                            element.style.maxHeight = "" + this._lastMaxHeight + "px";
                            this.updateSize();
                        }
                    }
                    if (count < 10) {
                        setTimeout(function () {
                            _this.setMaxHeight(count + 1);
                        }, 200);
                    }
                }
            };
            Object.defineProperty(Scale.prototype, "styleSize", {
                get: function () {
                    return new PIXI.Point(this.parentWidth, this.parentHeight);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scale.prototype, "isPortrait", {
                get: function () {
                    return this.width < this.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scale.prototype, "isLandscape", {
                get: function () {
                    return !this.isPortrait;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scale.prototype, "parentWidth", {
                get: function () {
                    if (navigator["isCocoonJS"])
                        return window.innerWidth;
                    return $(this.game.canvas.parentElement).width();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scale.prototype, "parentHeight", {
                get: function () {
                    if (navigator["isCocoonJS"])
                        return window.innerHeight * window.devicePixelRatio;
                    return $(this.game.canvas.parentElement).height();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scale.prototype, "width", {
                get: function () {
                    var isPortrait = this.parentWidth < this.parentHeight;
                    if (!isPortrait && this.parentHeight < 321 || (isPortrait && this.parentWidth < 321)) {
                        this.game.stage.scaleX = this.game.stage.scaleY = 1 / 1.5;
                        return this.parentWidth * 1.5;
                    }
                    this.game.stage.scaleX = this.game.stage.scaleY = 1;
                    return this.parentWidth;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Scale.prototype, "height", {
                get: function () {
                    var isPortrait = this.parentWidth < this.parentHeight;
                    if (!isPortrait && this.parentHeight < 321 || (isPortrait && this.parentWidth < 321)) {
                        this.game.stage.scaleX = this.game.stage.scaleY = 1 / 1.5;
                        return this.parentHeight * 1.5;
                    }
                    this.game.stage.scaleX = this.game.stage.scaleY = 1;
                    return this.parentHeight;
                },
                enumerable: true,
                configurable: true
            });
            return Scale;
        }(PIXI.utils.EventEmitter));
        core.Scale = Scale;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Screens = (function (_super) {
            __extends(Screens, _super);
            function Screens(game) {
                var _this = _super.call(this, game) || this;
                _this.name = "screens";
                _this._screens = {};
                _this.interactive = true;
                return _this;
            }
            Screens.prototype.add = function (name, screen) {
                this._screens[name] = screen;
                screen.name = name;
                this.addChild(screen);
            };
            Screens.prototype.init = function () {
                this.game.stage.addChild(this);
                if (!this.game.client.config.screens)
                    return;
                var screen;
                for (var i = 0; i < this.game.client.config.screens.length; ++i) {
                    screen = this.game.client.config.screens[i];
                    if (screen.name && screen.class)
                        this.add(screen.name, new screen.class(this.game));
                    else
                        this.add(screen.NAME, new screen(this.game));
                }
            };
            Screens.prototype.show = function (name) {
                var _this = this;
                if (!this._currentName) {
                    this._currentName = name;
                    this.getScreen(name).transitionIn();
                    return this.current;
                }
                if (this._currentName == name) {
                    this.current.transitionIn();
                    return this.current;
                }
                var currentScreen = this.getScreen(this._currentName);
                var nextScreen = this.getScreen(name);
                if (!nextScreen) {
                    logWarning("Error: gf.core.Screens.show(). No screen found with name: \"" + name + "\"");
                    return;
                }
                this._previousName = this._currentName;
                currentScreen.once(gf.TRANSITION_OUT_COMPLETE, function () {
                    _this._currentName = nextScreen.name;
                    nextScreen.transitionIn();
                    _this.emit(gf.SCREEN, nextScreen, nextScreen.name);
                }, this);
                currentScreen.transitionOut();
                return nextScreen;
            };
            Screens.prototype.hide = function (name) {
                this.getScreen(name).transitionOut();
                return this.getScreen(name);
            };
            Screens.prototype.showPrevious = function () {
                if (!this._previousName || this._previousName === this._currentName) {
                    if (!this._previousName) {
                        logWarning("Error: gf.core.Screens.showPrevious(). No previous screen available.");
                    }
                    else {
                        logWarning("Error: gf.core.Screens.showPrevious(). Current screen is equal to previous screen.");
                    }
                    return null;
                }
                return this.show(this._previousName);
            };
            Screens.prototype.getScreen = function (name) {
                if (!this._screens[name])
                    logWarning("Error: gf.core.Screens.getScreen(). No screen with name \"" + name + "\" found.");
                return this._screens[name];
            };
            Screens.prototype.hasScreen = function (name) {
                return !!this._screens[name];
            };
            Screens.prototype.onResize = function () {
                var screen;
                for (var name_3 in this._screens) {
                    screen = this._screens[name_3];
                    if (screen.isActive) {
                        this._screens[name_3].onResize();
                    }
                }
            };
            Object.defineProperty(Screens.prototype, "currentName", {
                get: function () {
                    return this._currentName;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Screens.prototype, "current", {
                get: function () {
                    return this.getScreen(this._currentName);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Screens.prototype, "previous", {
                get: function () {
                    return this.getScreen(this._previousName);
                },
                enumerable: true,
                configurable: true
            });
            return Screens;
        }(gf.display.Container));
        core.Screens = Screens;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Sounds = (function () {
            function Sounds(game) {
                this.game = game;
                this.forceFxPlay = false;
                this.game.on(gf.BLUR, this.onBlur, this);
                this.game.on(gf.FOCUS, this.onFocus, this);
                this.game.storage.on(gf.DATA, this.onStorage, this);
                this.fx = [];
                this.music = [];
                this._soundsPlaying = [];
            }
            Sounds.prototype.onStorage = function () {
                if (typeof this._fxMuted == "undefined")
                    this._fxMuted = false;
                if (typeof this.game.storage.getItem("fxMuted") == "undefined")
                    this.muteFx(this.game.client.config.muteMusicDefault ? true : this._fxMuted);
                else
                    this.muteFx(!!this.game.storage.getItem("fxMuted"));
                if (typeof this._musicMuted == "undefined")
                    this._musicMuted = false;
                if (typeof this.game.storage.getItem("musicMuted") == "undefined")
                    this.muteMusic(this.game.client.config.muteFxDefault ? true : this._musicMuted);
                else
                    this.muteMusic(!!this.game.storage.getItem("musicMuted"));
            };
            Sounds.prototype.muteSounds = function (value, a) {
                for (var i = 0; i < a.length; ++i)
                    a[i].sound.mute(value);
            };
            Sounds.prototype.stopSound = function (key, a, frame) {
                if (frame === void 0) { frame = ""; }
                for (var i = 0; i < this._soundsPlaying.length; ++i) {
                    if (this._soundsPlaying[i].key == key && this._soundsPlaying[i].frame == frame) {
                        gf.core.Sounds.getSound(key, a).stop(this._soundsPlaying[i].soundId);
                        this._soundsPlaying.splice(i, 1);
                        break;
                    }
                }
            };
            Sounds.getSound = function (key, a) {
                var sound;
                for (var i = 0; i < a.length; ++i) {
                    if (a[i].key == key) {
                        sound = a[i].sound;
                        break;
                    }
                }
                return sound;
            };
            Sounds.soundAdded = function (key, a) {
                var isAdded = false;
                for (var i = 0; i < a.length; ++i) {
                    if (a[i].key == key) {
                        isAdded = true;
                        break;
                    }
                }
                return isAdded;
            };
            Sounds.prototype.onBlur = function () {
                this._fxWasMuted = this._fxMuted;
                this._musicWasMuted = this._musicMuted;
                this._fxMuted = true;
                this.muteSounds(true, this.fx);
                this._musicMuted = true;
                this.muteSounds(true, this.music);
            };
            Sounds.prototype.onFocus = function () {
                this._fxMuted = this._fxWasMuted;
                this.muteSounds(this._fxWasMuted, this.fx);
                this._musicMuted = this._musicWasMuted;
                this.muteSounds(this._musicWasMuted, this.music);
            };
            Sounds.prototype.playFx = function (key, frame, loop, volume) {
                var _this = this;
                if (frame === void 0) { frame = ""; }
                if (loop === void 0) { loop = false; }
                if (volume === void 0) { volume = 1; }
                var sound = this.getFx(key, loop, volume);
                if (!sound || (this._fxMuted && !this.forceFxPlay))
                    return null;
                sound.on("play", function (soundId) {
                    _this._soundsPlaying.push({ key: key, frame: frame, soundId: soundId });
                    if (_this._fxMuted)
                        gf.core.Sounds.getSound(key, _this.fx).mute(true, soundId);
                });
                if (frame.length > 0)
                    sound.stop().play(frame);
                else
                    sound.stop().play();
                return sound;
            };
            Sounds.prototype.stopFx = function (key, frame) {
                if (frame === void 0) { frame = ""; }
                this.stopSound(key, this.fx, frame);
            };
            Sounds.prototype.stopAllFx = function () {
                for (var i = 0; i < this.fx.length; ++i) {
                    for (var j = 0; j < this._soundsPlaying.length; ++j) {
                        if (this._soundsPlaying[j].key == this.fx[i].key) {
                            this.stopFx(this._soundsPlaying[j].key, this._soundsPlaying[j].frame);
                        }
                    }
                }
            };
            Sounds.prototype.playMusic = function (key, frame, loop, volume) {
                var _this = this;
                if (frame === void 0) { frame = ""; }
                if (loop === void 0) { loop = false; }
                if (volume === void 0) { volume = 1; }
                var sound = this.getMusic(key, loop, volume);
                if (!sound)
                    return null;
                sound.on("play", function (soundId) {
                    _this._soundsPlaying.push({ key: key, frame: frame, soundId: soundId });
                    if (_this._musicMuted)
                        gf.core.Sounds.getSound(key, _this.music).mute(true, soundId);
                });
                if (frame.length > 0)
                    sound.stop().play(frame);
                else
                    sound.stop().play();
                sound.loop(loop);
                sound.volume(volume);
                return sound;
            };
            Sounds.prototype.stopMusic = function (key) {
                this.stopSound(key, this.music);
            };
            Sounds.prototype.muteFx = function (value, storage) {
                if (storage === void 0) { storage = true; }
                this._fxMuted = value;
                this.muteSounds(value, this.fx);
                if (storage)
                    this.game.storage.setItem("fxMuted", value);
            };
            Sounds.prototype.muteMusic = function (value, storage) {
                if (storage === void 0) { storage = true; }
                this._musicMuted = value;
                this.muteSounds(value, this.music);
                if (storage)
                    this.game.storage.setItem("musicMuted", value);
            };
            Sounds.prototype.addSound = function (key, soundType, callback) {
                var _this = this;
                var a = (soundType == gf.SOUND_FX) ? this.fx : this.music;
                if (gf.core.Sounds.soundAdded(key, a)) {
                    if (callback)
                        callback();
                    return;
                }
                var sound;
                var json = this.game.cache.getSound(key).json;
                var properties = {
                    src: [this.game.cache.getSound(key).url], onload: function () {
                        if (callback)
                            callback();
                    },
                    onloaderror: function (soundId, error) {
                        logWarning("Error loading sound (ID: " + soundId + ", key: " + key + ", url: " + _this.game.cache.getSound(key).url + ". " + error);
                        if (callback)
                            callback();
                    }
                };
                if (json) {
                    properties.sprite = json.sprite;
                }
                sound = new Howl(properties);
                a.push({ key: key, sound: sound });
                return sound;
            };
            Sounds.prototype.reload = function (callback) {
                var _this = this;
                this._soundsReloaded = 0;
                var fxKeys = [];
                this.fx.forEach(function (value) {
                    fxKeys.push(value.key);
                });
                this.fx = [];
                fxKeys.forEach(function (value) {
                    _this._soundsReloaded++;
                    _this.addSound(value, "fx", function () {
                        _this.soundReloaded(callback);
                    });
                });
                var musicKeys = [];
                this.music.forEach(function (value) {
                    musicKeys.push(value.key);
                });
                this.music = [];
                musicKeys.forEach(function (value) {
                    _this._soundsReloaded++;
                    _this.addSound(value, "music", function () {
                        _this.soundReloaded(callback);
                    });
                });
            };
            Sounds.prototype.soundReloaded = function (callback) {
                this._soundsReloaded--;
                if (this._soundsReloaded == 0 && callback)
                    callback();
            };
            Sounds.prototype.getFx = function (key, loop, volume) {
                if (loop === void 0) { loop = false; }
                if (volume === void 0) { volume = 1; }
                var sound = gf.core.Sounds.getSound(key, this.fx);
                if (!sound)
                    return null;
                sound.loop(loop);
                sound.volume(volume);
                return sound;
            };
            Sounds.prototype.getMusic = function (key, loop, volume) {
                if (loop === void 0) { loop = false; }
                if (volume === void 0) { volume = 1; }
                var sound = gf.core.Sounds.getSound(key, this.music);
                if (!sound)
                    return null;
                sound.loop(loop);
                sound.volume(volume);
                return sound;
            };
            Object.defineProperty(Sounds.prototype, "isFxMuted", {
                get: function () {
                    return this._fxMuted;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Sounds.prototype, "isMusicMuted", {
                get: function () {
                    return this._musicMuted;
                },
                enumerable: true,
                configurable: true
            });
            return Sounds;
        }());
        core.Sounds = Sounds;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Stage = (function (_super) {
            __extends(Stage, _super);
            function Stage(game) {
                var _this = _super.call(this, game) || this;
                _this.name = "stage";
                _this.interactive = true;
                _this.game.on(gf.RESIZE, _this.onResize, _this);
                return _this;
            }
            Stage.prototype.addFooter = function () {
                if (!this.game.client.config.FooterClass)
                    return;
                this.footer = new this.game.client.config.FooterClass(this.game);
                this.footer.interactive = true;
                this.addChild(this.footer);
            };
            Stage.prototype.addHeader = function () {
                if (!this.game.client.config.HeaderClass)
                    return;
                this.header = new this.game.client.config.HeaderClass(this.game);
                this.header.interactive = true;
                this.addChild(this.header);
            };
            return Stage;
        }(gf.display.Container));
        core.Stage = Stage;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var model;
    (function (model) {
        model.COOLDOWN_CHANGE = "cooldownChange";
        model.COOLDOWN_COMPLETE = "cooldownComplete";
        var Cooldown = (function (_super) {
            __extends(Cooldown, _super);
            function Cooldown(game, duration, maxValue, storageToken, defaultValue) {
                var _this = _super.call(this) || this;
                _this.game = game;
                _this.duration = duration;
                _this.currentValue = maxValue;
                _this.maxValue = maxValue;
                _this.defaultValue = defaultValue ? defaultValue : maxValue;
                _this.storageToken = storageToken;
                return _this;
            }
            Cooldown.prototype.onStorageData = function (data) {
                this.timeLeft = 0;
                this.currentValue = data ? data[this.storageToken] : this.game.storage.getItem(this.storageToken);
                if (typeof this.currentValue == "undefined") {
                    this.currentValue = this.defaultValue;
                }
                this.timestamp = data ? data[this.storageToken + "Timestamp"] : this.game.storage.getItem(this.storageToken + "Timestamp");
                if (typeof this.timestamp == "undefined" && this.currentValue < this.maxValue) {
                    this.timestamp = this.currentTime;
                    this.store();
                }
                if (this.currentValue < this.maxValue) {
                    var toAdd = ((this.currentTime - this.timestamp) / this.duration) >> 0;
                    this.currentValue += toAdd;
                    if (toAdd > 0) {
                        this.update();
                        this.store();
                    }
                    this.timeLeft = this.duration - (this.currentTime - this.timestamp - toAdd * this.duration);
                }
                this.update();
                this.game.on(gf.BLUR, this.onBlur, this);
                this.game.on(gf.FOCUS, this.onFocus, this);
            };
            Cooldown.prototype.store = function () {
                if (this.currentValue == this.maxValue - 1)
                    this.timestamp = this.currentTime;
                this.game.storage.setItem([this.storageToken, this.storageToken + "Timestamp"], [this.currentValue, this.timestamp]);
            };
            Cooldown.prototype.onFocus = function () {
                var _this = this;
                this.game.removeListener(gf.BLUR, this.onBlur, this);
                this.game.removeListener(gf.FOCUS, this.onFocus, this);
                this.game.storage.getData(false, function (data) { return _this.onStorageData(data); });
            };
            Cooldown.prototype.onBlur = function () {
                this.stopCountdown();
            };
            Cooldown.prototype.startCountdown = function () {
                var _this = this;
                if (this.cooldownRunning)
                    return;
                this.cooldownRunning = true;
                this.cooldown = new TimelineMax({ repeat: -1 }).addCallback(function () {
                    _this.timeLeft -= 1000;
                    _this.updateCountdown();
                }, 1);
                this.updateCountdown();
            };
            Cooldown.prototype.stopCountdown = function () {
                if (this.cooldownRunning) {
                    this.cooldown.clear();
                    this.cooldown.kill();
                    this.cooldownRunning = false;
                }
            };
            Cooldown.prototype.updateCountdown = function () {
                if (this.timeLeft <= 0) {
                    this.timeLeft = 0;
                    this.add();
                }
                this.emit(gf.model.COOLDOWN_CHANGE);
            };
            Cooldown.prototype.update = function () {
                this.currentValue = Math.max(Math.min(this.currentValue, this.maxValue), 0);
                if (this.currentValue == this.maxValue) {
                    this.emit(gf.model.COOLDOWN_CHANGE);
                    this.emit(gf.model.COOLDOWN_COMPLETE);
                    this.stopCountdown();
                }
                else {
                    if (this.timeLeft == 0)
                        this.timeLeft = this.duration;
                    this.startCountdown();
                    this.emit(gf.model.COOLDOWN_CHANGE);
                }
            };
            Cooldown.prototype.add = function () {
                var _this = this;
                this.game.storage.getData(false, function () {
                    _this.currentValue++;
                    _this.store();
                    _this.update();
                });
            };
            Cooldown.prototype.remove = function () {
                var _this = this;
                this.game.storage.getData(false, function () {
                    _this.currentValue--;
                    _this.store();
                    _this.update();
                });
            };
            Object.defineProperty(Cooldown.prototype, "currentTime", {
                get: function () {
                    return new Date().getTime();
                },
                enumerable: true,
                configurable: true
            });
            return Cooldown;
        }(PIXI.utils.EventEmitter));
        model.Cooldown = Cooldown;
    })(model = gf.model || (gf.model = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Format = (function () {
            function Format() {
            }
            Format.toHHMMSS = function (ms) {
                var totalSeconds = (ms / 1000) << 0;
                var hours = (totalSeconds / 3600) << 0;
                var minutes = ((totalSeconds - (hours * 3600)) / 60) << 0;
                var seconds = totalSeconds - (hours * 3600) - (minutes * 60);
                var h = hours < 10 ? "0" + hours.toString() : hours.toString();
                var m = minutes < 10 ? "0" + minutes.toString() : minutes.toString();
                var s = seconds < 10 ? "0" + seconds.toString() : seconds.toString();
                return h + ":" + m + ":" + s;
            };
            Format.toMMSS = function (ms) {
                var minutes = (ms / 1000 / 60) << 0;
                var seconds = ((ms / 1000) % 60) << 0;
                var m = minutes < 10 ? "0" + minutes.toString() : minutes.toString();
                var s = seconds < 10 ? "0" + seconds.toString() : seconds.toString();
                return m + ":" + s;
            };
            Format.decimalMark = function (value, mark) {
                if (mark === void 0) { mark = "."; }
                return String(value).replace(/(\d)(?=(\d{3})+(?!\d))/g, "$1" + mark);
            };
            return Format;
        }());
        utils.Format = Format;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var ItemVO = (function () {
            function ItemVO() {
                this.custom = {};
            }
            return ItemVO;
        }());
        vo.ItemVO = ItemVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var EpisodeVO = (function (_super) {
            __extends(EpisodeVO, _super);
            function EpisodeVO() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Object.defineProperty(EpisodeVO.prototype, "lastLevel", {
                get: function () {
                    return this.levels[this.levels.length - 1];
                },
                enumerable: true,
                configurable: true
            });
            return EpisodeVO;
        }(gf.vo.ItemVO));
        vo.EpisodeVO = EpisodeVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var HighscoreVO = (function () {
            function HighscoreVO() {
                this.myself = false;
                this.score = 0;
            }
            HighscoreVO.prototype.reset = function () {
                this.score = 0;
                this.myself = false;
                this.levelId = null;
                this.imageUrl = null;
                this.rank = null;
                this.name = null;
            };
            return HighscoreVO;
        }());
        vo.HighscoreVO = HighscoreVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var ResultVO = (function () {
            function ResultVO() {
                this.custom = {};
                this.score = 0;
                this.stars = 0;
                this.won = false;
            }
            return ResultVO;
        }());
        vo.ResultVO = ResultVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var LevelVO = (function (_super) {
            __extends(LevelVO, _super);
            function LevelVO() {
                var _this = _super !== null && _super.apply(this, arguments) || this;
                _this.jsonLoaded = false;
                _this.highscoreDataVO = new gf.vo.HighscoreVO();
                _this.resultVO = new gf.vo.ResultVO();
                return _this;
            }
            LevelVO.prototype.getStarCount = function (score) {
                var star = 0;
                if (score == 0 || !this.stars)
                    return star;
                this.stars.forEach(function (value) {
                    if (score >= value)
                        star++;
                });
                return star;
            };
            LevelVO.prototype.reset = function () {
                this.tokenFail = null;
                this.tokenWin = null;
                this.stars = null;
                this.custom = null;
                this.jsonLoaded = false;
                this.id = null;
                this.highscoreDataVO.reset();
            };
            LevelVO.prototype.fromJson = function (data) {
                this.tokenFail = data.fail_text_token;
                this.tokenWin = data.win_text_token;
                this.stars = data.stars;
                this.custom = data.custom;
                this.jsonLoaded = true;
                this.id = data.id;
                return this;
            };
            return LevelVO;
        }(gf.vo.ItemVO));
        vo.LevelVO = LevelVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var model;
    (function (model) {
        var msForUnlock = 259200000;
        model.EPISODE_UNLOCKED = "episodeUnlocked";
        model.EPISODE_UPDATE = "episodeUpdate";
        var Episodes = (function (_super) {
            __extends(Episodes, _super);
            function Episodes(game) {
                var _this = _super.call(this, game, msForUnlock, 1, "episode1", 1) || this;
                _this.game.user.on(gf.LOGOUT, _this.reset, _this);
                _this._episodes = [];
                _this._activations = [["default"]];
                _this.on(gf.model.COOLDOWN_COMPLETE, function () {
                    var episode = _this.game.storage.getItem("episodeToUnlock");
                    if (episode) {
                        _this.unlockEpisodeByTime(episode);
                    }
                }, _this);
                return _this;
            }
            Episodes.prototype.onData = function () {
                this._activations = this.game.storage.getItem("episodes");
                if (!this._activations) {
                    this.setActivations([["default"]]);
                }
                this.unlockEpisodes();
            };
            Episodes.prototype.setActivations = function (value) {
                this._activations = [value];
                this.game.storage.setItem("episodes", this._activations);
            };
            Episodes.prototype.init = function () {
                if (!this.game.cache.checkJSON("levels"))
                    return;
                var episodes = this.game.cache.getJSON("levels").episodes;
                this._total = episodes.length;
                if (this._total > 0) {
                    var episodeVO = void 0;
                    for (var i = 0; i < this._total; ++i) {
                        episodeVO = new gf.vo.EpisodeVO();
                        episodeVO.id = i + 1;
                        episodeVO.levels = episodes[i].levels;
                        episodeVO.custom = episodes[i].custom || {};
                        this._episodes.push(episodeVO);
                    }
                    this._current = this.getEpisode(1);
                }
                this.game.storage.on(gf.DATA, this.onData, this);
            };
            Episodes.prototype.unlockEpisodes = function () {
                if (this._total <= 0)
                    return;
                var episodeVO = this.getEpisode(1);
                episodeVO.unlocked = true;
                this._current = episodeVO;
                this.unlockLevelForEpisode(episodeVO.id);
                for (var i = 0; i < this._total; ++i) {
                    episodeVO = this._episodes[i];
                    var levels = episodeVO.levels;
                    var lastLevelVO = this.game.levels.getLevelVO(levels[levels.length - 1]);
                    if (lastLevelVO && lastLevelVO.unlocked && this._episodes[i + 1]) {
                        episodeVO = this._episodes[i + 1];
                        episodeVO.unlocked = this.isEpisodeUnlocked(episodeVO.id);
                        if (episodeVO.unlocked) {
                            if (episodeVO.id == 1 || this.game.levels.getLevelVO(this.getEpisode(episodeVO.id - 1).lastLevel).unlocked) {
                                this._current = episodeVO;
                                this.unlockLevelForEpisode(episodeVO.id);
                            }
                        }
                    }
                }
                if (this.hasNext) {
                    episodeVO = this.getEpisode(this.next.id);
                    episodeVO.unlocked = this.isEpisodeUnlocked(episodeVO.id);
                    if (episodeVO.unlocked) {
                        if (episodeVO.id == 1 || this.game.levels.getLevelVO(this.getEpisode(episodeVO.id - 1).lastLevel).unlocked) {
                            this._current = episodeVO;
                            this.unlockLevelForEpisode(episodeVO.id);
                        }
                    }
                }
                episodeVO = this.getEpisode(this.game.storage.getItem("episodeToUnlock"));
                if (episodeVO) {
                    episodeVO.unlocked = this.isEpisodeUnlocked(episodeVO.id);
                    if (episodeVO.unlocked) {
                        if (episodeVO.id == 1 || this.game.levels.getLevelVO(this.getEpisode(episodeVO.id - 1).lastLevel).unlocked) {
                            this._current = episodeVO;
                            this.unlockLevelForEpisode(episodeVO.id);
                        }
                    }
                    else {
                        this.startActivationCountdown(episodeVO.id);
                    }
                }
            };
            Episodes.prototype.unlockLevelForEpisode = function (episode) {
                var levelVO = this.game.levels.getLevelVO(this.getEpisode(episode).levels[0]);
                if (levelVO && !levelVO.unlocked) {
                    levelVO.unlocked = true;
                    var progress = new gf.vo.ProgressVO();
                    progress.level = levelVO.id;
                    progress.score = 0;
                    progress.unlocked = true;
                    this.game.user.progress.setProgress(progress);
                }
            };
            Episodes.prototype.reset = function () {
                this._current = this.getEpisode(1);
                this._activations = [["default"]];
            };
            Episodes.prototype.deletePendingRequests = function (callback) {
                var _this = this;
                var requestIds = [];
                casClient.getRequests(function (requests) {
                    requests.outgoing.forEach(function (request) {
                        if (request.status == "ACCEPTED") {
                            if (request.customData.type == gf.REQUEST_EPISODE) {
                                _this.unlockEpisodeByUser(request.user, request.customData.episode);
                                requestIds.push(request.id);
                            }
                        }
                    });
                    if (requestIds.length == 0) {
                        if (callback)
                            callback();
                    }
                    else {
                        var requestsDeleted_1 = 0;
                        requestIds.forEach(function (value) {
                            casClient.deleteRequest(value, function () {
                                requestsDeleted_1++;
                                if (requestsDeleted_1 == requestIds.length)
                                    if (callback)
                                        callback();
                            });
                        });
                    }
                });
            };
            Episodes.prototype.startActivationCountdown = function (episode) {
                if (episode > this._total)
                    return;
                this.storageToken = "episode" + episode;
                if (!!!(this.game.storage.getItem(this.storageToken + "Running"))) {
                    this.game.storage.setItem(this.storageToken + "Running", true);
                    this.game.storage.setItem(this.storageToken, 0);
                    this.game.storage.setItem("episodeToUnlock", episode);
                }
                this.onStorageData();
            };
            Episodes.prototype.getEpisode = function (episode) {
                var result = null;
                this._episodes.forEach(function (episodeVO) {
                    if (episodeVO.id == episode) {
                        result = episodeVO;
                        return false;
                    }
                    return true;
                });
                return result;
            };
            Episodes.prototype.getEpisodeByLevel = function (level) {
                var result = null;
                this._episodes.forEach(function (episodeVO) {
                    if (episodeVO.levels.indexOf(level) != -1) {
                        result = episodeVO;
                        return false;
                    }
                    return true;
                });
                return result;
            };
            Episodes.prototype.getActivationsByEpisode = function (episode) {
                if (!episode) {
                    return this._activations[this._current.id - 1];
                }
                return this._activations[episode - 1];
            };
            Episodes.prototype.unlockEpisodeByUser = function (user, episode) {
                if (!episode) {
                    this.unlockEpisodeByUser(user, this._current.id);
                    return;
                }
                var activations = (this._activations[episode - 1]) ? this._activations[episode - 1] : [];
                var userFound = false;
                activations.forEach(function (value) {
                    if (value && value.id == user.id) {
                        userFound = true;
                    }
                });
                if (!userFound) {
                    activations.push(user);
                    this._activations[episode - 1] = activations;
                    this.game.storage.setItem("episodes", this._activations);
                }
                var episodeVO = this.getEpisode(episode);
                episodeVO.unlocked = this.isEpisodeUnlocked(episode);
                if (episodeVO.unlocked) {
                    this.emit(gf.model.EPISODE_UNLOCKED, episode, activations);
                }
                return episodeVO.unlocked;
            };
            Episodes.prototype.unlockEpisodeByTime = function (episode) {
                var episodeVO = this.getEpisode(episode);
                var activations = (this._activations[episode - 1]) ? this._activations[episode - 1] : [];
                activations.push("activatedByTimer");
                episodeVO.unlocked = this.isEpisodeUnlocked(episode);
                this._activations[episode - 1] = activations;
                this.game.storage.setItem("episodes", this._activations);
                if (episodeVO.unlocked) {
                    if (episodeVO.id == 1 || this.game.levels.getLevelVO(this.getEpisode(episodeVO.id - 1).lastLevel).unlocked) {
                        this._current = episodeVO;
                        this.unlockLevelForEpisode(episodeVO.id);
                    }
                }
            };
            Episodes.prototype.unlockEpisode = function (episode) {
                this._activations[episode - 1] = ["default"];
                this.game.storage.setItem("episodes", this._activations);
                var episodeVO = this.getEpisode(episode);
                episodeVO.unlocked = this.isEpisodeUnlocked(episode);
                if (episodeVO.unlocked) {
                    if (episodeVO.id == 1 || this.game.levels.getLevelVO(this.getEpisode(episodeVO.id - 1).lastLevel).unlocked) {
                        this._current = episodeVO;
                        this.unlockLevelForEpisode(episodeVO.id);
                    }
                }
            };
            Episodes.prototype.isEpisodeUnlocked = function (episode) {
                if (episode > this._total)
                    return false;
                var activations = this.getActivationsByEpisode(episode);
                if (activations && activations.length > 0) {
                    return (activations.length == 3 || activations[0] == "default" || activations[0] == "activatedByCurrency" || activations[0] == "activatedByTimer");
                }
                return this.getEpisode(episode).unlocked;
            };
            Episodes.prototype.isUnlocking = function (episode) {
                var pending = this.game.storage.getItem("episodeToUnlock");
                if (!pending)
                    return false;
                return pending == episode;
            };
            Episodes.prototype.isUnlocked = function (level) {
                return this.getEpisodeByLevel(level).unlocked;
            };
            Object.defineProperty(Episodes.prototype, "lastLevel", {
                get: function () {
                    if (this._current) {
                        return this._current.levels[this._current.levels.length - 1];
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Episodes.prototype, "hasNext", {
                get: function () {
                    return this.current.id < this._total;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Episodes.prototype, "previous", {
                get: function () {
                    if (this._current.id > 1)
                        return this.getEpisode(this._current.id - 1);
                    return null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Episodes.prototype, "next", {
                get: function () {
                    if (this.hasNext)
                        return this.getEpisode(this._current.id + 1);
                    return null;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Episodes.prototype, "current", {
                get: function () {
                    return this._current;
                },
                set: function (value) {
                    this._current = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Episodes.prototype, "formatedTime", {
                get: function () {
                    return gf.utils.Format.toHHMMSS(this.timeLeft);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Episodes.prototype, "total", {
                get: function () {
                    return this._total;
                },
                enumerable: true,
                configurable: true
            });
            return Episodes;
        }(gf.model.Cooldown));
        model.Episodes = Episodes;
    })(model = gf.model || (gf.model = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var model;
    (function (model) {
        var Progress = (function () {
            function Progress(game) {
                this.game = game;
                this.progress = [];
                this.game.storage.on(gf.DATA, this.onStorageData, this);
                this.game.user.on(gf.LOGOUT, this.reset, this);
            }
            Progress.prototype.onStorageData = function () {
                if (this.game.user.isLoggedIn) {
                    this.mergeProgress();
                }
                else {
                    this.progress = [];
                    this.game.levels.unlockLevels();
                }
            };
            Progress.prototype.reset = function () {
                this.progress = [];
            };
            Progress.prototype.mergeProgress = function () {
                var _this = this;
                var levels = this.game.storage.getItem("levels");
                var storedProgress = [];
                for (var key in levels) {
                    if (levels.hasOwnProperty(key)) {
                        storedProgress.push(levels[key]);
                    }
                }
                var progressToSet = [];
                var progressVO;
                this.progress.forEach(function (currentProgressVO) {
                    progressVO = _this.getProgressByLevel(storedProgress, currentProgressVO.level);
                    if (progressVO) {
                        if (currentProgressVO.score > progressVO.score) {
                            progressToSet.push(progressVO);
                        }
                    }
                    else {
                        progressToSet.push(currentProgressVO);
                    }
                });
                var data = {};
                var scoresToSet = [];
                progressToSet.forEach(function (progressVO) {
                    data[progressVO.level] = progressVO;
                    scoresToSet.push({ score: progressVO.score, level: progressVO.level });
                });
                if (progressToSet.length > 0) {
                    this.game.storage.updateItem("levels", data, function () {
                        if (_this.game.client.config.useCAS) {
                            var entries_1 = [];
                            var vo_1;
                            scoresToSet.forEach(function (value) {
                                vo_1 = new cas.vo.NewHighscore();
                                vo_1.category = "level" + value.level;
                                vo_1.score = value.score;
                                if (vo_1.score != 0)
                                    entries_1.push(vo_1);
                            });
                            casClient.setHighscores(entries_1, function () { });
                        }
                        _this.game.levels.unlockLevels();
                    });
                }
                else {
                    this.game.levels.unlockLevels();
                }
            };
            Progress.prototype.setProgress = function (progress) {
                var _this = this;
                var progressFound = false;
                this.progress.forEach(function (vo) {
                    if (vo.level == progress.level) {
                        progressFound = true;
                        if (progress.score > vo.score) {
                            $.extend(vo, progress);
                            _this.game.storage.updateItem("levels", (_a = {}, _a[progress.level] = progress, _a));
                        }
                    }
                    var _a;
                });
                if (!progressFound) {
                    this.progress.push($.extend(new gf.vo.ProgressVO(), progress));
                    this.game.storage.updateItem("levels", (_a = {}, _a[progress.level] = progress, _a));
                }
                var _a;
            };
            Progress.prototype.getProgress = function (level) {
                var levels = this.game.storage.getItem("levels");
                var lastLevel = 1;
                var progress = new gf.vo.ProgressVO;
                for (var key in levels) {
                    if (levels.hasOwnProperty(key)) {
                        progress = levels[key];
                        if (isNaN(level)) {
                            if (progress.level > lastLevel) {
                                lastLevel = progress.level;
                            }
                        }
                        else if (progress.level == level) {
                            return progress;
                        }
                    }
                }
                if (!level) {
                    return this.getProgress(lastLevel);
                }
            };
            Progress.prototype.getProgressByLevel = function (progressVOs, level) {
                var progress = null;
                progressVOs.forEach(function (vo) {
                    if (vo.level == level) {
                        progress = vo;
                        return true;
                    }
                });
                return progress;
            };
            return Progress;
        }());
        model.Progress = Progress;
    })(model = gf.model || (gf.model = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var model;
    (function (model) {
        var maxLives = 5;
        var msForLife = 600000;
        var Lives = (function (_super) {
            __extends(Lives, _super);
            function Lives(game) {
                var _this = _super.call(this, game, msForLife, maxLives, "lives") || this;
                if (_this.game.client.config.hasLives)
                    _this.game.storage.on(gf.DATA, _this.onStorageData, _this);
                return _this;
            }
            Object.defineProperty(Lives.prototype, "formatedTime", {
                get: function () {
                    return gf.utils.Format.toMMSS(this.timeLeft);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Lives.prototype, "lives", {
                get: function () {
                    return this.currentValue;
                },
                enumerable: true,
                configurable: true
            });
            return Lives;
        }(gf.model.Cooldown));
        model.Lives = Lives;
    })(model = gf.model || (gf.model = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var model;
    (function (model) {
        var User = (function (_super) {
            __extends(User, _super);
            function User(game) {
                var _this = _super.call(this) || this;
                _this._email = "";
                _this._id = 0;
                _this._isLoggedIn = false;
                _this._imageUrl = "";
                _this._name = "";
                _this.game = game;
                return _this;
            }
            User.prototype.onLoggedIn = function (status, callback) {
                if (status.toLowerCase() == gf.SUCCESS) {
                    this._isLoggedIn = true;
                    this.emit(gf.LOGIN);
                    this.getUser(function () {
                        callback(gf.SUCCESS);
                    });
                }
                else {
                    callback(status);
                }
            };
            User.prototype.getLoginStatus = function (callback) {
                var _this = this;
                casClient.isLoggedIn(function (result) {
                    if (result) {
                        _this._isLoggedIn = true;
                        _this.emit(gf.LOGIN);
                        _this.getUser(function () {
                            callback(true);
                        });
                    }
                    else {
                        callback(false);
                    }
                });
            };
            User.prototype.getUser = function (callback) {
                var _this = this;
                casClient.getUser(function (user) {
                    _this._id = user.id;
                    _this._name = user.username;
                    _this._imageUrl = user.imageUrl;
                    if (user.email && user.email.length > 0) {
                        _this._email = user.email;
                    }
                    callback();
                });
            };
            User.prototype.login = function (callback) {
                var _this = this;
                if (this._isLoggedIn)
                    return;
                if (this.game.client.config.hasRaffle)
                    casClient.ui.showRaffleDialog(function (status) { return _this.onLoggedIn(status, callback); });
                else
                    casClient.ui.showLoginDialog(function (status) { return _this.onLoggedIn(status, callback); });
            };
            User.prototype.logout = function (callback) {
                var _this = this;
                if (!this._isLoggedIn)
                    return;
                casClient.logout(function () {
                    _this._isLoggedIn = false;
                    _this.emit(gf.LOGOUT);
                    callback();
                });
            };
            User.prototype.raffle = function (callback) {
                var _this = this;
                casClient.ui.showRaffleDialog(function (status) {
                    if (status.toLowerCase() == gf.SUCCESS) {
                        _this._isLoggedIn = true;
                        _this.emit(gf.LOGIN);
                        _this.getUser(function () {
                            callback(gf.SUCCESS);
                        });
                    }
                    else {
                        callback(status);
                    }
                });
            };
            User.prototype.showAccountDialog = function (callback) {
                casClient.ui.showAccountDialog(function (status) {
                    if (callback)
                        callback(status);
                });
            };
            Object.defineProperty(User.prototype, "isLoggedIn", {
                get: function () {
                    return this._isLoggedIn;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(User.prototype, "email", {
                get: function () {
                    return this._email;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(User.prototype, "id", {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(User.prototype, "imageUrl", {
                get: function () {
                    return this._imageUrl;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(User.prototype, "name", {
                get: function () {
                    return this._name;
                },
                enumerable: true,
                configurable: true
            });
            return User;
        }(PIXI.utils.EventEmitter));
        model.User = User;
    })(model = gf.model || (gf.model = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var vo;
    (function (vo) {
        var ProgressVO = (function () {
            function ProgressVO() {
                this.custom = {};
                this.score = 0;
                this.unlocked = false;
            }
            return ProgressVO;
        }());
        vo.ProgressVO = ProgressVO;
    })(vo = gf.vo || (gf.vo = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var model;
    (function (model) {
        var Levels = (function () {
            function Levels(game) {
                this._levelCapReached = false;
                this.game = game;
                this.levels = [];
                this.game.user.on(gf.LOGOUT, this.reset, this);
            }
            Levels.prototype.loadLevels = function (count) {
                var _this = this;
                this.game.overlays.show("loader");
                var loader = new gf.core.Loader(this.game);
                var start = this.game.client.config.hasEndless ? 0 : 1;
                for (var i = start; i <= count; ++i) {
                    if (!this.game.cache.checkJSON("level" + i)) {
                        loader.json("level" + i, this._levelPath + "level" + i + ".json");
                    }
                }
                loader.once(gf.LOAD_COMPLETE, function () {
                    for (var i = start; i <= count; ++i) {
                        _this.getLevelVO(i).fromJson(_this.game.cache.getJSON("level" + i));
                    }
                    _this.game.overlays.hide("loader");
                }, this);
                loader.start();
            };
            Levels.prototype.init = function () {
                if (!this.game.cache.checkJSON("levels"))
                    return;
                this.data = this.game.cache.getJSON("levels");
                this._levelCount = this.data.total;
                this._levelPath = this.data.path;
                var level;
                for (var i = 0; i < this._levelCount; ++i) {
                    level = new gf.vo.LevelVO();
                    level.id = this.game.client.config.hasEndless ? i : i + 1;
                    this.levels.push(level);
                }
            };
            Levels.prototype.reset = function () {
                this.levels = [];
                this.init();
                this.unlockLevels();
            };
            Levels.prototype.loadLevel = function (level, onComplete) {
                var _this = this;
                if (!this.game.cache.checkJSON("levels"))
                    return;
                if (level < 0 || level > this._levelCount)
                    return;
                if (!this.game.cache.getJSON("level" + level)) {
                    var loader = new gf.core.Loader(this.game);
                    loader.once(gf.LOAD_COMPLETE, function () {
                        _this.getLevelVO(level).fromJson(_this.game.cache.getJSON("level" + level));
                        if (onComplete)
                            onComplete();
                    }, this);
                    loader.json("level" + level, this._levelPath + "level" + level + ".json");
                    loader.start();
                }
                else {
                    if (onComplete)
                        onComplete();
                }
            };
            Levels.prototype.getLevelVO = function (level) {
                var result = null;
                this.levels.forEach(function (levelVO) {
                    if (levelVO.id == level) {
                        result = levelVO;
                        return true;
                    }
                });
                return result;
            };
            Levels.prototype.updateLevelVO = function (level, data) {
                var result;
                this.levels.forEach(function (levelVO) {
                    if (levelVO.id == level) {
                        levelVO = $.extend(levelVO, data);
                        result = levelVO;
                        return true;
                    }
                });
                if (this.currentLevel.id == level) {
                    this.currentLevel = result;
                }
                return result;
            };
            Levels.prototype.unlockNextLevel = function (level) {
                var _this = this;
                if (this.getLevelVO(level)) {
                    if (!this.currentLevel.jsonLoaded) {
                        this.game.levels.loadLevel(level, function () { return _this.unlockLevel(level); });
                    }
                    else {
                        var episode = this.game.episodes.getEpisodeByLevel(level).id;
                        if (!this.game.episodes.isEpisodeUnlocked(episode)) {
                            this.game.episodes.startActivationCountdown(episode);
                        }
                        this.unlockLevel(level);
                    }
                }
                else {
                    return true;
                }
                return false;
            };
            Levels.prototype.unlockLevel = function (level) {
                if (!this.game.cache.checkJSON("levels"))
                    return;
                var levelVO = this.getLevelVO(level);
                levelVO.unlocked = true;
                var progress = new gf.vo.ProgressVO();
                progress.level = level;
                progress.unlocked = true;
                this.game.user.progress.setProgress(progress);
            };
            Levels.prototype.unlockLevels = function () {
                if (!this.game.cache.checkJSON("levels"))
                    return;
                var levels = this.game.storage.getItem("levels");
                var start = this.game.client.config.hasEndless ? 0 : 1;
                var currentLevel = start;
                if (!levels) {
                    for (var i = start; i <= this.game.client.config.unlockedLevels; ++i) {
                        this.unlockLevel(i);
                        var progress = new gf.vo.ProgressVO();
                        progress.level = i;
                        progress.unlocked = true;
                        this.game.storage.setItem("levels", (_a = {}, _a[progress.level] = progress, _a));
                    }
                    this.currentLevel = this.getLevelVO(1);
                }
                else {
                    var level = void 0;
                    for (var key in levels) {
                        var data = levels[key];
                        if (data.level <= this._levelCount) {
                            if (!currentLevel || data.level > currentLevel && data.unlocked) {
                                currentLevel = data.level;
                            }
                            level = this.getLevelVO(data.level);
                            if (level) {
                                level.unlocked = data.unlocked;
                                this.game.user.progress.setProgress(data);
                            }
                        }
                    }
                    if (!this._currentLevel) {
                        this._currentLevel = this.getLevelVO(currentLevel);
                        this._currentLevel.unlocked = true;
                    }
                }
                this.loadLevels(currentLevel);
                var _a;
            };
            Levels.prototype.getStars = function (score, level, ascending) {
                if (ascending === void 0) { ascending = true; }
                var levelVO = this.getLevelVO(level);
                if (score == null || score == 0 || levelVO == null) {
                    return 0;
                }
                var s = levelVO.stars;
                var i;
                var stars;
                if (ascending) {
                    stars = s.length;
                    for (i = s.length - 1; i >= 0; --i) {
                        if (score && score < s[i])
                            stars--;
                    }
                }
                else {
                    stars = 0;
                    for (i = 0; i < s.length; ++i) {
                        if (score && score < s[i])
                            stars++;
                    }
                }
                return stars;
            };
            Levels.prototype.getScoreByLevel = function (level) {
                return this.getLevelVO(level).highscoreDataVO.score;
            };
            Object.defineProperty(Levels.prototype, "currentLevel", {
                get: function () {
                    return this._currentLevel;
                },
                set: function (value) {
                    this._currentLevel = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Levels.prototype, "levelCapReached", {
                get: function () {
                    return this._levelCapReached;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Levels.prototype, "lastUnlockedLevelVO", {
                get: function () {
                    var i;
                    for (i = 0; i < this.levels.length; ++i) {
                        if (!this.levels[i] || !this.levels[i].unlocked) {
                            break;
                        }
                    }
                    return this.levels[i] ? this.levels[i] : this.levels[i - 1];
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Levels.prototype, "levelCount", {
                get: function () {
                    return this._levelCount;
                },
                enumerable: true,
                configurable: true
            });
            return Levels;
        }());
        model.Levels = Levels;
    })(model = gf.model || (gf.model = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Render = (function () {
            function Render() {
            }
            Render.onChange = function (game) {
                this.type = gf.RENDER_TYPE_ON_CHANGE;
                PIXI.mesh.Mesh.prototype["game"] = game;
                PIXI.mesh.Mesh.prototype["_onTextureUpdate"] = (function (_super) {
                    return function () {
                        this.game.renderState = 2;
                        return _super.apply(this, arguments);
                    };
                })(PIXI.mesh.Mesh.prototype["_onTextureUpdate"]);
                PIXI.Sprite.prototype["game"] = game;
                PIXI.Sprite.prototype["_onTextureUpdate"] = (function (_super) {
                    return function () {
                        this.game.renderState = 2;
                        return _super.apply(this, arguments);
                    };
                })(PIXI.Sprite.prototype["_onTextureUpdate"]);
                PIXI.Text.prototype["game"] = game;
                PIXI.Text.prototype["updateTexture"] = (function (_super) {
                    return function () {
                        this.game.renderState = 2;
                        return _super.apply(this, arguments);
                    };
                })(PIXI.Text.prototype["updateTexture"]);
                PIXI.DisplayObject.prototype["game"] = game;
                Object.defineProperty(PIXI.DisplayObject.prototype, "alpha", {
                    set: function (value) {
                        if (this.worldVisible)
                            this.game.renderState = 2;
                        this._alpha = value;
                    },
                    get: function () {
                        return this._alpha;
                    }
                });
                Object.defineProperty(PIXI.DisplayObject.prototype, "rotation", {
                    set: function (value) {
                        if (this.worldVisible)
                            this.game.renderState = 2;
                        this.transform.rotation = value;
                    },
                    get: function () {
                        return this.transform.rotation;
                    }
                });
                Object.defineProperty(PIXI.DisplayObject.prototype, "scale", {
                    set: function (value) {
                        if (this.worldVisible)
                            this.game.renderState = 2;
                        this.transform.scale.copy(value);
                    },
                    get: function () {
                        return this.transform.scale;
                    }
                });
                Object.defineProperty(PIXI.DisplayObject.prototype, "skew", {
                    set: function (value) {
                        if (this.worldVisible)
                            this.game.renderState = 2;
                        this.transform.skew.copy(value);
                    },
                    get: function () {
                        return this.transform.skew;
                    }
                });
                PIXI.TransformStatic.prototype["game"] = game;
                PIXI.TransformStatic.prototype["onChange"] = (function (_super) {
                    return function () {
                        this.game.renderState = 2;
                        return _super.apply(this, arguments);
                    };
                })(PIXI.TransformStatic.prototype["onChange"]);
                if (parseInt(PIXI.VERSION.split(".").join("")) < 452) {
                    game.renderer["plugins"].interaction.on("pointermove", function () { return game.renderState = 2; });
                }
                game.renderer["plugins"].interaction.on("mousedown", function () { return game.renderState = 2; });
                game.renderer["plugins"].interaction.on("mouseup", function () { return game.renderState = 2; });
                game.renderer["plugins"].interaction.on("mousemove", function () { return game.renderState = 2; });
                game.renderer["plugins"].interaction.on("touchstart", function () { return game.renderState = 2; });
                game.renderer["plugins"].interaction.on("touchend", function () { return game.renderState = 2; });
                game.renderer["plugins"].interaction.on("touchmove", function () { return game.renderState = 2; });
            };
            Render.type = gf.RENDER_TYPE_DEFAULT;
            return Render;
        }());
        utils.Render = Render;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Resolution = (function () {
            function Resolution() {
            }
            Resolution.getResolution = function () {
                var mediaQuery = "(-webkit-min-device-pixel-ratio: 1.5), (min--moz-device-pixel-ratio: 1.5), (-o-min-device-pixel-ratio: 3/2), (min-resolution: 1.5dppx)";
                if (window.devicePixelRatio > 1) {
                    return 2;
                }
                if (window.matchMedia && window.matchMedia(mediaQuery).matches) {
                    return 2;
                }
                return 1;
            };
            return Resolution;
        }());
        utils.Resolution = Resolution;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Storage = (function (_super) {
            __extends(Storage, _super);
            function Storage(game) {
                var _this = _super.call(this) || this;
                _this._dataLocal = {};
                _this._dataServer = {};
                _this._pending = [];
                _this._running = false;
                _this._dataFetched = false;
                _this.checkIfSupported();
                _this.game = game;
                _this.game.user.on(gf.LOGIN, _this.getData, _this);
                _this.game.user.on(gf.LOGOUT, function () {
                    _this._dataFetched = false;
                    _this.clear(function () { return _this.getData(); });
                }, _this);
                return _this;
            }
            Storage.prototype.checkIfSupported = function () {
                this._isSupported = false;
                try {
                    var key = "kr3mTest89476";
                    localStorage.setItem(key, "xyz");
                    localStorage.getItem(key);
                    localStorage.removeItem(key);
                    this._isSupported = true;
                }
                catch (e) {
                }
            };
            Storage.prototype.getData = function (dispatch, callback, forceLocal) {
                var _this = this;
                if (dispatch === void 0) { dispatch = true; }
                if (forceLocal === void 0) { forceLocal = false; }
                this._dataFetched = false;
                if (!this.isSupported) {
                    this._dataLocal = {};
                }
                else {
                    var decoded = localStorage.getItem(this.game.client.config.appName);
                    if (decoded && window.atob)
                        decoded = window.atob(decoded);
                    else
                        decoded = "{}";
                    this._dataLocal = JSON.parse(decoded);
                }
                if (this.game.client.config.useCAS && navigator.onLine && !forceLocal) {
                    var timeout_1 = setTimeout(function () {
                        _this.getData(dispatch, callback, true);
                    }, 10000);
                    casClient.getCookie(this.game.client.config.appName, function (cookie) {
                        clearTimeout(timeout_1);
                        _this._dataServer = cookie || {};
                        _this._dataFetched = true;
                        if (dispatch) {
                            _this.emit(gf.DATA, _this._dataServer, _this._dataLocal);
                        }
                        if (callback) {
                            callback(_this._dataServer, _this._dataLocal);
                        }
                    });
                }
                else {
                    this._dataFetched = true;
                    if (dispatch) {
                        this.emit(gf.DATA, this._dataServer, this._dataLocal);
                    }
                    if (callback) {
                        callback(this._dataServer, this._dataLocal);
                    }
                }
            };
            Storage.prototype.clear = function (callback) {
                this._dataLocal = {};
                this._dataServer = {};
                if (this.isSupported) {
                    var encoded = JSON.stringify(this._dataLocal);
                    if (window.btoa)
                        encoded = window.btoa(encoded);
                    localStorage.setItem(this.game.client.config.appName, encoded);
                }
                if (this.game.client.config.useCAS && navigator.onLine) {
                    casClient.setCookie(this.game.client.config.appName, this._dataServer, function () {
                        if (callback) {
                            callback();
                        }
                    });
                }
                else {
                    if (callback) {
                        callback();
                    }
                }
            };
            Storage.prototype.getItem = function (key, localData) {
                if (localData === void 0) { localData = false; }
                return localData ? this._dataLocal[key] : this._dataServer[key];
            };
            Storage.prototype.setItem = function (key, value, callback) {
                if (typeof key === "string") {
                    this._dataLocal[key] = value;
                    this._dataServer[key] = value;
                }
                else {
                    for (var i = 0; i < key.length; ++i) {
                        this._dataLocal[key[i]] = value[i];
                        this._dataServer[key[i]] = value[i];
                    }
                }
                if (this.isSupported) {
                    var encoded = JSON.stringify(this._dataLocal);
                    if (window.btoa)
                        encoded = window.btoa(encoded);
                    localStorage.setItem(this.game.client.config.appName, encoded);
                }
                if (this.game.client.config.useCAS && navigator.onLine) {
                    if (this._running) {
                        this._pending.push(callback);
                    }
                    else {
                        this.flush(callback);
                    }
                }
                else {
                    if (callback)
                        callback();
                }
            };
            Storage.prototype.flush = function (callback) {
                var _this = this;
                this._running = true;
                casClient.setCookie(this.game.client.config.appName, this._dataServer, function () {
                    if (_this._pending.length > 0) {
                        callback = _this._pending.shift();
                        _this.flush(callback);
                    }
                    else {
                        _this._running = false;
                    }
                    if (callback)
                        callback();
                });
            };
            Storage.prototype.updateItem = function (key, value, callback) {
                this.setItem(key, $.extend({}, this.getItem(key), value), callback);
            };
            Object.defineProperty(Storage.prototype, "dataServer", {
                get: function () {
                    return this._dataServer;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Storage.prototype, "dataLocal", {
                get: function () {
                    return this._dataLocal;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Storage.prototype, "dataFetched", {
                get: function () {
                    return this._dataFetched;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Storage.prototype, "isSupported", {
                get: function () {
                    return this._isSupported;
                },
                enumerable: true,
                configurable: true
            });
            return Storage;
        }(PIXI.utils.EventEmitter));
        utils.Storage = Storage;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Game = (function (_super) {
            __extends(Game, _super);
            function Game(client) {
                var _this = _super.call(this) || this;
                _this._client = client;
                _this._isFocused = true;
                _this.setCanvas();
                _this.setRenderer();
                _this.user = new gf.model.User(_this);
                _this.cache = new gf.core.Cache(_this);
                _this.loader = new gf.core.Loader(_this);
                _this.scale = new gf.core.Scale(_this);
                _this.stage = new gf.core.Stage(_this);
                _this.storage = new gf.utils.Storage(_this);
                _this.episodes = new gf.model.Episodes(_this);
                _this.levels = new gf.model.Levels(_this);
                _this.screens = new gf.core.Screens(_this);
                _this.overlays = new gf.core.Overlays(_this);
                _this.sounds = new gf.core.Sounds(_this);
                _this.ticker = PIXI.ticker.shared;
                return _this;
            }
            Game.prototype.run = function () {
                this.user.progress = new gf.model.Progress(this);
                this.user.lives = new gf.model.Lives(this);
                this.screens.init();
                this.stage.addFooter();
                this.stage.addHeader();
                this.overlays.init();
                this.scale.init();
                this.episodes.init();
                this.levels.init();
                this.storage.getData();
                this.client.config.onRun(this);
                this.emit(gf.RUNNING);
            };
            Game.prototype.setCanvas = function () {
                var _this = this;
                if (document.hidden !== undefined)
                    document.addEventListener("visibilitychange", function (e) { return _this.onVisibilityChange(e); });
                else if (document["mozHidden"] !== undefined)
                    document.addEventListener("mozvisibilitychange", function (e) { return _this.onVisibilityChange(e); });
                else if (document["webkitHidden"] !== undefined)
                    document.addEventListener("webkitvisibilitychange", function (e) { return _this.onVisibilityChange(e); });
                else if (document["msHidden"] !== undefined)
                    document.addEventListener("msvisibilitychange", function (e) { return _this.onVisibilityChange(e); });
                else if (document["onfocusin"] !== undefined)
                    document["onfocusin"] = document["onfocusout"] = function (e) { return _this.onVisibilityChange(e); };
                else
                    window.onpageshow = window.onpagehide = window.onfocus = window.onblur = function (e) { return _this.onVisibilityChange(e); };
                this.canvas = document.getElementById(this.client.config.canvasDomId);
                setInterval(function () { return _this.onVisibilityChange(); }, 1000);
            };
            Game.prototype.onVisibilityChange = function (e) {
                if (e === void 0) { e = null; }
                if (e && e.type && (e.type === "pagehide" || e.type === "blur" || e.type === "pageshow" || e.type === "focus")) {
                    if (e.type === "pagehide" || e.type === "blur") {
                        this.blur();
                    }
                    else if (e.type === "pageshow" || event.type === "focus") {
                        this.focus();
                    }
                    return;
                }
                if (document.hidden || document["mozHidden"] || document["msHidden"] || document["webkitHidden"])
                    this.blur();
                else
                    this.focus();
            };
            Game.prototype.blur = function () {
                if (this._isFocused) {
                    this._isFocused = false;
                    this.emit(gf.BLUR);
                }
            };
            Game.prototype.focus = function () {
                if (!this._isFocused) {
                    this._isFocused = true;
                    this.emit(gf.FOCUS);
                    this.emit(gf.RESIZE);
                }
            };
            Game.prototype.setRenderer = function () {
                PIXI.utils.skipHello();
                var options = {};
                options.antialias = false;
                options.autoResize = true;
                options.resolution = this.client.config.resolution;
                options.roundPixels = this.client.config.roundPixels;
                options.transparent = this.client.config.transparent;
                options.view = this.canvas;
                options.clearBeforeRender = true;
                PIXI.glCore.VertexArrayObject.FORCE_NATIVE = true;
                PIXI.settings.CAN_UPLOAD_SAME_BUFFER = false;
                PIXI.settings.SPRITE_MAX_TEXTURES = 2;
                if (this.client.config.forceWebGL)
                    this.renderer = new PIXI.WebGLRenderer(300, 200, options);
                else if (this.client.config.forceCanvas)
                    this.renderer = new PIXI.CanvasRenderer(300, 200, options);
                else
                    this.renderer = PIXI.autoDetectRenderer(300, 200, options);
                if (this.client.config.renderType === gf.RENDER_TYPE_ON_CHANGE)
                    gf.utils.Render.onChange(this);
                PIXI.ticker.shared.add(this.update, this);
            };
            Game.prototype.start = function () {
                var _this = this;
                if (this.client.config.useCAS) {
                    this.user.getLoginStatus(function () { return _this.run(); });
                }
                else {
                    this.run();
                }
            };
            Game.prototype.resize = function () {
                this.emit(gf.RESIZE);
            };
            Game.prototype.update = function () {
                if (gf.utils.Render.type === gf.RENDER_TYPE_ON_CHANGE) {
                    if (this.renderState != 1) {
                        this.renderer.render(this.stage);
                        this.renderState = 1;
                    }
                }
                else {
                    this.renderer.render(this.stage);
                }
            };
            Object.defineProperty(Game.prototype, "height", {
                get: function () {
                    return this.scale.height;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "width", {
                get: function () {
                    return this.scale.width;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "scaleX", {
                get: function () {
                    return this.stage.scaleX;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "scaleY", {
                get: function () {
                    return this.stage.scaleY;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "client", {
                get: function () {
                    return this._client;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "landscape", {
                get: function () {
                    return this.scale.isLandscape;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "portrait", {
                get: function () {
                    return !this.landscape;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Game.prototype, "isFocused", {
                get: function () {
                    return this._isFocused;
                },
                enumerable: true,
                configurable: true
            });
            return Game;
        }(PIXI.utils.EventEmitter));
        core.Game = Game;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var core;
    (function (core) {
        var Loader = (function (_super) {
            __extends(Loader, _super);
            function Loader(game) {
                var _this = _super.call(this) || this;
                _this._XDomainRequestFailedOnce = false;
                _this.game = game;
                _this._isLoading = false;
                _this._hasLoaded = false;
                _this.crossOrigin = false;
                _this._fileList = [];
                _this._flightQueue = [];
                _this._processingHead = 0;
                _this._fileLoadStarted = false;
                _this._totalFileCount = 0;
                _this._loadedFileCount = 0;
                return _this;
            }
            Loader.prototype.processLoadQueue = function () {
                var _this = this;
                if (!this._isLoading) {
                    this.finishedLoading(true);
                    return;
                }
                var file;
                var i;
                for (i = 0; i < this._flightQueue.length; ++i) {
                    file = this._flightQueue[i];
                    if (file.loaded || file.error) {
                        this._flightQueue.splice(i, 1);
                        i--;
                        file.loading = false;
                        file.requestUrl = null;
                        file.requestObject = null;
                        if (file.error) {
                            this.emit(gf.LOAD_ERROR, file.key, file);
                            this.loadTest("error");
                        }
                        this._loadedFileCount++;
                        this.emit(gf.LOAD_PROGRESS, file.key, !file.error, this._loadedFileCount, this._totalFileCount);
                    }
                }
                var syncblock = false;
                for (i = this._processingHead; i < this._fileList.length; i++) {
                    file = this._fileList[i];
                    if (file.loaded || file.error) {
                        if (i === this._processingHead) {
                            this._processingHead = i + 1;
                        }
                    }
                    else if (!file.loading && this._flightQueue.length < 4) {
                        if (!syncblock) {
                            if (!this._fileLoadStarted) {
                                this._fileLoadStarted = true;
                            }
                            this._flightQueue.push(file);
                            file.loading = true;
                            this.loadFile(file);
                        }
                    }
                    if (!file.loaded && file.syncPoint) {
                        syncblock = true;
                    }
                }
                if (this._processingHead >= this._fileList.length) {
                    this.finishedLoading();
                }
                else if (!this._flightQueue.length) {
                    logWarning("gf.core.Loader - aborting: processing queue empty, loading may have stalled");
                    setTimeout(function () {
                        _this.finishedLoading(true);
                    }, 2000);
                }
            };
            Loader.prototype.loadTest = function (endType) {
                try {
                    if (parent && (parent.location.href == window.location.href + "loadtest.html")) {
                        if (!window.hasOwnProperty("_kr3m_LT_"))
                            window["_kr3m_LT_"] = { error: 0, complete: false };
                        if (endType == "error")
                            window["_kr3m_LT_"].error += 1;
                        else if (endType == "complete")
                            window["_kr3m_LT_"].complete = true;
                    }
                }
                catch (e) {
                }
            };
            Loader.prototype.finishedLoading = function (abnormal) {
                if (abnormal === void 0) { abnormal = false; }
                if (this._hasLoaded) {
                    return;
                }
                this._hasLoaded = true;
                this._isLoading = false;
                if (!abnormal && !this._fileLoadStarted) {
                    this._fileLoadStarted = true;
                }
                this.reset();
                this.emit(gf.LOAD_COMPLETE);
                this.loadTest("complete");
            };
            Loader.prototype.asyncComplete = function (file, errorMessage) {
                if (errorMessage === void 0) { errorMessage = ""; }
                file.loaded = true;
                file.error = !!errorMessage;
                if (errorMessage) {
                    file.errorMessage = errorMessage;
                    logWarning("gf.core.Loader - " + file.type + "[" + file.key + "]" + ": " + errorMessage);
                }
                this.processLoadQueue();
            };
            Loader.prototype.transformUrl = function (url) {
                url += (url.indexOf("?") == -1 ? "?" : "&") + "_=" + this.game.client.config.version;
                return url;
            };
            Loader.prototype.loadFile = function (file) {
                var _this = this;
                switch (file.type) {
                    case "image":
                    case "textureatlas":
                    case "bitmapfont":
                    case "svg":
                        file.url = this.transformUrl(file.url);
                        this.loadImageTag(file);
                        break;
                    case "woff":
                        var style = '<style type="text/css">@font-face {font-family:"' + file.key + '"; src:url("' + file.url + '") format("woff");}</style>';
                        $(style).appendTo("head");
                        WebFont.load({
                            custom: {
                                families: [file.key]
                            },
                            fontactive: function () {
                                _this.fileComplete(file);
                            },
                            fontinactive: function () {
                                _this.fileComplete(file);
                            }
                        });
                        break;
                    case "audioatlas":
                        file.url = this.transformUrl(file.url);
                        this.xhrLoad(file, file.url, "arraybuffer", "fileComplete");
                        break;
                    case "audio":
                        if (file.url) {
                            file.url = this.transformUrl(file.url);
                            this.xhrLoad(file, file.url, "arraybuffer", "fileComplete");
                        }
                        else {
                            this.fileError(file, null, "no supported audio URL specified");
                        }
                        break;
                    case "video":
                        this.xhrLoad(file, file.url, "arraybuffer", "videoBufferLoaded");
                        break;
                    case "script":
                        this.xhrLoad(file, this.transformUrl(file.url), "text", "fileComplete");
                        break;
                    case "json":
                        file.url = this.transformUrl(file.url);
                        this.xhrLoad(file, file.url, "text", "jsonLoadComplete");
                        break;
                    case "xml":
                        file.url = this.transformUrl(file.url);
                        this.xhrLoad(file, file.url, "text", "xmlLoadComplete");
                        break;
                }
            };
            Loader.prototype.videoBufferLoaded = function (file, xhr) {
                file.data = PIXI.Texture.fromVideoUrl(file.url);
                this.fileComplete(file, xhr);
            };
            Loader.prototype.loadImageTag = function (file) {
                var _this = this;
                file.data = new Image();
                file.data.name = file.key;
                if (this.crossOrigin) {
                    file.data.crossOrigin = this.crossOrigin;
                }
                file.data.onload = function () {
                    if (file.data.onload) {
                        file.data.onload = null;
                        file.data.onerror = null;
                        _this.fileComplete(file);
                    }
                };
                file.data.onerror = function () {
                    if (file.data.onload) {
                        file.data.onload = null;
                        file.data.onerror = null;
                        _this.fileError(file);
                    }
                };
                file.data.src = file.url;
                if (file.data.complete && file.data.width && file.data.height) {
                    file.data.onload = null;
                    file.data.onerror = null;
                    this.fileComplete(file);
                }
            };
            Loader.prototype.xhrLoadWithXDR = function (file, url, type, onload, onerror) {
                var _this = this;
                var xhr = new window["XDomainRequest"]();
                xhr.open("GET", url, true);
                xhr.responseType = type;
                xhr.timeout = 3000;
                onerror = onerror || "fileError";
                xhr.onerror = function () {
                    if (Loader.retryWithXhrLoad) {
                        log("Fallback to xhrLoad:" + url);
                        _this._XDomainRequestFailedOnce = true;
                        _this.xhrLoad(file, url, type, onload, onerror);
                    }
                    else {
                        try {
                            return _this[onerror](file, xhr);
                        }
                        catch (e) {
                            _this.asyncComplete(file, e.message || "Exception");
                        }
                    }
                };
                xhr.ontimeout = function () {
                    try {
                        return _this[onerror](file, xhr);
                    }
                    catch (e) {
                        _this.asyncComplete(file, e.message || "Exception");
                    }
                };
                xhr.onprogress = function () {
                };
                xhr.onload = function () {
                    try {
                        return _this[onload](file, xhr);
                    }
                    catch (e) {
                        _this.asyncComplete(file, e.message || "Exception");
                    }
                };
                file.requestObject = xhr;
                file.requestUrl = url;
                setTimeout(function () {
                    xhr.send();
                }, 0);
            };
            Loader.prototype.xhrLoad = function (file, url, type, onload, onerror) {
                var _this = this;
                if (this._XDomainRequestFailedOnce == false) {
                    if (!!(window["XDomainRequest"] && !("withCredentials" in (new XMLHttpRequest())))) {
                        this.xhrLoadWithXDR(file, url, type, onload, onerror);
                        return;
                    }
                }
                var xhr = new XMLHttpRequest();
                xhr.open("GET", url, true);
                xhr.withCredentials = true;
                xhr.responseType = type;
                onerror = onerror || "fileError";
                xhr.onload = function () {
                    return _this[onload](file, xhr);
                };
                xhr.onerror = function () {
                    try {
                        return _this[onerror](file, xhr);
                    }
                    catch (e) {
                        if (!_this._hasLoaded) {
                            _this.asyncComplete(file, e.message || "Exception");
                        }
                        else {
                            logDebug(e, file);
                        }
                    }
                };
                file.requestObject = xhr;
                file.requestUrl = url;
                xhr.send();
            };
            Loader.prototype.fileError = function (file, xhr, reason) {
                if (reason === void 0) { reason = ""; }
                var url = file.requestUrl || this.transformUrl(file.url);
                var message = "Error loading file from URL " + url;
                if (!reason && xhr) {
                    reason = xhr.status.toString();
                }
                if (reason) {
                    message = message + " (" + reason + ")";
                }
                this.asyncComplete(file, message);
            };
            Loader.prototype.fileComplete = function (file, xhr) {
                var _this = this;
                var loadNext = true;
                switch (file.type) {
                    case "image":
                        this.game.cache.addImage(file.key, file.url, file.data);
                        break;
                    case "svg":
                        this.game.cache.addSVG(file.key, file.url, file.data);
                        break;
                    case "woff":
                        break;
                    case "audioatlas":
                        loadNext = false;
                        file.atlasURL = this.transformUrl(file.atlasURL);
                        this.xhrLoad(file, file.atlasURL, "text", "jsonLoadComplete");
                        break;
                    case "script":
                        file.data = document.createElement("script");
                        file.data.language = "javascript";
                        file.data.type = "text/javascript";
                        file.data.defer = false;
                        file.data.text = xhr.responseText;
                        document.head.appendChild(file.data);
                        break;
                    case "textureatlas":
                        if (file.atlasURL == null) {
                            this.game.cache.addTextureAtlas(file.key, file.url, file.data, file.atlasData);
                        }
                        else {
                            loadNext = false;
                            file.atlasURL = this.transformUrl(file.atlasURL);
                            this.xhrLoad(file, file.atlasURL, "text", "jsonLoadComplete");
                        }
                        break;
                    case "bitmapfont":
                        if (!file.xmlURL) {
                            this.game.cache.addBitmapFont(file.key, file.url, file.data, file.xmlData);
                        }
                        else {
                            loadNext = false;
                            file.xmlURL = this.transformUrl(file.xmlURL);
                            this.xhrLoad(file, file.xmlURL, "text", "xmlLoadComplete");
                        }
                        break;
                    case "audio":
                        loadNext = false;
                        file.data = xhr.response;
                        this.game.cache.addSound(file.key, file.url, file.data);
                        this.game.sounds.addSound(file.key, file.soundType, function () {
                            _this.asyncComplete(file);
                        });
                        break;
                    case "video":
                        this.game.cache.addVideo(file.key, file.data);
                        break;
                }
                if (loadNext) {
                    this.asyncComplete(file);
                }
            };
            Loader.prototype.jsonLoadComplete = function (file, xhr) {
                var _this = this;
                var data;
                try {
                    data = JSON.parse(xhr.responseText);
                }
                catch (e) {
                    logError("JSON parse error file " + file.url, e);
                }
                if (file.type === "json") {
                    this.game.cache.addJSON(file.key, file.url, data);
                    this.asyncComplete(file);
                }
                else if (file.type === "audioatlas") {
                    this.game.cache.addSound(file.key, file.url, file.data, data);
                    this.game.sounds.addSound(file.key, file.soundType, function () {
                        _this.asyncComplete(file);
                    });
                }
                else {
                    this.game.cache.addTextureAtlas(file.key, file.url, file.data, data);
                    this.asyncComplete(file);
                }
            };
            Loader.prototype.addToFileList = function (type, key, url, properties, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                var file = new gf.core.File();
                file.type = type;
                file.key = key;
                file.url = url;
                file.data = null;
                file.loading = false;
                file.loaded = false;
                file.error = false;
                if (properties) {
                    for (var prop in properties) {
                        file[prop] = properties[prop];
                    }
                }
                var fileIndex = this.getAssetIndex(type, key);
                if (overwrite && fileIndex > -1) {
                    var currentFile = this._fileList[fileIndex];
                    if (!currentFile.loading && !currentFile.loaded) {
                        this._fileList[fileIndex] = file;
                    }
                    else {
                        this._fileList.push(file);
                        this._totalFileCount++;
                    }
                }
                else if (fileIndex === -1) {
                    this._fileList.push(file);
                    this._totalFileCount++;
                }
            };
            Loader.prototype.checkKeyExists = function (type, key) {
                return this.getAssetIndex(type, key) > -1;
            };
            Loader.prototype.getAssetIndex = function (type, key) {
                var bestFound = -1;
                for (var i = 0; i < this._fileList.length; i++) {
                    var file = this._fileList[i];
                    if (file.type === type && file.key === key) {
                        bestFound = i;
                        if (!file.loaded && !file.loading) {
                            break;
                        }
                    }
                }
                return bestFound;
            };
            Loader.prototype.reset = function (clearEvents) {
                if (clearEvents === void 0) { clearEvents = false; }
                this._isLoading = false;
                this._processingHead = 0;
                this._fileList.length = 0;
                this._flightQueue.length = 0;
                this._fileLoadStarted = false;
                this._totalFileCount = 0;
                this._loadedFileCount = 0;
                if (clearEvents) {
                    this.removeAllListeners(gf.LOAD_COMPLETE);
                    this.removeAllListeners(gf.LOAD_ERROR);
                    this.removeAllListeners(gf.LOAD_PROGRESS);
                }
            };
            Loader.prototype.script = function (key, url) {
                this.addToFileList("script", key, url, { syncPoint: true }, false);
                return this;
            };
            Loader.prototype.image = function (key, url, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                this.addToFileList("image", key, url, undefined, overwrite);
                return this;
            };
            Loader.prototype.json = function (key, url, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                this.addToFileList("json", key, url, undefined, overwrite);
                return this;
            };
            Loader.prototype.svg = function (key, url, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                this.addToFileList("svg", key, url, null, overwrite);
                return this;
            };
            Loader.prototype.xml = function (key, url, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                this.addToFileList("xml", key, url, null, overwrite);
                return this;
            };
            Loader.prototype.audio = function (key, url, soundType) {
                if (soundType === void 0) { soundType = gf.SOUND_MUSIC; }
                this.addToFileList("audio", key, url, { buffer: null, soundType: soundType });
                return this;
            };
            Loader.prototype.audiosprite = function (key, url, atlasURL, soundType) {
                if (soundType === void 0) { soundType = gf.SOUND_FX; }
                this.addToFileList("audioatlas", key, url, { atlasURL: atlasURL, soundType: soundType });
                return this;
            };
            Loader.prototype.bitmapFont = function (key, textureURL, xmlURL, xmlData) {
                if (xmlURL) {
                    this.addToFileList("bitmapfont", key, textureURL, {
                        xmlURL: xmlURL,
                    });
                }
                else {
                    if (typeof xmlData === "string") {
                        var xml = gf.utils.Parser.XML(xmlData);
                        if (!xml) {
                            throw new Error("gf.core.Loader. Invalid Bitmap Font XML given");
                        }
                        this.addToFileList("bitmapfont", key, textureURL, {
                            xmlURL: null,
                            xmlData: xml,
                        });
                    }
                }
                return this;
            };
            Loader.prototype.woff = function (key, url, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                this.addToFileList("woff", key, url, null, overwrite);
                return this;
            };
            Loader.prototype.video = function (key, url, overwrite) {
                if (overwrite === void 0) { overwrite = false; }
                this.addToFileList("video", key, url, null, overwrite);
                return this;
            };
            Loader.prototype.atlas = function (key, textureURL, atlasURL, atlasData) {
                if (atlasURL) {
                    this.addToFileList("textureatlas", key, textureURL, { atlasURL: atlasURL });
                }
                else {
                    atlasData = JSON.parse(atlasData);
                    this.addToFileList("textureatlas", key, textureURL, {
                        atlasURL: null,
                        atlasData: atlasData
                    });
                }
                return this;
            };
            Loader.prototype.removeAll = function () {
                this._fileList.length = 0;
                this._flightQueue.length = 0;
            };
            Loader.prototype.start = function () {
                if (this._isLoading) {
                    return;
                }
                this._hasLoaded = false;
                this._isLoading = true;
                this.processLoadQueue();
            };
            Object.defineProperty(Loader.prototype, "totalLoadedFiles", {
                get: function () {
                    return this._loadedFileCount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Loader.prototype, "totalQueuedFiles", {
                get: function () {
                    return this._totalFileCount - this._loadedFileCount;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Loader.prototype, "progressFloat", {
                get: function () {
                    var progress = (this._loadedFileCount / this._totalFileCount) * 100;
                    return gf.utils.Maths.clamp(progress || 0, 0, 100);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Loader.prototype, "progress", {
                get: function () {
                    return Math.round(this.progressFloat);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Loader.prototype, "hasLoaded", {
                get: function () {
                    return this._hasLoaded;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Loader.prototype, "isLoading", {
                get: function () {
                    return this._isLoading;
                },
                enumerable: true,
                configurable: true
            });
            Loader.retryWithXhrLoad = false;
            return Loader;
        }(PIXI.utils.EventEmitter));
        core.Loader = Loader;
        var File = (function () {
            function File() {
            }
            return File;
        }());
        core.File = File;
        var Asset = (function () {
            function Asset(index, file) {
                this.index = index;
                this.file = file;
            }
            return Asset;
        }());
        core.Asset = Asset;
    })(core = gf.core || (gf.core = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var AssetLoader = (function (_super) {
            __extends(AssetLoader, _super);
            function AssetLoader(game, assets) {
                var _this = _super.call(this, game) || this;
                _this.assets = assets;
                _this.on(gf.LOAD_COMPLETE, _this.onComplete, _this);
                return _this;
            }
            AssetLoader.prototype.onComplete = function () {
                this.game.overlays.hide("loader");
                this._loaded = true;
            };
            AssetLoader.prototype.loadFile = function (file) {
                var _this = this;
                switch (file.type) {
                    case "threeJSON":
                        new THREE.JSONLoader().load(file.url, function (geometry, materials) {
                            file.geometry = geometry;
                            file.materials = materials;
                            _this.fileComplete(file);
                        });
                        break;
                    case "texture":
                        new THREE.TextureLoader().load(file.url, function (texture) {
                            file.texture = texture;
                            _this.fileComplete(file);
                        });
                        break;
                    case "cubeTexture":
                        new THREE.CubeTextureLoader().load(file.url, function (texture) {
                            file.texture = texture;
                            _this.fileComplete(file);
                        });
                        break;
                    default:
                        _super.prototype.loadFile.call(this, file);
                        break;
                }
            };
            AssetLoader.prototype.fileComplete = function (file, xhr) {
                var callAsyncComplete = true;
                switch (file.type) {
                    case "threeJSON":
                        this.assets.addThreeJSON(file.key, file.url, file.geometry, file.materials);
                        break;
                    case "texture":
                        this.assets.addTexture(file.key, file.url, file.texture);
                        break;
                    case "cubeTexture":
                        this.assets.addTexture(file.key, file.url, file.texture);
                        break;
                    default:
                        callAsyncComplete = false;
                        _super.prototype.fileComplete.call(this, file, xhr);
                        break;
                }
                if (callAsyncComplete) {
                    this.asyncComplete(file);
                }
            };
            AssetLoader.prototype.threeJSON = function (key, url) {
                this.addToFileList("threeJSON", key, url);
            };
            AssetLoader.prototype.texture = function (key, url) {
                this.addToFileList("texture", key, url);
            };
            AssetLoader.prototype.cubeTexture = function (key, url) {
                this.addToFileList("cubeTexture", key, url);
            };
            AssetLoader.prototype.start = function () {
                this.game.overlays.show("loader");
                _super.prototype.start.call(this);
            };
            Object.defineProperty(AssetLoader.prototype, "loaded", {
                get: function () {
                    return this._loaded;
                },
                enumerable: true,
                configurable: true
            });
            return AssetLoader;
        }(gf.core.Loader));
        core.AssetLoader = AssetLoader;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Assets = (function () {
            function Assets(playground) {
                this.playground = playground;
                this.materials = {};
                this.textures = {};
                this.threeJSON = {};
            }
            Assets.prototype.getMesh = function (key) {
                return this.threeJSON[key].mesh.clone();
            };
            Assets.prototype.getMaterial = function (key) {
                var materialParameters = {};
                materialParameters.color = 0xffffff;
                materialParameters.map = this.getTexture(key);
                materialParameters.opacity = this.playground.cubeOpacity;
                materialParameters.flatShading = true;
                materialParameters.side = THREE.DoubleSide;
                materialParameters.transparent = true;
                materialParameters.reflectivity = 0;
                return new THREE.MeshLambertMaterial(materialParameters);
            };
            Assets.prototype.getColorMaterial = function (color) {
                var materialParameters = {};
                materialParameters.color = color;
                materialParameters.opacity = 1;
                materialParameters.flatShading = true;
                materialParameters.transparent = false;
                materialParameters.reflectivity = 0;
                return new THREE.MeshLambertMaterial(materialParameters);
            };
            Assets.prototype.getBody = function (mesh) {
                var vertice;
                var vertices = [];
                var face;
                var faces = [];
                var j;
                for (j = 0; j < mesh.geometry.vertices.length; ++j) {
                    vertice = mesh.geometry.vertices[j];
                    vertices.push(vertice.x, vertice.y, vertice.z);
                }
                for (j = 0; j < mesh.geometry.faces.length; ++j) {
                    face = mesh.geometry.faces[j];
                    faces.push(face.a, face.b, face.c);
                }
                var body = new CANNON.Body({ mass: 0 });
                body.addShape(new CANNON.Trimesh(vertices, faces));
                return body;
            };
            Assets.prototype.getTexture = function (key) {
                return this.textures[key].texture;
            };
            Assets.prototype.addTexture = function (key, url, texture) {
                this.textures[key] = { url: url, texture: texture };
            };
            Assets.prototype.addThreeJSON = function (key, url, geometry, materials) {
                var mesh = new THREE.Mesh(geometry);
                this.threeJSON[key] = { geometry: geometry, materials: materials, url: url, mesh: mesh };
            };
            return Assets;
        }());
        core.Assets = Assets;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Canvas = (function () {
            function Canvas(game, onUpdate) {
                var _this = this;
                this.game = game;
                this._onUpdate = onUpdate;
                this._isRunning = false;
                this.view = document.getElementById("playground");
                if ((PIXI.utils.isMobile.tablet || PIXI.utils.isMobile.phone) && !navigator["isCocoonJS"]) {
                    $(window).on("focus", function () {
                        $(_this.view).hide();
                        setTimeout(function () {
                            $(_this.view).show();
                        }, 100);
                    });
                }
                PIXI.ticker.shared.add(function () { return _this.onTick(); }, this);
                var rendererParamaters = {};
                rendererParamaters.canvas = this.view;
                rendererParamaters.alpha = true;
                rendererParamaters.antialias = this.game.client.config.useAntiAlias;
                rendererParamaters.preserveDrawingBuffer = true;
                this.renderer = new THREE.WebGLRenderer(rendererParamaters);
                this.renderer.autoClear = true;
            }
            Canvas.getInstance = function (game, onUpdate) {
                if (!this.instance) {
                    this.instance = new cuboro.core.Canvas(game, onUpdate);
                }
                else {
                    this.instance._onUpdate = onUpdate;
                }
                return this.instance;
            };
            Canvas.prototype.onTick = function () {
                if (!this._isRunning || this._isPaused)
                    return;
                this._onUpdate(PIXI.ticker.shared.elapsedMS);
            };
            Canvas.prototype.pause = function () {
                this._isPaused = true;
            };
            Canvas.prototype.resume = function () {
                this._isPaused = false;
            };
            Canvas.prototype.start = function () {
                if (this._isRunning)
                    return;
                this._isRunning = true;
                this.resume();
                this.onResize();
            };
            Canvas.prototype.stop = function () {
                if (!this._isRunning)
                    return;
                this._isRunning = false;
                this.pause();
                this.renderer.clear();
            };
            Canvas.prototype.onResize = function () {
                var resolution = 1;
                if (this.game.renderer.resolution > 1)
                    resolution = this.game.client.config.assetsResolution;
                this.renderer.setSize(this.game.scale.parentWidth * resolution, this.game.scale.parentHeight * resolution);
                this.view.style.width = this.game.scale.styleSize.x + 'px';
                this.view.style.height = this.game.scale.styleSize.y + 'px';
            };
            return Canvas;
        }());
        core.Canvas = Canvas;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        core.STATE_NONE = -1;
        core.STATE_ROTATE = 0;
        core.STATE_ZOOM = 1;
        core.STATE_PAN = 2;
        var Controls = (function () {
            function Controls(playground, settings) {
                this._pos = new THREE.Vector3();
                this.playground = playground;
                this.settings = settings;
                this._mouse = new THREE.Vector2(0, 0);
                this._lastMouse = new THREE.Vector2(0, 0);
                this._state = core.STATE_NONE;
                this._panStart = new THREE.Vector2();
                this._panEnd = new THREE.Vector2();
                this._panDelta = new THREE.Vector2();
                this._minPan = new THREE.Vector3(-10, -10, -10);
                this._maxPan = new THREE.Vector3(10, 10, 10);
                this._pan = new THREE.Vector3();
                this.canPan = true;
                this.canRotate = true;
                this.canZoom = true;
                this._distance = this.settings.distance;
                this._panAngle = this.settings.panAngle;
                this._tiltAngle = this.settings.tiltAngle;
                this.lookAt = this.settings.lookAt.clone();
                this._zoomStart = new THREE.Vector2();
                this._zoomEnd = new THREE.Vector2();
                this._zoomDelta = new THREE.Vector2();
                this._currentPanAngle = this._panAngle;
                this._currentTiltAngle = this._tiltAngle;
                this._lastPanAngle = this._currentPanAngle;
                this._lastTiltAngle = this._currentTiltAngle;
                this.settings.interaction.on("onMouseDown", this.onMouseDown, this);
                this.settings.interaction.on("onMouseMove", this.onMouseMove, this);
                this.settings.interaction.on("onMouseUp", this.onMouseUp, this);
                this.settings.interaction.on("onMouseWheel", this.onMouseWheel, this);
                this.settings.interaction.on("onTouchStart", this.onTouchStart, this);
                this.settings.interaction.on("onTouchMove", this.onTouchMove, this);
                this.settings.interaction.on("onTouchEnd", this.onTouchEnd, this);
                this.enabled = true;
                this.reset();
            }
            Controls.prototype.update = function (interpolate) {
                var _this = this;
                if (interpolate === void 0) { interpolate = false; }
                if (this._tiltAngle != this._currentTiltAngle || this._panAngle != this._currentPanAngle) {
                    if (interpolate) {
                        this._currentTiltAngle += (this._tiltAngle - this._currentTiltAngle) / (this.settings.steps + 1);
                        this._currentPanAngle += (this._panAngle - this._currentPanAngle) / (this.settings.steps + 1);
                    }
                    else {
                        this._currentPanAngle = this._panAngle;
                        this._currentTiltAngle = this._tiltAngle;
                    }
                    if ((Math.abs(this.tiltAngle - this._currentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._currentPanAngle) < 0.01)) {
                        this._currentTiltAngle = this._tiltAngle;
                        this._currentPanAngle = this._panAngle;
                    }
                }
                this._pos.x = this.lookAt.x;
                this._pos.y = this.lookAt.y;
                this._pos.z = this.lookAt.z;
                this.settings.camera.position.x = this._pos.x - this._distance * Math.sin(this._currentPanAngle * PIXI.DEG_TO_RAD) * Math.cos(this._currentTiltAngle * PIXI.DEG_TO_RAD);
                this.settings.camera.position.z = this._pos.z + this._distance * Math.cos(this._currentPanAngle * PIXI.DEG_TO_RAD) * Math.cos(this._currentTiltAngle * PIXI.DEG_TO_RAD);
                this.settings.camera.position.y = this._pos.y + this._distance * Math.sin(this._currentTiltAngle * PIXI.DEG_TO_RAD) * this.settings.yFactor;
                this.settings.camera.lookAt(this.lookAt);
                this.playground.spotLight.position.x = this.settings.camera.position.x - 2;
                this.playground.spotLight.position.y = this.settings.camera.position.y - 2;
                this.playground.spotLight.position.z = this.settings.camera.position.z - 2;
                this.playground.spotLight.target.position.copy(this.lookAt);
                setTimeout(function () { return _this.playground.emit(cuboro.CAMERA_UPDATE); }, 10);
            };
            Controls.prototype.hideMenus = function () {
                this.playground.gameScreen.moveMenu.alpha = 0.25;
                this.playground.gameScreen.rotateMenu.alpha = 0.25;
            };
            Controls.prototype.showMenus = function () {
                this.playground.gameScreen.moveMenu.alpha = 1;
                this.playground.gameScreen.rotateMenu.alpha = 1;
            };
            Controls.prototype.onMouseWheel = function (e) {
                if (!this.canZoom)
                    return;
                var delta = 0;
                if (e.wheelDelta !== undefined) {
                    delta = e.wheelDelta;
                }
                else if (e.detail !== undefined) {
                    delta = -e.detail;
                }
                if (delta > 0) {
                    this.distance *= 0.95;
                }
                else if (delta < 0) {
                    this.distance /= 0.95;
                }
                this.update();
            };
            Controls.prototype.onMouseMove = function (e) {
                if (!this.enabled)
                    return;
                this._mouse.set(e.clientX, e.clientY);
                if (this._state == cuboro.core.STATE_ROTATE) {
                    if (!this.canRotate)
                        return;
                    this.panAngle = 0.3 * (this._mouse.x - this._lastMouse.x) + this._lastPanAngle;
                    this.tiltAngle = 0.3 * (this._mouse.y - this._lastMouse.y) + this._lastTiltAngle;
                    this.update();
                }
                else if (this._state == cuboro.core.STATE_PAN) {
                    if (!this.canPan)
                        return;
                    this._panEnd.set(this._mouse.x, this._mouse.y);
                    this._panDelta.subVectors(this._panEnd, this._panStart);
                    var l = this.settings.camera.position.clone().sub(this.lookAt).length();
                    var targetDistance = l * Math.tan((this.settings.camera.fov * 0.5) * PIXI.DEG_TO_RAD);
                    this.panLeft(2 * this._panDelta.x * targetDistance / this.playground.game.height);
                    this.panUp(2 * this._panDelta.y * targetDistance / this.playground.game.height);
                    this._panStart.copy(this._panEnd);
                    this.lookAt.add(this._pan);
                    this.lookAt.clamp(this._minPan, this._maxPan);
                    this._pan.set(0, 0, 0);
                    this.update();
                }
            };
            Controls.prototype.onMouseDown = function (e) {
                if (!this.enabled)
                    return;
                this.hideMenus();
                this._lastPanAngle = this.panAngle;
                this._lastTiltAngle = this.tiltAngle;
                this._lastMouse.set(e.clientX, e.clientY);
                switch (e.button) {
                    case 0:
                        if (!this.canRotate)
                            return;
                        if (this.playground.gameScreen.bottomMenu.btMoveView.isSelected && this.canPan) {
                            this._state = cuboro.core.STATE_PAN;
                            this._panStart.set(e.clientX, e.clientY);
                        }
                        else {
                            this._state = cuboro.core.STATE_ROTATE;
                        }
                        break;
                    case 2:
                        if (!this.canPan)
                            return;
                        this._state = cuboro.core.STATE_PAN;
                        this._panStart.set(e.clientX, e.clientY);
                        break;
                }
            };
            Controls.prototype.onMouseUp = function () {
                this.showMenus();
                this._state = cuboro.core.STATE_NONE;
                this.playground.emit(cuboro.CAMERA_UPDATED);
            };
            Controls.prototype.onTouchStart = function (e) {
                if (!this.enabled)
                    return;
                this.hideMenus();
                var touchCount = (e.touches) ? e.touches.length : 1;
                var x = (e.touches) ? e.touches[0].pageX : e.clientX;
                var y = (e.touches) ? e.touches[0].pageY : e.clientY;
                switch (touchCount) {
                    case 1:
                        if (this.playground.gameScreen.bottomMenu.btMoveView.isSelected && this.canPan) {
                            this._state = cuboro.core.STATE_PAN;
                            this._panStart.set(x, y);
                        }
                        else if (this.canRotate) {
                            this._state = cuboro.core.STATE_ROTATE;
                            this._lastPanAngle = this.panAngle;
                            this._lastTiltAngle = this.tiltAngle;
                            this._lastMouse.set(x, y);
                        }
                        break;
                    case 2:
                        if (!this.canZoom)
                            return;
                        this._state = cuboro.core.STATE_ZOOM;
                        var dx = x - e.touches[1].pageX;
                        var dy = y - e.touches[1].pageY;
                        var distance = Math.sqrt(dx * dx + dy * dy);
                        this._zoomStart.set(0, distance);
                        break;
                    case 3:
                        if (!this.canPan)
                            return;
                        this._state = cuboro.core.STATE_PAN;
                        this._panStart.set(x, y);
                        break;
                    default:
                        this._state = cuboro.core.STATE_NONE;
                }
            };
            Controls.prototype.onTouchMove = function (e) {
                if (this.enabled === false)
                    return;
                var x = (e.touches) ? e.touches[0].pageX : e.clientX;
                var y = (e.touches) ? e.touches[0].pageY : e.clientY;
                switch (this._state) {
                    case cuboro.core.STATE_ROTATE:
                        if (!this.canRotate)
                            return;
                        this._mouse.set(x, y);
                        this.panAngle = 0.3 * (this._mouse.x - this._lastMouse.x) + this._lastPanAngle;
                        this.tiltAngle = 0.3 * (this._mouse.y - this._lastMouse.y) + this._lastTiltAngle;
                        this.update();
                        break;
                    case cuboro.core.STATE_ZOOM:
                        if (!this.canZoom)
                            return;
                        var dx = x - e.touches[1].pageX;
                        var dy = y - e.touches[1].pageY;
                        var distance = Math.sqrt(dx * dx + dy * dy);
                        this._zoomEnd.set(0, distance);
                        this._zoomDelta.subVectors(this._zoomEnd, this._zoomStart);
                        if (this._zoomDelta.y > 0) {
                            this.distance *= 0.98;
                        }
                        else if (this._zoomDelta.y < 0) {
                            this.distance /= 0.98;
                        }
                        this._zoomStart.copy(this._zoomEnd);
                        this.update();
                        break;
                    case cuboro.core.STATE_PAN:
                        if (!this.canPan)
                            return;
                        this._panEnd.set(x, y);
                        this._panDelta.subVectors(this._panEnd, this._panStart);
                        var l = this.settings.camera.position.clone().sub(this.lookAt).length();
                        var targetDistance = l * Math.tan((this.settings.camera.fov * 0.5) * PIXI.DEG_TO_RAD);
                        this.panLeft(2 * this._panDelta.x * targetDistance / this.playground.game.height);
                        this.panUp(2 * this._panDelta.y * targetDistance / this.playground.game.height);
                        this._panStart.copy(this._panEnd);
                        this.lookAt.add(this._pan);
                        this.lookAt.clamp(this._minPan, this._maxPan);
                        this._pan.set(0, 0, 0);
                        break;
                    default:
                        this._state = cuboro.core.STATE_NONE;
                }
            };
            Controls.prototype.onTouchEnd = function () {
                this.showMenus();
                this._state = cuboro.core.STATE_NONE;
                this.playground.emit(cuboro.CAMERA_UPDATED);
            };
            Controls.prototype.reset = function () {
                this.distance = this.settings.distance;
                this.panAngle = this.settings.panAngle;
                this.tiltAngle = this.settings.tiltAngle;
                this.lookAt = this.settings.lookAt.clone();
                this.update();
            };
            Controls.prototype.panLeft = function (distance) {
                var panOffset = new THREE.Vector3();
                var te = this.settings.camera.matrix.elements;
                panOffset.set(te[0], te[1], te[2]);
                panOffset.multiplyScalar(-distance);
                this._pan.add(panOffset);
                this.lookAt.add(this._pan);
                this.lookAt.clamp(this._minPan, this._maxPan);
                this._pan.set(0, 0, 0);
                this.update();
            };
            Controls.prototype.panUp = function (distance) {
                var panOffset = new THREE.Vector3();
                var te = this.settings.camera.matrix.elements;
                panOffset.set(te[4], te[5], te[6]);
                panOffset.multiplyScalar(distance);
                this._pan.add(panOffset);
                this.lookAt.add(this._pan);
                this.lookAt.clamp(this._minPan, this._maxPan);
                this._pan.set(0, 0, 0);
                this.update();
            };
            Object.defineProperty(Controls.prototype, "isDirectionX", {
                get: function () {
                    var direction = new THREE.Vector3(0, -1, 0);
                    direction.applyQuaternion(this.settings.camera.quaternion);
                    return (Math.abs(direction.x) > Math.abs(direction.z));
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controls.prototype, "direction", {
                get: function () {
                    var direction = new THREE.Vector3(0, -1, 0);
                    direction.applyQuaternion(this.settings.camera.quaternion);
                    if (this.isDirectionX) {
                        return (direction.x * -1) > 0 ? 1 : -1;
                    }
                    else {
                        return direction.z > 0 ? 1 : -1;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controls.prototype, "distance", {
                get: function () {
                    return this._distance;
                },
                set: function (value) {
                    if (this._distance == value) {
                        return;
                    }
                    this._distance = Math.max(this.settings.minDistance, Math.min(this.settings.maxDistance, value));
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controls.prototype, "panAngle", {
                get: function () {
                    return this._panAngle;
                },
                set: function (value) {
                    value = Math.max(this.settings.minPanAngle, Math.min(this.settings.maxPanAngle, value));
                    if (this._panAngle == value) {
                        return;
                    }
                    this._panAngle = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Controls.prototype, "tiltAngle", {
                get: function () {
                    return this._tiltAngle;
                },
                set: function (value) {
                    value = Math.max(this.settings.minTiltAngle, Math.min(this.settings.maxTiltAngle, value));
                    if (this._tiltAngle == value) {
                        return;
                    }
                    this._tiltAngle = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            return Controls;
        }());
        core.Controls = Controls;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var ControlsSettings = (function () {
            function ControlsSettings() {
                this.panAngle = 0;
                this.tiltAngle = 10;
                this.distance = 30;
                this.minDistance = 8;
                this.maxDistance = 30;
                this.minTiltAngle = 5;
                this.maxTiltAngle = 89;
                this.minPanAngle = -Infinity;
                this.maxPanAngle = Infinity;
                this.steps = 8;
                this.yFactor = 2;
            }
            return ControlsSettings;
        }());
        core.ControlsSettings = ControlsSettings;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Cube = (function () {
            function Cube(playground, key) {
                this.playground = playground;
                this.key = key;
                this.mapPosition = new THREE.Vector3();
                this._hits = 0;
                this._opacity = 1;
                this.mesh = this.playground.assets.getMesh(this.key);
                this.mesh.material = this.playground.assets.getMaterial("cube-out");
                this.mesh.name = this.key;
                this.mesh.userData.body = this.body;
                this.mesh.userData.cube = this;
                this.body = this.playground.assets.getBody(this.mesh);
                this.playground.scene.add(this.mesh);
                this.playground.world.addBody(this.body);
                this.addLayerInfo();
                this._lastRotationX = 0;
                this._lastRotationZ = 0;
                this._lastRotationY = 0;
                this._rotationX = 0;
                this._rotationY = 0;
                this._rotationZ = 0;
                this._selected = false;
                this._materialHit1 = this.playground.assets.getMaterial("cube-hit1");
                this._materialHit2 = this.playground.assets.getMaterial("cube-hit2");
                this._materialHit3 = this.playground.assets.getMaterial("cube-hit3");
                this._materialHit4 = this.playground.assets.getMaterial("cube-hit4");
                this._materialOut = this.playground.assets.getMaterial("cube-out");
                this._materialOver = this.playground.assets.getMaterial("cube-over");
                this._materialDown = this.playground.assets.getMaterial("cube-down");
                this._materialSelected = this.playground.assets.getMaterial("cube-selected");
                this._materialHighlight = this.playground.assets.getMaterial("cube-highlight");
                this.id = PIXI.utils.uid().toString();
            }
            Cube.prototype.addLayerInfo = function () {
                var width = 256;
                var maxWidth = 256 >> 1;
                var height = 256;
                var c = new PIXI.Container();
                var s = new PIXI.Sprite(PIXI.Texture.EMPTY);
                s.width = width;
                s.height = height;
                c.addChild(s);
                var l = this.key.indexOf("mk") != -1 ? loc("cube_mk_layer") : this.key.indexOf("d") != -1 ? loc(this.key) : this.key.substr(5);
                var t = new gf.display.Text(this.playground.game, l, cuboro.TEXT_STYLE_LAYER.clone());
                if (t.width > s.width - maxWidth) {
                    t.width = s.width - maxWidth;
                    t.scaleY = t.scaleX;
                }
                t.x = (width - t.width) >> 1;
                t.y = (height - t.height) >> 1;
                c.addChild(t);
                var r = new PIXI.CanvasRenderer(width, height, {
                    transparent: true,
                    resolution: 1
                });
                r.render(c);
                var image = new Image();
                image.src = r.view.toDataURL();
                image.width = width;
                image.height = height;
                c.destroy({ children: true, texture: true, baseTexture: true });
                r.destroy(true);
                var texture = new THREE.Texture(image);
                texture.needsUpdate = true;
                var geometry = new THREE.BoxGeometry(2.01, 2.01, 2.01);
                var material = new THREE.MeshBasicMaterial({ map: texture, transparent: true });
                this.layer = new THREE.Mesh(geometry, material);
                this.layer.visible = false;
                this.playground.scene.add(this.layer);
            };
            Cube.prototype.setState = function (state) {
                if (!state) {
                    switch (this._hits) {
                        case 0:
                            this.mesh.material = this._materialOut;
                            break;
                        case 1:
                            this.mesh.material = this._materialHit1;
                            break;
                        case 2:
                            this.mesh.material = this._materialHit2;
                            break;
                        case 3:
                            this.mesh.material = this._materialHit3;
                            break;
                        case 4:
                            this.mesh.material = this._materialHit4;
                            break;
                    }
                }
                else {
                    switch (state) {
                        case gf.OUT:
                            this.mesh.material = this._materialOut;
                            break;
                        case gf.OVER:
                            this.mesh.material = this._materialOver;
                            break;
                        case gf.DOWN:
                            this.mesh.material = this._materialDown;
                            break;
                        case gf.SELECTED:
                            this.mesh.material = this._materialSelected;
                            break;
                        case gf.HIGHLIGHT:
                            this.mesh.material = this._materialHighlight;
                            break;
                    }
                }
            };
            Cube.prototype.remove = function () {
                this._materialHit1.dispose();
                this._materialHit2.dispose();
                this._materialHit3.dispose();
                this._materialHit4.dispose();
                this._materialOut.dispose();
                this._materialOver.dispose();
                this._materialDown.dispose();
                this._materialSelected.dispose();
                this._materialHighlight.dispose();
                this.playground.scene.remove(this.mesh);
                this.playground.gameScreen.bottomMenu.cubeList.getItemByKey(this.key).remaining++;
                this.playground.world.remove(this.body);
                this.playground.scene.remove(this.mesh);
                this.playground.scene.remove(this.layer);
            };
            Cube.prototype.drop = function () {
                var _this = this;
                TweenMax.to(this, 0.5, {
                    y: this.playground.map.yTo3DPos(this.mapPosition.y),
                    ease: Bounce.easeOut,
                    onUpdate: function () {
                        if (_this.playground.gameScreen.moveMenu.visible) {
                            _this.playground.emit(cuboro.CUBE_UPDATE);
                        }
                    }
                });
            };
            Cube.prototype.setRotation = function (x, y, z) {
                x = gf.utils.Maths.degToRad(x);
                y = gf.utils.Maths.degToRad(y);
                z = gf.utils.Maths.degToRad(z);
                TweenMax.to(this.mesh.rotation, 0.1, { x: x, y: y, z: z });
            };
            Object.defineProperty(Cube.prototype, "rotationX", {
                get: function () {
                    return this._rotationX;
                },
                set: function (value) {
                    this._rotationX = value;
                    var val = this._rotationX - this._lastRotationX;
                    var rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationAxis(new THREE.Vector3(1, 0, 0).normalize(), val);
                    rotationMatrix.multiply(this.mesh.matrix);
                    this.mesh.matrix = rotationMatrix;
                    this.mesh.rotation.setFromRotationMatrix(this.mesh.matrix);
                    this._lastRotationX = this._rotationX;
                },
                enumerable: true,
                configurable: true
            });
            Cube.prototype.resetRotationX = function () {
                this._rotationX = 0;
                this._lastRotationX = 0;
            };
            Object.defineProperty(Cube.prototype, "rotationY", {
                get: function () {
                    return this._rotationY;
                },
                set: function (value) {
                    this._rotationY = value;
                    var val = this._rotationY - this._lastRotationY;
                    var rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationAxis(new THREE.Vector3(0, 1, 0).normalize(), val);
                    rotationMatrix.multiply(this.mesh.matrix);
                    this.mesh.matrix = rotationMatrix;
                    this.mesh.rotation.setFromRotationMatrix(this.mesh.matrix);
                    this._lastRotationY = this._rotationY;
                },
                enumerable: true,
                configurable: true
            });
            Cube.prototype.resetRotationY = function () {
                this._rotationY = 0;
                this._lastRotationY = 0;
            };
            Object.defineProperty(Cube.prototype, "rotationZ", {
                get: function () {
                    return this._rotationZ;
                },
                set: function (value) {
                    this._rotationZ = value;
                    var val = this._rotationZ - this._lastRotationZ;
                    var rotationMatrix = new THREE.Matrix4();
                    rotationMatrix.makeRotationAxis(new THREE.Vector3(0, 0, 1).normalize(), val);
                    rotationMatrix.multiply(this.mesh.matrix);
                    this.mesh.matrix = rotationMatrix;
                    this.mesh.rotation.setFromRotationMatrix(this.mesh.matrix);
                    this._lastRotationZ = this._rotationZ;
                },
                enumerable: true,
                configurable: true
            });
            Cube.prototype.resetRotationZ = function () {
                this._rotationZ = 0;
                this._lastRotationZ = 0;
            };
            Cube.prototype.highlight = function (highlight) {
                this.setState(highlight ? gf.HIGHLIGHT : gf.OUT);
            };
            Cube.prototype.fromString = function (value) {
                var data = JSON.parse(value);
                this.mapPosition.set(data.map.x, data.map.y, data.map.z);
                this.mesh.rotation.set(data.rot._x, data.rot._y, data.rot._z);
            };
            Cube.prototype.toString = function () {
                var data = {};
                data.map = this.mapPosition;
                data.key = this.key;
                data.rot = this.mesh.rotation;
                return JSON.stringify(data);
            };
            Object.defineProperty(Cube.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    this._isSelected = value;
                    this.setState(this.isSelected ? gf.SELECTED : this.isOver ? gf.OVER : gf.OUT);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "isOver", {
                get: function () {
                    return this._isOver;
                },
                set: function (value) {
                    this._isOver = value;
                    if (!this.isSelected)
                        this.setState(this.isOver ? gf.OVER : gf.OUT);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "isDown", {
                get: function () {
                    return this._isDown;
                },
                set: function (value) {
                    this._isDown = value;
                    if (!this.isSelected)
                        this.setState(this._isDown ? gf.DOWN : this.isOver ? gf.OVER : gf.OUT);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "scale", {
                get: function () {
                    return this.mesh.scale.x;
                },
                set: function (value) {
                    this.mesh.scale.x = value;
                    this.mesh.scale.y = value;
                    this.mesh.scale.z = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "x", {
                get: function () {
                    return this.body.position.x;
                },
                set: function (value) {
                    this.mesh.position.x = value;
                    this.body.position.x = value;
                    this.layer.position.x = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "y", {
                get: function () {
                    return this.body.position.y;
                },
                set: function (value) {
                    this.mesh.position.y = value;
                    this.body.position.y = value;
                    this.layer.position.y = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "z", {
                get: function () {
                    return this.body.position.z;
                },
                set: function (value) {
                    this.mesh.position.z = value;
                    this.body.position.z = value;
                    this.layer.position.z = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "hits", {
                get: function () {
                    return this._hits;
                },
                set: function (value) {
                    this._hits = Math.min(4, value);
                    this.setState();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cube.prototype, "opacity", {
                get: function () {
                    return this._opacity;
                },
                set: function (value) {
                    this._opacity = value;
                    this._materialHit1.opacity = this._opacity;
                    this._materialHit2.opacity = this._opacity;
                    this._materialHit3.opacity = this._opacity;
                    this._materialHit4.opacity = this._opacity;
                    this._materialOut.opacity = this._opacity;
                    this._materialOver.opacity = this._opacity;
                    this._materialDown.opacity = this._opacity;
                    this._materialSelected.opacity = this._opacity;
                    this._materialHighlight.opacity = this._opacity;
                    this.mesh.material.opacity = this._opacity;
                },
                enumerable: true,
                configurable: true
            });
            return Cube;
        }());
        core.Cube = Cube;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Cubes = (function () {
            function Cubes(playground) {
                this.playground = playground;
                this.cubes = [];
            }
            Cubes.prototype.remove = function (cube) {
                if (!cube)
                    cube = this.selected;
                if (!cube)
                    return;
                this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                this.cubes.splice(this.cubes.indexOf(cube), 1);
                cube.remove();
                this.updateY();
                this.playground.placeables.update();
            };
            Cubes.prototype.swap = function (cube) {
                var x = this.selected.mapPosition.x;
                var y = this.selected.mapPosition.y;
                var z = this.selected.mapPosition.z;
                this.selected.mapPosition.x = cube.mapPosition.x;
                this.selected.mapPosition.y = cube.mapPosition.y;
                this.selected.mapPosition.z = cube.mapPosition.z;
                cube.mapPosition.x = x;
                cube.mapPosition.y = y;
                cube.mapPosition.z = z;
                this.update(cube, false);
                this.update(this.selected, false);
                this.updateY();
                this.playground.emit(cuboro.SWAP);
            };
            Cubes.prototype.getById = function (id) {
                var cube = null;
                this.cubes.forEach(function (value) {
                    if (value.id == id) {
                        cube = value;
                        return true;
                    }
                });
                return cube;
            };
            Cubes.prototype.getHighestCube = function (mapX, mapZ) {
                for (var mapY = cuboro.MAX_Y - 1; mapY >= 0; --mapY) {
                    var id = this.playground.map.getAt(mapX, mapY, mapZ);
                    if (id != cuboro.EMPTY)
                        return this.getById(id);
                }
                return this.getById(cuboro.EMPTY);
            };
            Cubes.prototype.removeCubes = function () {
                while (this.cubes.length)
                    this.remove(this.cubes[0]);
                this.cubes = [];
            };
            Cubes.prototype.getHighestStartCubes = function () {
                var startCubes = this.cubes.filter(function (cube) { return cuboro.START_CUBES.indexOf(cube.key) >= 0; });
                var maxY = 0;
                for (var i = 0; i < startCubes.length; ++i)
                    maxY = Math.max(maxY, startCubes[i].mapPosition.y);
                return startCubes.filter(function (cube) { return cube.mapPosition.y == maxY; });
            };
            Cubes.prototype.highlightMarble = function (highlight) {
                this.cubes.forEach(function (value) {
                    if (cuboro.START_CUBES.indexOf(value.key) != -1)
                        value.highlight(highlight);
                });
            };
            Cubes.prototype.update = function (cube, updateY) {
                if (updateY === void 0) { updateY = true; }
                if (!cube && !this.selected)
                    return;
                if (!cube)
                    cube = this.selected;
                if (this.cubes.indexOf(cube) == -1)
                    this.cubes.push(cube);
                var mapPos = cube.mapPosition;
                this.playground.map.setAt(cube.id, mapPos);
                this.updatePosition(cube);
                this.playground.placeables.update();
                if (updateY)
                    this.updateY();
            };
            Cubes.prototype.updatePosition = function (cube) {
                var pos = this.playground.map.to3DPos(cube.mapPosition);
                cube.x = pos.x;
                cube.y = pos.y;
                cube.z = pos.z;
            };
            Cubes.prototype.updateY = function () {
                var cubeIsFalling = false;
                for (var i = 0; i < this.cubes.length; ++i) {
                    var cube = this.cubes[i];
                    if (cube.mapPosition.y > 0 && this.playground.map.getAt(cube.mapPosition.x, cube.mapPosition.y - 1, cube.mapPosition.z) == cuboro.EMPTY) {
                        this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                        cube.mapPosition.y = cube.mapPosition.y - 1;
                        this.playground.map.setAt(cube.id, cube.mapPosition);
                        cube.drop();
                        cubeIsFalling = true;
                        break;
                    }
                }
                if (cubeIsFalling)
                    this.updateY();
            };
            Cubes.prototype.getCubes = function () {
                var data = [];
                this.cubes.forEach(function (value) {
                    data.push(value.toString());
                });
                return data;
            };
            Cubes.prototype.setCubes = function (data) {
                var _this = this;
                data.forEach(function (value) {
                    var cube = new cuboro.core.Cube(_this.playground, kr3m.util.Json.decode(value).key);
                    cube.fromString(value);
                    _this.playground.gameScreen.bottomMenu.cubeList.getItemByKey(cube.key).remaining--;
                    _this.playground.cubes.update(cube, false);
                });
            };
            Object.defineProperty(Cubes.prototype, "over", {
                get: function () {
                    return this._over;
                },
                set: function (value) {
                    if (this._over != value) {
                        if (this._over)
                            this._over.isOver = false;
                        this._over = value;
                        if (this._over)
                            this._over.isOver = true;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cubes.prototype, "down", {
                get: function () {
                    return this._down;
                },
                set: function (value) {
                    if (this._down != value) {
                        if (this._down)
                            this._down.isDown = false;
                        this._down = value;
                        if (this._down)
                            this._down.isDown = true;
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cubes.prototype, "selected", {
                get: function () {
                    return this._selected;
                },
                set: function (value) {
                    var rotateMenu = this.playground.gameScreen.rotateMenu;
                    var moveMenu = this.playground.gameScreen.moveMenu;
                    if (this._selected != value) {
                        if (this._selected)
                            this._selected.isSelected = false;
                        this._selected = value;
                        this.playground.emit(cuboro.CUBE_SELECTED, this._selected);
                        if (this._selected) {
                            this._selected.isSelected = true;
                            if (this.playground.gameScreen.bottomMenu.btMoveCube.isSelected)
                                moveMenu.show();
                            else
                                rotateMenu.show();
                        }
                        else {
                            this.playground.emit(cuboro.CUBE_DESELECTED);
                        }
                    }
                    else if (this._selected) {
                        this._selected.isSelected = false;
                        this._selected = null;
                        this.playground.emit(cuboro.CUBE_DESELECTED);
                    }
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Cubes.prototype, "swapping", {
                get: function () {
                    return this._swapping;
                },
                set: function (value) {
                    this._swapping = value;
                },
                enumerable: true,
                configurable: true
            });
            return Cubes;
        }());
        core.Cubes = Cubes;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Evaluation = (function () {
            function Evaluation(playground) {
                this.playground = playground;
                this.reset();
            }
            Evaluation.prototype.isSubstructure = function (cube) {
                var result = false;
                this.playground.cubes.cubes.forEach(function (value) {
                    if (value.hits > 0) {
                        if (value.mapPosition.x == cube.mapPosition.x && value.mapPosition.z == cube.mapPosition.z) {
                            if (value.mapPosition.y > cube.mapPosition.y) {
                                result = true;
                                return true;
                            }
                        }
                    }
                });
                return result;
            };
            Evaluation.prototype.reset = function () {
                this.current = new cuboro.vo.EvaluationData();
                this.current.cubes = 0;
                this.current.track = [0, 0, 0, 0, 0];
                this.current.substructure = 0;
                this.current.scoreCubes = 0;
                this.current.scoreTotal = 0;
                this.current.scoreTrack = [0, 0, 0, 0, 0];
                this.current.scoreSubstructure = 0;
            };
            Evaluation.prototype.calculate = function () {
                var _this = this;
                this.reset();
                this.current.cubes = this.playground.cubes.getCubes().length;
                this.current.scoreCubes = this.current.cubes;
                this.current.scoreTrack = [0, 0, 0, 0, 0];
                this.current.scoreSubstructure = 0;
                var collisions = this.playground.marble.collisions;
                var cubes = [];
                collisions.forEach(function (value) {
                    if (cubes.indexOf(value.cube) == -1)
                        cubes.push(value.cube);
                });
                cubes.forEach(function (value) {
                    _this.current.track[value.hits - 1]++;
                    if (value.hits == 1)
                        _this.current.scoreTrack[0] += 2;
                    else if (value.hits == 2)
                        _this.current.scoreTrack[1] += 4;
                    else if (value.hits == 3)
                        _this.current.scoreTrack[2] += 12;
                    else if (value.hits == 4)
                        _this.current.scoreTrack[3] += 16;
                    else if (value.hits > 4)
                        _this.current.scoreTrack[4] += 16;
                    if (_this.isSubstructure(value)) {
                        _this.current.substructure++;
                        _this.current.scoreSubstructure += 4;
                    }
                });
                this.current.scoreTotal = this.current.scoreCubes +
                    this.current.scoreTrack[0] +
                    this.current.scoreTrack[1] +
                    this.current.scoreTrack[2] +
                    this.current.scoreTrack[3] +
                    this.current.scoreTrack[4] +
                    this.current.scoreSubstructure;
                mTrack.data.evaluation = this.current;
                this.playground.game.stage.header.trackMenu.checkPublish();
            };
            return Evaluation;
        }());
        core.Evaluation = Evaluation;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Ground = (function () {
            function Ground(playground) {
                this.playground = playground;
                this.createBody();
                this.createGround();
                this.createMap();
            }
            Ground.prototype.createBody = function () {
                this.body = new CANNON.Body({ mass: 0 });
                this.body.addShape(new CANNON.Plane());
                this.body.quaternion.setFromAxisAngle(new CANNON.Vec3(1, 0, 0), -Math.PI / 2);
                this.body.position = new CANNON.Vec3(1, 0, 1);
                this.playground.world.addBody(this.body);
            };
            Ground.prototype.createGround = function () {
                this.material = new THREE.MeshBasicMaterial({ map: this.playground.assets.getTexture("ground") });
                this.geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);
                this.tiles = [];
                this.tilesMap = [];
                var row;
                var col;
                var tile;
                for (row = 0; row < cuboro.MAX_X; ++row) {
                    this.tilesMap[row] = [];
                    for (col = 0; col < cuboro.MAX_Z; ++col) {
                        tile = this.getTile();
                        tile.name = "ground" + col.toString() + "_" + row.toString();
                        tile.position.z = col * 2 - (cuboro.MAX_Z - 1);
                        tile.position.y = 0;
                        tile.position.x = row * 2 - (cuboro.MAX_X - 1);
                        tile.userData = { x: row, z: col };
                        this.playground.scene.add(tile);
                        this.tilesMap[row][col] = tile;
                        this.tiles.push(tile);
                    }
                }
            };
            Ground.prototype.createMap = function () {
                var row;
                var col;
                this.map = [];
                for (row = 0; row < cuboro.MAX_X; ++row) {
                    this.map[row] = [];
                    for (col = 0; col < cuboro.MAX_Z; ++col) {
                        this.map[row][col] = 1;
                    }
                }
            };
            Ground.prototype.update = function (map) {
                this.map = map;
                var row;
                var col;
                var tile;
                for (row = 0; row < cuboro.MAX_X; ++row) {
                    for (col = 0; col < cuboro.MAX_Z; ++col) {
                        tile = this.tilesMap[row][col];
                        tile.visible = (map[row][col] == 1);
                        this.map[row][col] = (tile.visible) ? 1 : 0;
                    }
                }
            };
            Ground.prototype.updateTile = function (row, col, active) {
                this.tilesMap[row][col].visible = active;
                this.map[row][col] = (active) ? 1 : 0;
            };
            Ground.prototype.getTile = function () {
                var mesh = new THREE.Mesh(this.geometry, this.material);
                mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -cuboro.DEG_RAD_90);
                return mesh;
            };
            return Ground;
        }());
        core.Ground = Ground;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var History = (function (_super) {
            __extends(History, _super);
            function History(playground) {
                var _this = _super.call(this) || this;
                _this.playground = playground;
                _this.history = [];
                return _this;
            }
            History.prototype.reset = function () {
                this.history = [];
                this.emit(gf.CHANGE, this.history.length);
            };
            History.prototype.save = function (silent) {
                if (silent === void 0) { silent = false; }
                var cube;
                var data = [];
                this.playground.scene.children.forEach(function (value) {
                    if (value.name.indexOf("cube") != -1) {
                        cube = value.userData.cube;
                        data.push({
                            key: cube.key,
                            pos: cube.mapPosition.toArray(),
                            rot: cube.mesh.rotation.toArray()
                        });
                    }
                });
                if (this.history.length == 0 || JSON.stringify(data) != JSON.stringify(this.history[this.history.length - 1])) {
                    this.skipFirst = true;
                    this.history.push(data);
                    if (!silent)
                        this.emit(gf.CHANGE, this.history.length);
                }
            };
            History.prototype.undo = function () {
                var _this = this;
                this.playground.cubes.selected = null;
                this.playground.cubes.removeCubes();
                this.playground.placeables.hide();
                this.playground.gameScreen.moveMenu.hide();
                this.playground.gameScreen.rotateMenu.hide();
                if (this.history.length > 0) {
                    var cube_1;
                    var data = this.history.pop();
                    if (this.skipFirst && data.length > 0)
                        data = this.history.pop();
                    this.skipFirst = false;
                    if (!data)
                        return;
                    data.forEach(function (value) {
                        cube_1 = new cuboro.core.Cube(_this.playground, value.key);
                        cube_1.mapPosition.set(value.pos[0], value.pos[1], value.pos[2]);
                        cube_1.mesh.rotation.set(value.rot[0], value.rot[1], value.rot[2]);
                        _this.playground.gameScreen.bottomMenu.cubeList.getItemByKey(cube_1.key).remaining--;
                        _this.playground.cubes.update(cube_1);
                        _this.playground.save();
                    });
                    this.playground.emit(cuboro.CUBE_UPDATE);
                    this.emit(gf.CHANGE, this.history.length);
                }
                if (this.history.length == 0)
                    this.save(true);
            };
            return History;
        }(PIXI.utils.EventEmitter));
        core.History = History;
        var CubeData = (function () {
            function CubeData() {
            }
            return CubeData;
        }());
        core.CubeData = CubeData;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Map = (function () {
            function Map(playground) {
                this.playground = playground;
                var x;
                var y;
                var z;
                this.map = [];
                for (x = 0; x < cuboro.MAX_X; ++x) {
                    this.map[x] = [];
                    for (y = 0; y < cuboro.MAX_Y; ++y) {
                        this.map[x][y] = [];
                        for (z = 0; z < cuboro.MAX_Z; ++z) {
                            this.map[x][y][z] = cuboro.EMPTY;
                        }
                    }
                }
            }
            Map.prototype.getAt = function (posOrX, y, z) {
                var x;
                if (typeof posOrX != "number") {
                    var pos = posOrX;
                    x = pos.x;
                    y = pos.y;
                    z = pos.z;
                }
                else {
                    x = posOrX;
                }
                if (!this.onMap(x, z, y))
                    return null;
                return this.map[x][y][z];
            };
            Map.prototype.setAt = function (id, posOrX, y, z) {
                var x;
                if (typeof posOrX != "number") {
                    var pos = posOrX;
                    x = pos.x;
                    y = pos.y;
                    z = pos.z;
                }
                else {
                    x = posOrX;
                }
                if (this.onMap(x, z, y)) {
                    this.map[x][y][z] = id;
                }
                else {
                    log("cuboro.core.Map.setAt error. Position " + x + ", " + y + ", " + z + " not on map!");
                }
            };
            Map.prototype.isValidX = function (value) {
                return !(value < 0 || value >= cuboro.MAX_X);
            };
            Map.prototype.isValidY = function (value) {
                return !(value < 0 || value >= cuboro.MAX_Y);
            };
            Map.prototype.isValidZ = function (value) {
                return !(value < 0 || value >= cuboro.MAX_Z);
            };
            Map.prototype.isValid = function (x, y, z) {
                if (!this.isValidX(x))
                    return false;
                if (!this.isValidY(y))
                    return false;
                return this.isValidZ(z);
            };
            Map.prototype.getNextEmptyY = function (x, z) {
                for (var y = 0; y < cuboro.MAX_Y + 1; ++y) {
                    if (this.map[x]) {
                        if (this.map[x][y]) {
                            if (this.map[x][y][z] == cuboro.EMPTY) {
                                return y;
                            }
                        }
                        else {
                            return y;
                        }
                    }
                }
            };
            Map.prototype.to3DPos = function (posOrX, y, z) {
                var x;
                if (typeof posOrX != "number") {
                    var pos = posOrX;
                    x = pos.x;
                    y = pos.y;
                    z = pos.z;
                }
                else {
                    x = posOrX;
                }
                x = this.xTo3DPos(x);
                y = this.yTo3DPos(y);
                z = this.zTo3DPos(z);
                return new THREE.Vector3(x, y, z);
            };
            Map.prototype.xTo3DPos = function (value) {
                var maxX = cuboro.MAX_X >> 1;
                return (value * 2 + (this.playground.elementMargin * (value - maxX))) - 11;
            };
            Map.prototype.yTo3DPos = function (value) {
                return (value * 2 + (this.playground.layerMargin * 2 * value)) + 1;
            };
            Map.prototype.zTo3DPos = function (value) {
                var maxZ = cuboro.MAX_Z >> 1;
                return (value * 2 + (this.playground.elementMargin * (value - maxZ))) - 11;
            };
            Map.prototype.toMapPos = function (posOrX, y, z) {
                var x;
                if (typeof posOrX != "number") {
                    var pos = posOrX;
                    x = this.xToMapPos(pos.x);
                    y = this.yToMapPos(pos.y);
                    z = this.zToMapPos(pos.z);
                }
                else {
                    x = this.xToMapPos(posOrX);
                    y = this.yToMapPos(y);
                    z = this.zToMapPos(z);
                }
                return new THREE.Vector3(x, y, z);
            };
            Map.prototype.xToMapPos = function (value) {
                var offset = this.playground.elementMargin * (Math.round((value + 11) * 0.5) - (cuboro.MAX_X >> 1));
                return Math.round((value + 11 - offset) * 0.5);
            };
            Map.prototype.yToMapPos = function (value) {
                var offset = this.playground.layerMargin * 2 * ((value - 1) * 0.5);
                return Math.round((value - offset - 1) * 0.5);
            };
            Map.prototype.zToMapPos = function (value) {
                var offset = this.playground.elementMargin * (Math.round((value + 11) * 0.5) - (cuboro.MAX_Z >> 1));
                return Math.round((value + 11 - offset) * 0.5);
            };
            Map.prototype.onMap3D = function (x, z) {
                x = this.xToMapPos(x);
                z = this.xToMapPos(z);
                return this.onMap(x, z);
            };
            Map.prototype.onMap = function (x, z, y) {
                if (x < 0) {
                    return false;
                }
                if (x > cuboro.MAX_X) {
                    return false;
                }
                if (z < 0) {
                    return false;
                }
                if (z > cuboro.MAX_Z) {
                    return false;
                }
                if (y == undefined) {
                    return true;
                }
                if (y < 0) {
                    return false;
                }
                return y <= cuboro.MAX_Y;
            };
            Map.prototype.mapItem = function (x, y, z) {
                if (!this.map[x]) {
                    return null;
                }
                if (!this.map[x][y]) {
                    return null;
                }
                if (!this.map[x][y][z]) {
                    return null;
                }
                return this.map[x][y][z];
            };
            return Map;
        }());
        core.Map = Map;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Timer = (function (_super) {
            __extends(Timer, _super);
            function Timer(game) {
                var _this = _super.call(this) || this;
                _this.game = game;
                _this._duration = 0;
                _this._elapsed = 0;
                _this._paused = false;
                return _this;
            }
            Timer.prototype.tick = function () {
                var _this = this;
                this._elapsed += 100;
                if (this._duration - this._elapsed <= 0) {
                    this.stop();
                    this.emit(gf.TIMER);
                    this.emit(gf.TIMER_COMPLETE);
                    return;
                }
                if (this._elapsed % 1000 == 0)
                    this.emit(gf.TIMER);
                this._timerId = setTimeout(function () { return _this.tick(); }, 100);
            };
            Timer.prototype.round = function (value) {
                return parseInt(value.toString(), 10);
            };
            Timer.prototype.pause = function () {
                if (this._paused)
                    return;
                clearTimeout(this._timerId);
                this._paused = true;
                return this;
            };
            Timer.prototype.resume = function () {
                if (!this._paused)
                    return;
                this.start((this._duration - this._elapsed) / 1000);
                this._paused = false;
                return this;
            };
            Timer.prototype.resumeEx = function () {
                if (!this._paused)
                    return;
                var e = this._elapsed;
                this.start(this._duration / 1000);
                this._elapsed = e;
                this._paused = false;
                this.emit(gf.TIMER, this.round(this._duration));
                return this;
            };
            Timer.prototype.stop = function () {
                this._isRunning = false;
                this._paused = false;
                if (this._timerId)
                    clearTimeout(this._timerId);
                return this;
            };
            Timer.prototype.restart = function () {
                this.stop().start(this._duration * 0.001);
                return this;
            };
            Timer.prototype.start = function (duration) {
                var _this = this;
                if (this._isRunning)
                    this.stop();
                this._isRunning = true;
                this._duration = duration * 1000;
                this._elapsed = 0;
                this._timerId = setTimeout(function () { return _this.tick(); }, 100);
                this.emit(gf.TIMER, this.round(duration));
                return this;
            };
            Object.defineProperty(Timer.prototype, "duration", {
                get: function () {
                    return this._duration;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Timer.prototype, "elapsed", {
                get: function () {
                    return this.round(this._elapsed * 0.001);
                },
                set: function (value) {
                    this._elapsed = value * 1000;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Timer.prototype, "elapsedEx", {
                get: function () {
                    return this._elapsed * 0.001;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Timer.prototype, "left", {
                get: function () {
                    return this.round(this._duration * 0.001 - this.elapsed);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Timer.prototype, "paused", {
                get: function () {
                    return this._paused;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Timer.prototype, "isRunning", {
                get: function () {
                    return this._isRunning;
                },
                enumerable: true,
                configurable: true
            });
            return Timer;
        }(PIXI.utils.EventEmitter));
        utils.Timer = Timer;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Marble = (function (_super) {
            __extends(Marble, _super);
            function Marble(playground) {
                var _this = _super.call(this) || this;
                _this.playground = playground;
                _this.body = new CANNON.Body({ mass: 2.5 });
                _this.body.angularDamping = -0.00001;
                _this.body.angularFactor.set(0.9, 0.9, 0.9);
                _this.body.linearDamping = 0.01;
                _this.body.linearFactor.set(0.85, 0.85, 0.85);
                _this.body.addShape(new CANNON.Sphere(0.31));
                _this.body.addEventListener("collide", function (e) { return _this.onCollision(e.body); });
                var materialParameters = {};
                materialParameters.color = 0xffffff;
                materialParameters.map = _this.playground.assets.getTexture("marble");
                materialParameters.opacity = 0.90;
                materialParameters.flatShading = true;
                materialParameters.transparent = true;
                materialParameters.reflectivity = 1;
                materialParameters.refractionRatio = 0.75;
                _this.mesh = new THREE.Mesh(new THREE.SphereGeometry(0.31, 20, 20));
                _this.mesh.material = new THREE.MeshPhongMaterial(materialParameters);
                _this.mesh.name = "marble";
                _this.mesh.visible = false;
                _this.playground.scene.add(_this.mesh);
                _this.playground.world.addBody(_this.body);
                _this.zeroTimer = new gf.utils.Timer(_this.playground.game);
                _this.zeroTimer.on(gf.TIMER_COMPLETE, function () { return _this.isStuck = true; }, _this);
                return _this;
            }
            Marble.prototype.isOnGround = function () {
                return this.onGround;
            };
            Marble.prototype.isInContainer = function () {
                return this.inContainer;
            };
            Marble.prototype.hasSkipped = function () {
                return this.skipHeight >= cuboro.MARBLE_SKIP_THRESHOLD;
            };
            Marble.prototype.onCollision = function (body) {
                if (body.id === this.playground.ground.body.id)
                    this.onGround = true;
                if (body.id != this.preHit && !this.onGround) {
                    if (!this.lastHitTime || Date.now() - this.lastHitTime > 100) {
                        this.lastHitTime = Date.now();
                        this.prePreHit = this.preHit;
                        this.preHit = body.id;
                        var cube = this.bodies[body.id];
                        if (cube) {
                            if (cube.mesh.name === "cube_mk")
                                this.inContainer = true;
                            this._collisions.push({ bodyId: body.id, cube: cube });
                            cube.hits++;
                        }
                    }
                }
            };
            Marble.prototype.reset = function () {
                var _this = this;
                this.inContainer = false;
                this.isStuck = false;
                this.onGround = false;
                this.preHit = null;
                this.prePreHit = null;
                this.lastHitTime = null;
                this.bodies = {};
                this.resetBody();
                this.playground.cubes.cubes.forEach(function (value) {
                    var body = value.body;
                    body.position.copy(value.mesh.position);
                    body.quaternion.copy(value.mesh.quaternion);
                    body.velocity.setZero();
                    body.initVelocity.setZero();
                    body.angularVelocity.setZero();
                    body.initAngularVelocity.setZero();
                    body.previousPosition.setZero();
                    body.force.setZero();
                    body.torque.setZero();
                    body.sleepState = 0;
                    body.timeLastSleepy = 0;
                    value.hits = 0;
                    _this.bodies[body.id] = value;
                });
            };
            Marble.prototype.resetBody = function () {
                this.body.velocity.setZero();
                this.body.initVelocity.setZero();
                this.body.angularVelocity.setZero();
                this.body.initAngularVelocity.setZero();
                this.body.previousPosition.setZero();
                this.body.force.setZero();
                this.body.torque.setZero();
                this.body.sleepState = 0;
                this.body.timeLastSleepy = 0;
            };
            Marble.prototype.evaluate = function (success, aborted) {
                if (success) {
                    this.playground.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    this.playground.evaluation.calculate();
                    this.playground.game.overlays.show(cuboro.overlays.TrackDetailsIngame.NAME);
                }
                else if (!aborted) {
                    var message = this.playground.game.overlays.show(cuboro.overlays.Message.NAME);
                    message.text = loc("marble_run_failed");
                }
                this.reset();
                this.playground.physicsEnabled = false;
                this.playground.game.stage.header.show();
                this.playground.gameScreen.bottomMenu.visible = true;
                this.playground.gameScreen.layers.visible = true;
                this.playground.gameScreen.marbleRun.visible = false;
            };
            Marble.prototype.update = function () {
                var skip = this.body.position.y - this.lowestY;
                this.skipHeight = Math.max(this.skipHeight, skip);
                this.lowestY = Math.min(this.lowestY, this.body.position.y);
                if (this.onGround || this.inContainer || this.isStuck) {
                    var f = cuboro.MARBLE_DEATH_SLOW_FACTOR;
                    this.body.velocity = this.body.velocity.mult(f);
                    this.body.angularVelocity = this.body.angularVelocity.mult(f);
                    if (this.body.velocity.almostZero(0.1))
                        this.stop(false);
                }
                else {
                    if (this.body.velocity.almostZero(0.5)) {
                        if (!this.zeroTimer.isRunning)
                            this.zeroTimer.start(3 / this.playground.physicSpeedFactor);
                    }
                    else {
                        this.zeroTimer.stop();
                    }
                }
                this.mesh.position.set(this.body.position.x, this.body.position.y, this.body.position.z);
                this.mesh.quaternion.copy(this.body.quaternion);
            };
            Marble.prototype.start = function () {
                if (this.isRunning)
                    return;
                this.isRunning = true;
                this.bodies = {};
                this.playground.game.stage.header.hide();
                this.playground.gameScreen.bottomMenu.visible = false;
                this.playground.gameScreen.layers.visible = false;
                this.playground.gameScreen.marbleRun.visible = true;
                this.reset();
                this.lowestY = this.body.position.y;
                this.skipHeight = 0;
                this._collisions = [];
                this.playground.physicsEnabled = true;
            };
            Marble.prototype.stop = function (aborted) {
                var _this = this;
                if (!this.isRunning)
                    return;
                this.isRunning = false;
                this.mesh.visible = false;
                var success = this.onGround || this.inContainer;
                if (!aborted && success) {
                    this.playground.game.overlays.show(cuboro.overlays.Loader.NAME);
                    cuboro.ui.TrackPreview.GetBase64(this.playground, 300, function (value) {
                        if (mUser.isLoggedIn() && mTrack.owner.id == mUser.getUserId()) {
                            sTrack.saveTrackImage(mTrack.id, mTrack.name, value, function (imageUrl) {
                                mTrack.imageUrl = imageUrl;
                                _this.evaluate(true, aborted);
                                _this.playground.save();
                            });
                        }
                        else {
                            _this.evaluate(true, aborted);
                        }
                    });
                }
                else {
                    this.evaluate(false, aborted);
                }
                this.zeroTimer.stop();
                this.emit("stop");
            };
            Object.defineProperty(Marble.prototype, "collisions", {
                get: function () {
                    return this._collisions;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Marble.prototype, "x", {
                get: function () {
                    return this.body.position.x;
                },
                set: function (value) {
                    this.mesh.position.x = value;
                    this.body.position.x = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Marble.prototype, "y", {
                get: function () {
                    return this.body.position.y;
                },
                set: function (value) {
                    this.mesh.position.y = value;
                    this.body.position.y = value;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Marble.prototype, "z", {
                get: function () {
                    return this.body.position.z;
                },
                set: function (value) {
                    this.mesh.position.z = value;
                    this.body.position.z = value;
                },
                enumerable: true,
                configurable: true
            });
            return Marble;
        }(PIXI.utils.EventEmitter));
        core.Marble = Marble;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Placeables = (function () {
            function Placeables(playground) {
                this.playground = playground;
                this.createPlaceables();
                this.hide();
            }
            Placeables.prototype.createPlaceables = function () {
                this.materialPlaceable = this.playground.assets.getColorMaterial(0x00ff00);
                this.materialPlaceable.name = "materialPlaceable";
                this.materialPlaceable.transparent = true;
                this.materialPlaceable.opacity = 0;
                this.materialUnplaceable = this.playground.assets.getMaterial("unplaceable");
                this.materialUnplaceable.name = "materialUnplaceable";
                this.materialUnplaceable.transparent = true;
                this.geometry = new THREE.PlaneBufferGeometry(2, 2, 1, 1);
                this.tiles = [];
                this.tilesMap = [];
                var row;
                var col;
                var tile;
                for (row = 0; row < cuboro.MAX_X; ++row) {
                    this.tilesMap[row] = [];
                    for (col = 0; col < cuboro.MAX_Z; ++col) {
                        tile = this.getTile();
                        tile.name = "placeable" + col.toString() + "_" + row.toString();
                        tile.position.z = col * 2 - (cuboro.MAX_Z - 1);
                        tile.position.y = 0.05;
                        tile.position.x = row * 2 - (cuboro.MAX_X - 1);
                        tile.userData = { x: row, z: col };
                        tile.material = this.materialPlaceable;
                        this.playground.scene.add(tile);
                        this.tilesMap[row][col] = tile;
                        this.tiles.push(tile);
                    }
                }
            };
            Placeables.prototype.getTile = function () {
                var mesh = new THREE.Mesh(this.geometry, this.materialPlaceable);
                mesh.quaternion.setFromAxisAngle(new THREE.Vector3(1, 0, 0), -cuboro.DEG_RAD_90);
                return mesh;
            };
            Placeables.prototype.update = function () {
                var row;
                var col;
                var tile;
                var material;
                for (row = 0; row < cuboro.MAX_X; ++row) {
                    for (col = 0; col < cuboro.MAX_Z; ++col) {
                        var mapY = this.playground.map.getNextEmptyY(row, col);
                        tile = this.tilesMap[row][col];
                        tile.position.y = this.playground.map.yTo3DPos(mapY) - 0.99;
                        material = (mapY == cuboro.MAX_Y) ? this.materialUnplaceable : this.materialPlaceable;
                        if (material.name != tile.material.name)
                            tile.material = material;
                    }
                }
            };
            Placeables.prototype.hide = function () {
                this.tiles.forEach(function (value) {
                    value.visible = false;
                });
            };
            Placeables.prototype.show = function () {
                this.update();
                this.tiles.forEach(function (value) {
                    value.visible = true;
                });
            };
            return Placeables;
        }());
        core.Placeables = Placeables;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var utils;
    (function (utils) {
        var Maths = (function () {
            function Maths() {
            }
            Maths.isVector3Equal = function (v1, v2) {
                return v1.x == v2.x && v1.y == v2.y && v1.z == v2.z;
            };
            return Maths;
        }());
        utils.Maths = Maths;
    })(utils = cuboro.utils || (cuboro.utils = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Select = (function () {
            function Select(playground) {
                this.playground = playground;
                this.raycaster = new THREE.Raycaster();
                this.mouse = new THREE.Vector2();
                this.offset = new THREE.Vector3();
                this.plane = new THREE.Mesh(new THREE.PlaneBufferGeometry(2000, 2000, 8, 8), new THREE.MeshBasicMaterial({ color: 0x00FF00 }));
                this.plane.visible = false;
                this.playground.scene.add(this.plane);
                if (!navigator["isCocoonJS"]) {
                    var container = $("#kr3m");
                    this.offsetX = container.offset().left;
                    this.offsetY = container.offset().top;
                }
                else {
                    this.offsetX = this.offsetY = 0;
                }
                this.interaction = this.playground.gameScreen.interaction;
                this.interaction.on("onMouseDown", this.onDown, this);
                this.interaction.on("onMouseMove", this.onMove, this);
                this.interaction.on("onMouseUp", this.onUp, this);
                this.interaction.on("onTouchStart", this.onDown, this);
                this.interaction.on("onTouchMove", this.onMove, this);
                this.interaction.on("onTouchEnd", this.onUp, this);
            }
            Select.prototype.getMouse3D = function () {
                this.mouse.x = ((this._lastX - this.offsetX) / (this.playground.game.width * this.playground.game.scaleX)) * 2 - 1;
                this.mouse.y = -((this._lastY - this.offsetY) / (this.playground.game.height * this.playground.game.scaleY)) * 2 + 1;
                var pos = new THREE.Vector3(0, 0, 0);
                var pMouse = new THREE.Vector3(this.mouse.x, this.mouse.y, 1);
                pMouse.unproject(this.playground.camera);
                var cam = this.playground.camera.position;
                var m = pMouse.y / (pMouse.y - cam.y);
                pos.x = pMouse.x + (cam.x - pMouse.x) * m;
                pos.z = pMouse.z + (cam.z - pMouse.z) * m;
                return pos;
            };
            Select.prototype.spawnCubeFromList = function () {
                var list = this.playground.gameScreen.bottomMenu.cubeList;
                var listItem = list.currentItem;
                if (listItem && listItem.remaining > 0) {
                    listItem.remaining--;
                    var cube = new cuboro.core.Cube(this.playground, listItem.key);
                    var mapX = this.intersection.userData.x;
                    var mapZ = this.intersection.userData.z;
                    cube.x = this.playground.map.xTo3DPos(mapX);
                    cube.z = this.playground.map.zTo3DPos(mapZ);
                    cube.y = this.playground.map.to3DPos(mapX, this.playground.map.getNextEmptyY(mapX, mapZ), mapZ).y;
                    cube.mapPosition = this.playground.map.toMapPos(cube.x, cube.y, cube.z);
                    this.playground.cubes.update(cube);
                    this.playground.cubes.selected = cube;
                    list.deselectItems();
                    this.playground.placeables.hide();
                }
            };
            Select.prototype.onMove = function (e) {
                if (this.playground.physicsEnabled)
                    return;
                this.mouse.x = ((this.getX(e) - this.offsetX) / (this.playground.game.width * this.playground.game.scaleX)) * 2 - 1;
                this.mouse.y = -((this.getY(e) - this.offsetY) / (this.playground.game.height * this.playground.game.scaleY)) * 2 + 1;
                this.raycaster.setFromCamera(this.mouse, this.playground.camera);
                this.intersections = this.raycaster.intersectObjects(this.playground.scene.children);
                if (this._marbleSpawning) {
                    this.moveMarble();
                }
                else if (this.playground.cubes.down && this.interactionDistance > 10) {
                    this.moveCube();
                }
                else {
                    this.onOver();
                }
            };
            Select.prototype.onOver = function () {
                if (this.playground.physicsEnabled)
                    return;
                if (this.intersections.length > 0) {
                    if (this.intersection != this.intersections[0].object) {
                        this.intersection = this.intersections[0].object;
                        if (this.isCube) {
                            this.playground.cubes.over = this.intersection.userData.cube;
                        }
                        else {
                            this.playground.cubes.over = null;
                        }
                        this.plane.position.copy(this.intersection.position);
                        this.plane.lookAt(this.playground.camera.position);
                    }
                    this.interaction.buttonMode = true;
                }
                else {
                    this.intersection = null;
                    this.playground.cubes.over = null;
                    this.interaction.buttonMode = false;
                }
            };
            Select.prototype.onDown = function (e) {
                if (this.playground.physicsEnabled)
                    return;
                this.onMove(e);
                this.onOver();
                this._startX = this.getX(e);
                this._startY = this.getY(e);
                this.getMouse3D();
                if (!this._marbleSpawning && this.isCube) {
                    this.playground.controls.enabled = false;
                    this.playground.cubes.down = this.intersection.userData.cube;
                    this.playground.map.setAt(cuboro.EMPTY, this.playground.cubes.down.mapPosition);
                }
                else if (!this._marbleSpawning && this.isPlaceable) {
                    if (this.playground.cubes.selected) {
                        var cubePos = this.playground.cubes.selected.mapPosition;
                        var placeablePos = this.intersection.userData;
                        if (placeablePos.x == cubePos.x && placeablePos.z == cubePos.z) {
                            this.playground.controls.enabled = false;
                            this.playground.cubes.down = this.playground.cubes.selected;
                            this.playground.map.setAt(cuboro.EMPTY, this.playground.cubes.down.mapPosition);
                        }
                    }
                }
            };
            Select.prototype.onUp = function (e) {
                if (this.playground.physicsEnabled)
                    return;
                this.onMove(e);
                this.playground.controls.enabled = true;
                if (this._cubeSpawning)
                    this.intersection = this.playground.cubes.down.mesh;
                if (this._marbleSpawning)
                    this.intersection = this.playground.marble.mesh;
                if (!this._marbleSpawning && (this.playground.cubes.down || this.isCube)) {
                    this.placeCube();
                }
                else if (this.isPlaceable) {
                    var mapX = this.intersection.userData.x;
                    var mapZ = this.intersection.userData.z;
                    var isValidY = this.playground.map.isValidY(this.playground.map.getNextEmptyY(mapX, mapZ));
                    if (this.interactionDistance < 10 && this.playground.gameScreen.bottomMenu.cubeList.currentItem != null && isValidY) {
                        this.spawnCubeFromList();
                        this.playground.history.save();
                    }
                    if (this.playground.cubes.selected && this.interactionDistance < 10 && this.playground.gameScreen.moveMenu.visible && isValidY) {
                        this.moveCubeByPos();
                        this.playground.history.save();
                    }
                }
                else if (this.isMarble) {
                    this.placeMarble();
                }
                else if (this.isGround) {
                    this.deselectCube();
                }
                else {
                    this.deselectCube();
                }
                this.interaction.buttonMode = false;
            };
            Select.prototype.placeCube = function () {
                var cube = this.playground.cubes.down || this.intersection.userData.cube;
                if (!this.isCubeOnMap(cube)) {
                    this.playground.cubes.remove(cube);
                    this.playground.history.save();
                }
                else if (this.isDownSameAsUp && this.interactionDistance < 10) {
                    if (this.playground.cubes.swapping) {
                        this.playground.cubes.swap(cube);
                        this.playground.cubes.swapping = null;
                        this.playground.gameScreen.bottomMenu.btSwap.isSelected = false;
                        this.playground.history.save();
                        this.playground.save();
                    }
                    else {
                        this.playground.cubes.selected = cube;
                        this.playground.cubes.update(cube);
                    }
                }
                else {
                    if (this._cubeSpawning) {
                        this.playground.cubes.selected = cube;
                        this.playground.gameScreen.bottomMenu.cubeList.deselectItems();
                        this.playground.placeables.hide();
                    }
                    this.playground.cubes.update(cube);
                    this.playground.history.save();
                    this.playground.save();
                }
                this.playground.cubes.down = null;
                this._cubeSpawning = false;
            };
            Select.prototype.placeMarble = function () {
                if (!this.canMarbleStart) {
                    this.playground.marble.mesh.visible = false;
                }
                else {
                    if (this._marbleTween) {
                        this._marbleTween.progress(1);
                        this._marbleTween.kill();
                    }
                    this.playground.marble.start();
                }
                this._marbleSpawning = false;
                this.playground.cubes.highlightMarble(false);
                this.playground.gameScreen.bottomMenu.onMarbleUp();
            };
            Select.prototype.deselectCube = function () {
                if (this.playground.cubes.selected)
                    this.playground.cubes.selected = null;
                if (this.playground.cubes.swapping)
                    this.playground.cubes.swapping = null;
                if (!this.playground.gameScreen.bottomMenu.cubeList.currentItem)
                    this.playground.placeables.hide();
            };
            Select.prototype.moveMarble = function () {
                var position = this.getMouse3D();
                this.intersection = this.playground.marble.mesh;
                var cube;
                var intersectionCount = this.intersections.length;
                for (var i = 0; i < intersectionCount; ++i) {
                    if (this.intersections[i].object.name.indexOf("cube") != -1 && !cube) {
                        cube = this.intersections[i].object.userData.cube;
                    }
                }
                if (cube) {
                    var mapY = this.playground.map.getNextEmptyY(cube.mapPosition.x, cube.mapPosition.z);
                    position = this.playground.map.to3DPos(cube.mapPosition.x, mapY, cube.mapPosition.z);
                    position.y += cuboro.MARBLE_DROP_HEIGHTS[this.playground.gameScreen.bottomMenu.btDropHeight.dropHeight];
                    this._marbleTween = TweenMax.to(this.playground.marble, 0.15, {
                        x: position.x,
                        y: position.y,
                        z: position.z
                    });
                }
                else {
                    var mapPos = this.playground.map.toMapPos(position.x, this.playground.marble.y, position.z);
                    var mapY = this.playground.map.getNextEmptyY(mapPos.x, mapPos.z);
                    if (mapY != null && this.playground.map.isValidY(mapY)) {
                        position = this.playground.map.to3DPos(mapPos.x, mapY, mapPos.z);
                        position.y += cuboro.MARBLE_DROP_HEIGHTS[this.playground.gameScreen.bottomMenu.btDropHeight.dropHeight];
                        this._marbleTween = TweenMax.to(this.playground.marble, 0.15, {
                            x: position.x,
                            y: position.y,
                            z: position.z
                        });
                    }
                }
            };
            Select.prototype.moveCube = function () {
                var _this = this;
                var position = this.getMouse3D();
                var cube = this.playground.cubes.down;
                if (this._cubeSpawning)
                    this.intersection = this.playground.cubes.down.mesh;
                var hitCube;
                var intersection;
                var intersectionCount = this.intersections.length;
                for (var i = 0; i < intersectionCount; ++i) {
                    intersection = this.intersections[i].object;
                    if (intersection.name.indexOf("cube") != -1 && !hitCube && intersection.userData.cube != cube) {
                        hitCube = intersection.userData.cube;
                    }
                }
                if (hitCube) {
                    var mapY = this.playground.map.getNextEmptyY(hitCube.mapPosition.x, hitCube.mapPosition.z);
                    position = this.playground.map.to3DPos(hitCube.mapPosition.x, mapY, hitCube.mapPosition.z);
                    if (this.playground.map.isValidY(mapY)) {
                        cube.mapPosition.set(hitCube.mapPosition.x, mapY, hitCube.mapPosition.z);
                        TweenMax.to(cube, 0.25, {
                            x: position.x,
                            y: position.y,
                            z: position.z,
                            onComplete: function () { return _this.playground.emit(cuboro.CUBE_UPDATE); }
                        });
                    }
                }
                else if (this.isCubeOnMap(cube)) {
                    var mapPos = this.playground.map.toMapPos(position.x, cube.y, position.z);
                    var mapY = this.playground.map.getNextEmptyY(mapPos.x, mapPos.z);
                    if (mapY != null && this.playground.map.isValidY(mapY)) {
                        position = this.playground.map.to3DPos(mapPos.x, mapY, mapPos.z);
                        cube.mapPosition.set(mapPos.x, mapY, mapPos.z);
                        TweenMax.to(cube, 0.25, {
                            x: position.x,
                            y: position.y,
                            z: position.z,
                            onComplete: function () { return _this.playground.emit(cuboro.CUBE_UPDATE); }
                        });
                    }
                }
                else {
                    cube.x = position.x;
                    cube.z = position.z;
                }
            };
            Select.prototype.moveCubeByPos = function () {
                var _this = this;
                var position = this.getMouse3D();
                var cube = this.playground.cubes.selected;
                var mapPos = this.playground.map.toMapPos(position.x, position.y, position.z);
                var mapY = this.playground.map.getNextEmptyY(mapPos.x, mapPos.z);
                if (mapY != null && this.playground.map.isValidY(mapY)) {
                    this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                    position = this.playground.map.to3DPos(mapPos.x, mapY, mapPos.z);
                    cube.mapPosition.set(mapPos.x, mapY, mapPos.z);
                    this.playground.map.map[mapPos.x][mapY][mapPos.z] = cube.id;
                    TweenMax.to(cube, 0.25, {
                        x: position.x,
                        y: position.y,
                        z: position.z,
                        onComplete: function () { return _this.playground.emit(cuboro.CUBE_UPDATE); },
                    });
                    this.playground.placeables.update();
                }
            };
            Select.prototype.getIntersects = function () {
                var vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5).unproject(this.playground.camera);
                var raycaster = new THREE.Raycaster(this.playground.camera.position, vector.sub(this.playground.camera.position).normalize());
                return raycaster.intersectObjects(this.playground.scene.children);
            };
            Select.prototype.spawnCube = function (e, key) {
                this._cubeSpawning = true;
                this._startX = this._lastX = this.getX(e);
                this._startY = this._lastY = this.getY(e);
                var position = this.getMouse3D();
                this.playground.cubes.down = new cuboro.core.Cube(this.playground, key);
                this.playground.cubes.down.x = position.x;
                this.playground.cubes.down.y = 1;
                this.playground.cubes.down.z = position.z;
                this.moveCube();
            };
            Select.prototype.spawnMarble = function (e) {
                this.playground.resetView();
                this._marbleSpawning = true;
                this._startX = this._lastX = this.getX(e);
                this._startY = this._lastY = this.getY(e);
                var position = this.getMouse3D();
                this.playground.marble.x = position.x;
                this.playground.marble.y = 1;
                this.playground.marble.z = position.z;
                this.playground.marble.mesh.visible = true;
                this.playground.cubes.highlightMarble(true);
            };
            Select.prototype.getX = function (e) {
                this._lastX = (e.touches && e.touches.length > 0) ? e.touches[0].pageX : e.pageX || (e.clientX || this._lastX);
                return this._lastX;
            };
            Select.prototype.getY = function (e) {
                this._lastY = (e.touches && e.touches.length > 0) ? e.touches[0].pageY : e.pageY || (e.clientY || this._lastY);
                return this._lastY;
            };
            Select.prototype.isCubeOnMap = function (cube) {
                var onMap = this.playground.map.onMap3D(cube.x, cube.z);
                if (!onMap)
                    return false;
                var mapPosition = cube.mapPosition;
                return this.playground.map.isValid(mapPosition.x, mapPosition.y, mapPosition.z);
            };
            Object.defineProperty(Select.prototype, "canMarbleStart", {
                get: function () {
                    var marbleMap = this.playground.map.toMapPos(this.playground.marble.mesh.position);
                    var cube = this.playground.cubes.getHighestCube(marbleMap.x, marbleMap.z);
                    return (!!cube);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Select.prototype, "isCube", {
                get: function () {
                    if (!this.intersection)
                        return false;
                    return this.intersection.name.indexOf("cube") != -1;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Select.prototype, "isGround", {
                get: function () {
                    if (!this.intersection)
                        return false;
                    return this.intersection.name.indexOf("ground") != -1;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Select.prototype, "isMarble", {
                get: function () {
                    if (!this.intersection)
                        return false;
                    return this.intersection.name == "marble";
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Select.prototype, "isPlaceable", {
                get: function () {
                    if (!this.intersection)
                        return false;
                    return this.intersection.name.indexOf("placeable") != -1;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Select.prototype, "isDownSameAsUp", {
                get: function () {
                    if (!this.playground.cubes.down)
                        return false;
                    if (!this.intersection)
                        return false;
                    if (!this.intersection.userData.cube)
                        return false;
                    return this.playground.cubes.down == this.intersection.userData.cube;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(Select.prototype, "interactionDistance", {
                get: function () {
                    return gf.utils.Maths.distance(this._startX, this._startY, this._lastX, this._lastY);
                },
                enumerable: true,
                configurable: true
            });
            return Select;
        }());
        core.Select = Select;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Playground = (function (_super) {
            __extends(Playground, _super);
            function Playground(gameScreen) {
                var _this = _super.call(this) || this;
                _this.physicSpeedFactor = 1;
                mTests.pg = _this;
                _this._isSaving = false;
                _this.game = gameScreen.game;
                _this.gameScreen = gameScreen;
                _this.world = new CANNON.World();
                _this.world.bodies = [];
                _this.world.gravity.set(0, -50, 0);
                _this.world.defaultContactMaterial.friction = 0.0018;
                _this.world.defaultContactMaterial.restitution = 0;
                _this.camera = new THREE.PerspectiveCamera(50, _this.game.width / _this.game.height, 1, 100);
                _this.camera.rotation.set(-cuboro.DEG_RAD_90, 10, cuboro.DEG_RAD_90);
                _this.scene = new THREE.Scene();
                _this.scene.add(_this.camera);
                var hemiLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.75);
                hemiLight.position.set(12, 500, 12);
                _this.scene.add(hemiLight);
                _this.spotLight = new THREE.SpotLight(0xffffff, 0.5, 200);
                var camera = _this.spotLight.shadow.camera;
                camera.near = _this.camera.near;
                camera.far = _this.camera.far;
                camera.fov = _this.camera.fov;
                _this.spotLight.target.position.set(12, 0, 12);
                _this.scene.add(_this.spotLight);
                var controlsSettings = new cuboro.core.ControlsSettings();
                controlsSettings.interaction = _this.gameScreen.interaction;
                controlsSettings.camera = _this.camera;
                controlsSettings.lookAt = new THREE.Vector3(0, 0, 0);
                _this.controls = new cuboro.core.Controls(_this, controlsSettings);
                _this.cubes = new cuboro.core.Cubes(_this);
                _this.history = new cuboro.core.History(_this);
                _this.evaluation = new cuboro.core.Evaluation(_this);
                _this.map = new cuboro.core.Map(_this);
                _this.select = new cuboro.core.Select(_this);
                _this.assets = new cuboro.core.Assets(_this);
                _this.cubeOpacity = 1;
                _this.elementMargin = 0;
                _this.layerMargin = 0;
                _this.game.on(gf.RESIZE, _this.onResize, _this);
                return _this;
            }
            Playground.prototype.load = function () {
                var assetLoader = new cuboro.core.AssetLoader(this.game, this.assets);
                assetLoader.texture("cube-hit1", "img/texture-cube-hit1.png");
                assetLoader.texture("cube-hit2", "img/texture-cube-hit2.png");
                assetLoader.texture("cube-hit3", "img/texture-cube-hit3.png");
                assetLoader.texture("cube-hit4", "img/texture-cube-hit4.png");
                assetLoader.texture("cube-out", "img/texture-cube-out.png");
                assetLoader.texture("cube-over", "img/texture-cube-over.png");
                assetLoader.texture("cube-down", "img/texture-cube-down.png");
                assetLoader.texture("cube-highlight", "img/texture-cube-highlight.png");
                assetLoader.texture("cube-selected", "img/texture-cube-selected.png");
                assetLoader.texture("ground", "img/ground.png");
                assetLoader.texture("unplaceable", "img/unplaceable.png");
                assetLoader.texture("marble", "img/marble.jpg");
                var cubes = this.gameScreen.bottomMenu.cubeList.getItems();
                cubes.forEach(function (value) { return assetLoader.threeJSON(value.key, "models/" + value.key + ".json"); });
                assetLoader.on(gf.LOAD_COMPLETE, this.loadComplete, this);
                assetLoader.start();
            };
            Playground.prototype.loadComplete = function () {
                if (!this.ground)
                    this.ground = new cuboro.core.Ground(this);
                if (!this.placeables)
                    this.placeables = new cuboro.core.Placeables(this);
                if (!this.marble)
                    this.marble = new cuboro.core.Marble(this);
                if (mTrack.data.cubes) {
                    this.cubes.setCubes(mTrack.data.cubes);
                    if (mTrack.data.evaluation)
                        this.evaluation.current = mTrack.data.evaluation;
                }
                this.emit(cuboro.PLAYGROUND_READY);
            };
            Playground.prototype.onResize = function () {
                this.camera.aspect = this.game.width / this.game.height;
                this.camera.updateProjectionMatrix();
                if (this.canvas)
                    this.canvas.onResize();
            };
            Playground.prototype.resetView = function () {
                if (this.elementMargin > 0)
                    this.elementMargin = this.gameScreen.bottomMenu.elementMargin = 0;
                if (this.layerMargin > 0)
                    this.layerMargin = this.gameScreen.bottomMenu.layerMargin = 0;
            };
            Playground.prototype.save = function () {
                var _this = this;
                if (this._isSaving || !mUser.isLoggedIn())
                    return;
                this._isSaving = true;
                if (mTrack.id && !mTrack.imageUrl) {
                    this.saveImage();
                }
                var data = new cuboro.vo.TrackData();
                data.cubes = this.cubes.getCubes();
                data.evaluation = this.evaluation.current;
                data.sets = mTrack.data.sets;
                var name = this.game.stage.header.trackMenu.trackName.value;
                if (!mTrack.owner) {
                    this.saveDupe(data);
                    return;
                }
                if (mTrack.owner.id != mUser.getUserId()) {
                    this.saveDupe(data);
                    return;
                }
                this.saveId = window.setTimeout(function () { return _this.saveTimeout(); }, 10000);
                sTrack.save(data, name, true, null, function (savedTrack, status) {
                    clearTimeout(_this.saveId);
                    if (status == "ERROR_IS_NOT_TRACK_OWNER") {
                        log(loc("error_track_name_taken"));
                    }
                    else if (status == "ERROR_TRACK_NAME_NOT_OVERWRITTEN") {
                        log(loc("error_track_name_taken_own"));
                    }
                    else if (status == kr3m.SUCCESS) {
                        _this.game.stage.header.trackMenu.tfSaved.text = locDate("track_info_saved", savedTrack.lastSavedWhen);
                        mTrack = savedTrack;
                        if (!mTrack.imageUrl)
                            _this.saveImage();
                    }
                    _this._isSaving = false;
                });
            };
            Playground.prototype.saveDupe = function (data) {
                var _this = this;
                mTrack.owner = mUser.getUser();
                sTrack.generateUniqueRandomName(loc("trackname_prefix"), function (response) {
                    mTrack.name = response;
                    _this.game.stage.header.trackMenu.trackName.value = mTrack.name;
                    _this.saveId = window.setTimeout(function () { return _this.saveTimeout(); }, 10000);
                    sTrack.save(data, mTrack.name, true, mTrack.id, function (savedTrack, status) {
                        clearTimeout(_this.saveId);
                        if (status == "ERROR_IS_NOT_TRACK_OWNER") {
                            log(loc("error_track_name_taken"));
                        }
                        else if (status == "ERROR_TRACK_NAME_NOT_OVERWRITTEN") {
                            log(loc("error_track_name_taken_own"));
                        }
                        else if (status == kr3m.SUCCESS) {
                            _this.game.stage.header.trackMenu.tfSaved.text = locDate("track_info_saved", savedTrack.lastSavedWhen);
                            mTrack = savedTrack;
                            if (!mTrack.imageUrl)
                                _this.saveImage();
                        }
                        _this._isSaving = false;
                    });
                });
            };
            Playground.prototype.saveImage = function () {
                var _this = this;
                cuboro.ui.TrackPreview.GetBase64(this, 300, function (value) {
                    sTrack.saveTrackImage(mTrack.id, mTrack.name, value, function (imageUrl) {
                        mTrack.imageUrl = imageUrl;
                        _this._isSaving = false;
                    });
                });
            };
            Playground.prototype.saveTimeout = function () {
                clearTimeout(this.saveId);
                if (navigator.onLine)
                    this.game.stage.header.trackMenu.tfSaved.text = loc("error_save");
                else
                    this.game.stage.header.trackMenu.tfSaved.text = loc("error_save_offline");
                this._isSaving = false;
            };
            Playground.prototype.start = function () {
                var _this = this;
                if (this._isRunning)
                    return;
                this._isRunning = true;
                if (!this.canvas)
                    this.canvas = cuboro.core.Canvas.getInstance(this.game, function (elapsed) { return _this.update(elapsed); });
                this.canvas.start();
                this.history.reset();
                this.history.save();
                this.load();
            };
            Playground.prototype.stop = function () {
                if (!this._isRunning)
                    return;
                this._isRunning = false;
                this.canvas.stop();
                this.reset();
            };
            Playground.prototype.reset = function () {
                this.cubes.removeCubes();
                this.history.reset();
                this.gameScreen.moveMenu.hide();
                this.gameScreen.rotateMenu.hide();
            };
            Playground.prototype.update = function (elapsed) {
                if (this._physicsEnabled) {
                    elapsed *= this.physicSpeedFactor * 0.001;
                    this.accumulator += elapsed;
                    while (this.accumulator >= cuboro.TIMESTEP) {
                        this.world.step(cuboro.TIMESTEP);
                        this.marble.update();
                        this.accumulator -= cuboro.TIMESTEP;
                    }
                    this.elapsedMS += elapsed;
                }
                else {
                    this.accumulator = 0;
                }
                this.canvas.renderer.render(this.scene, this.camera);
            };
            Object.defineProperty(Playground.prototype, "physicsEnabled", {
                get: function () {
                    return this._physicsEnabled;
                },
                set: function (value) {
                    if (value)
                        this.elapsedMS = 0;
                    this._physicsEnabled = value;
                },
                enumerable: true,
                configurable: true
            });
            return Playground;
        }(PIXI.utils.EventEmitter));
        core.Playground = Playground;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var display;
    (function (display) {
        var MultiStyleText = (function (_super) {
            __extends(MultiStyleText, _super);
            function MultiStyleText(game, text, style, styles) {
                var _this = _super.call(this, game, text, style) || this;
                _this._textStyles = {};
                if (styles)
                    _this.createTextStyles(styles);
                return _this;
            }
            MultiStyleText.prototype.createTextStyles = function (styles) {
                if (!styles)
                    return;
                this._textStyles = {};
                for (var styleId in styles) {
                    this._textStyles[styleId] = this._style["clone"]();
                    for (var style in styles[styleId]) {
                        this._textStyles[styleId][style] = styles[styleId][style];
                    }
                }
                this.dirty = true;
            };
            MultiStyleText.prototype.createTextData = function (text, style) {
                return {
                    text: text,
                    style: style,
                    width: 0,
                    height: 0,
                    fontProperties: null
                };
            };
            MultiStyleText.prototype.getTextDataPerLine = function (lines) {
                var outputTextData = [];
                if (!this._textStyles)
                    this._textStyles = {};
                var tags = Object.keys(this._textStyles).join('|');
                var re = new RegExp("<\/?(" + tags + ")>", "g");
                var currentStyle = this.style;
                for (var i = 0; i < lines.length; i++) {
                    var lineTextData = [];
                    var matches = [];
                    var matchArray = void 0;
                    while ((matchArray = re.exec(lines[i])) !== null && matches.push(matchArray))
                        ;
                    if (!matches.length) {
                        lineTextData.push(this.createTextData(lines[i], currentStyle));
                    }
                    else {
                        var currentSearchIdx = 0;
                        for (var j = 0; j < matches.length; j++) {
                            if (matches[j].index > currentSearchIdx) {
                                lineTextData.push(this.createTextData(lines[i].substring(currentSearchIdx, matches[j].index), currentStyle));
                            }
                            if (matches[j][0][1] == '/')
                                currentStyle = this.style;
                            else
                                currentStyle = this._textStyles[matches[j][1]] || this.style;
                            currentSearchIdx = matches[j].index + matches[j][0].length;
                        }
                        if (currentSearchIdx < lines[i].length) {
                            lineTextData.push({
                                text: lines[i].substring(currentSearchIdx),
                                style: currentStyle
                            });
                        }
                    }
                    outputTextData.push(lineTextData);
                }
                return outputTextData;
            };
            MultiStyleText.prototype.getFont = function (style) {
                var fontSizeString = (typeof style.fontSize === 'number') ? style.fontSize + "px" : style.fontSize;
                var fontFamilies;
                if (!Array.isArray(style.fontFamily)) {
                    fontFamilies = style.fontFamily.split(',');
                }
                else {
                    fontFamilies = style.fontFamily;
                }
                for (var i = fontFamilies.length - 1; i >= 0; i--) {
                    var fontFamily = fontFamilies[i].trim();
                    if (!(/([\"\'])[^\'\"]+\1/).test(fontFamily)) {
                        fontFamily = "\"" + fontFamily + "\"";
                    }
                    fontFamilies[i] = fontFamily;
                }
                return style.fontStyle + " " + style.fontVariant + " " + style.fontWeight + " " + fontSizeString + " " + fontFamilies.join(',');
            };
            MultiStyleText.prototype.updateText = function (respectDirty) {
                var _this = this;
                if (this.localStyleID !== this._style.styleID) {
                    this.dirty = true;
                    this.localStyleID = this._style.styleID;
                }
                if (!this.dirty && respectDirty) {
                    return;
                }
                var outputText = this._style.wordWrap ? this.wordWrap(this._text) : this._text;
                var lines = outputText.split(/(?:\r\n|\r|\n)/);
                var lineWidths = new Array(lines.length);
                var lineHeights = new Array(lines.length);
                var maxLineWidth = 0;
                var outputTextData = this.getTextDataPerLine(lines);
                var i, j;
                var lineWidth, lineHeight;
                var fontProperties;
                for (i = 0; i < lines.length; i++) {
                    lineWidth = 0;
                    lineHeight = 0;
                    for (j = 0; j < outputTextData[i].length; j++) {
                        this.context.font = this.getFont(outputTextData[i][j].style);
                        fontProperties = outputTextData[i][j].fontProperties = PIXI.Text.calculateFontProperties(this.getFont(outputTextData[i][j].style));
                        outputTextData[i][j].width = this.context.measureText(outputTextData[i][j].text).width;
                        outputTextData[i][j].height = Math.max(outputTextData[i][j].fontProperties.fontSize, outputTextData[i][j].style.fontSize + outputTextData[i][j].style.strokeThickness, outputTextData[i][j].style.lineHeight);
                        lineWidth += outputTextData[i][j].width;
                        if (outputTextData[i][j].style.lineHeight != 0) {
                            lineHeight = Math.max(lineHeight, outputTextData[i][j].style.lineHeight);
                        }
                        else {
                            lineHeight = Math.max(lineHeight, outputTextData[i][j].height);
                        }
                    }
                    lineWidths[i] = lineWidth;
                    lineHeights[i] = lineHeight;
                    maxLineWidth = Math.max(maxLineWidth, lineWidth);
                }
                if (this.style.wordWrap && this.style.wordWrapWidth) {
                    maxLineWidth = Math.max(maxLineWidth, this.style.wordWrapWidth);
                }
                var stylesArray = Object.keys(this._textStyles).map(function (k) {
                    return _this._textStyles[k];
                });
                var maxStrokeThickness = stylesArray.reduce(function (prev, curr) {
                    return Math.max(prev, curr.strokeThickness);
                }, 0);
                var maxDropShadowDistance = stylesArray.reduce(function (prev, curr) {
                    var value = curr.dropShadow ? curr.dropShadowDistance : 0;
                    return Math.max(prev, value);
                }, 0);
                var maxPadding = stylesArray.reduce(function (prev, curr) {
                    return Math.max(prev, curr.padding);
                }, 0);
                var width = maxLineWidth + maxDropShadowDistance;
                width += maxPadding * 2;
                this.canvas.width = Math.ceil((width + this.context.lineWidth) * this.resolution);
                var height = (Math.max.apply(null, lineHeights) * lines.length) + maxDropShadowDistance;
                height += maxPadding * 2;
                this.canvas.height = height * this.resolution;
                this.context.scale(this.resolution, this.resolution);
                this.context.textBaseline = this._style.textBaseline;
                this.context.lineJoin = this._style.lineJoin;
                this.context.miterLimit = this._style.miterLimit;
                var linePositionX, linePositionY;
                var totalLineHeight = 0;
                for (i = 0; i < outputTextData.length; i++) {
                    var line = outputTextData[i];
                    var spacesCount = 0;
                    var wordsWidth = 0;
                    var justifySpacing = 0;
                    var doJustify = (this.style.align === gf.JUSTIFY) && (i < (outputTextData.length - 1));
                    if (doJustify) {
                        for (j = 0; j < line.length; j++) {
                            var textStyle = line[j].style;
                            var text = line[j].text;
                            this.context.font = textStyle.font;
                            this.context.strokeStyle = textStyle.stroke;
                            this.context.lineWidth = textStyle.strokeThickness;
                            this.context.fillStyle = this._generateFillStyle(textStyle.fill, [line[j].text]);
                            var words = text.split(' ');
                            for (var k = 0; k < words.length; k++) {
                                if (k < (words.length - 1)) {
                                    wordsWidth += this.context.measureText(words[k] + " ").width;
                                    spacesCount++;
                                }
                                else {
                                    wordsWidth += this.context.measureText(words[k]).width;
                                }
                            }
                        }
                        if (spacesCount > 0) {
                            justifySpacing = (maxLineWidth - wordsWidth) / spacesCount;
                        }
                    }
                    linePositionX = 0;
                    for (j = 0; j < line.length; j++) {
                        var textStyle = line[j].style;
                        var text = line[j].text;
                        var fontProperties_1 = line[j].fontProperties;
                        this.context.font = textStyle.font;
                        this.context.strokeStyle = textStyle.stroke;
                        this.context.lineWidth = textStyle.strokeThickness;
                        linePositionX += maxStrokeThickness * 0.5;
                        linePositionY = (maxStrokeThickness * 0.5 + totalLineHeight) + fontProperties_1.ascent;
                        linePositionY -= lineHeights[i] - line[j].height - (maxStrokeThickness - textStyle.strokeThickness) * 0.5;
                        var doJustifyLine = doJustify;
                        var alg = this.style.align;
                        if (alg == gf.JUSTIFY) {
                            if (i == (outputTextData.length - 1)) {
                                doJustifyLine = false;
                                alg = this._lastLineAlign;
                            }
                            if (spacesCount == 0) {
                                doJustifyLine = false;
                                alg = this._lastLineAlign;
                            }
                        }
                        if (alg == gf.RIGHT && linePositionX === 0) {
                            linePositionX += maxLineWidth - lineWidths[i];
                        }
                        else if (alg == gf.CENTER && linePositionX === 0) {
                            linePositionX += (maxLineWidth - lineWidths[i]) * 0.5;
                        }
                        if (this._verticalAlign == gf.BOTTOM) {
                            linePositionY += (lineHeights[i] - line[j].height) * 2 - (maxStrokeThickness - textStyle.strokeThickness) * 0.5;
                        }
                        else if (this._verticalAlign == gf.CENTER) {
                            linePositionY += (lineHeights[i] - line[j].height) * 0.5 - (maxStrokeThickness - textStyle.strokeThickness) * 0.5;
                        }
                        this.context.fillStyle = this._generateFillStyle(textStyle, [line[j].text]);
                        if (textStyle.dropShadow) {
                            this.context.fillStyle = textStyle.dropShadowColor;
                            var xShadowOffset = Math.sin(textStyle.dropShadowAngle) * textStyle.dropShadowDistance;
                            var yShadowOffset = Math.cos(textStyle.dropShadowAngle) * textStyle.dropShadowDistance;
                            if (textStyle.fill) {
                                this.drawLetterSpacing(text, linePositionX + xShadowOffset, linePositionY + yShadowOffset);
                            }
                        }
                        this.context.fillStyle = this._generateFillStyle(textStyle.fill, [line[j].text]);
                        if (doJustifyLine) {
                            if (textStyle.stroke && textStyle.strokeThickness) {
                                line[j].width = this.drawLetterSpacingJustify(text, linePositionX, linePositionY, true, justifySpacing);
                            }
                            if (textStyle.fill) {
                                line[j].width = this.drawLetterSpacingJustify(text, linePositionX, linePositionY, false, justifySpacing);
                            }
                        }
                        else {
                            if (textStyle.stroke && textStyle.strokeThickness) {
                                this.drawLetterSpacing(text, linePositionX, linePositionY, true);
                            }
                            if (textStyle.fill) {
                                this.drawLetterSpacing(text, linePositionX, linePositionY);
                            }
                        }
                        linePositionX += line[j].width;
                        linePositionX -= maxStrokeThickness * 0.5;
                    }
                    totalLineHeight += lineHeights[i];
                }
                this.updateTexture();
                this.onResize();
            };
            MultiStyleText.prototype.drawLetterSpacingJustify = function (text, x, y, isStroke, justifySpacing) {
                var width = 0;
                var words = text.split(' ');
                for (var i = 0; i < words.length; i++) {
                    this.drawLetterSpacing(words[i], Math.floor(x + width + 0.5), y, isStroke);
                    if (i < (words.length - 1)) {
                        width += this.context.measureText(words[i] + " ").width + justifySpacing;
                    }
                    else {
                        width += this.context.measureText(words[i]).width;
                    }
                }
                return width;
            };
            MultiStyleText.prototype.stripTags = function (text) {
                for (var styleId in this._textStyles) {
                    text = text.replace(new RegExp("<\/?(" + styleId + ")>", "g"), "");
                }
                return text;
            };
            MultiStyleText.prototype.wordWrap = function (text) {
                var result = '';
                var lines = text.split('\n');
                var wordWrapWidth = this._style.wordWrapWidth;
                var allwords = [];
                for (var i = 0; i < lines.length; i++) {
                    var words = lines[i].split(' ');
                    allwords = allwords.concat(words);
                }
                var outputTextData = this.getTextDataPerLine(allwords);
                var wordStyleIndex = 0;
                for (var i = 0; i < lines.length; i++) {
                    var spaceLeft = wordWrapWidth;
                    var words = lines[i].split(' ');
                    for (var j = 0; j < words.length; j++) {
                        if (outputTextData[wordStyleIndex].length == 0) {
                        }
                        else {
                            this.context.font = this.getFont(outputTextData[wordStyleIndex][0].style);
                            var wordWidth = this.context.measureText(this.stripTags(words[j])).width;
                            if (this._style.breakWords && wordWidth > wordWrapWidth) {
                                var characters = words[j].split('');
                                for (var c = 0; c < characters.length; c++) {
                                    var characterWidth = this.context.measureText(characters[c]).width;
                                    if (characterWidth > spaceLeft) {
                                        result += '\n' + characters[c];
                                        spaceLeft = wordWrapWidth - characterWidth;
                                    }
                                    else {
                                        if (c === 0) {
                                            result += ' ';
                                        }
                                        result += characters[c];
                                        spaceLeft -= characterWidth;
                                    }
                                }
                            }
                            else {
                                var wordWidthWithSpace = wordWidth + this.context.measureText(' ').width;
                                if (j === 0 || wordWidthWithSpace > spaceLeft) {
                                    if (j > 0) {
                                        result += '\n';
                                    }
                                    result += words[j];
                                    spaceLeft = wordWrapWidth - wordWidth;
                                }
                                else {
                                    spaceLeft -= wordWidthWithSpace;
                                    result += ' ' + words[j];
                                }
                            }
                        }
                        wordStyleIndex++;
                    }
                    if (i < lines.length - 1) {
                        result += '\n';
                    }
                }
                return result;
            };
            Object.defineProperty(MultiStyleText.prototype, "textStyles", {
                get: function () {
                    return this._textStyles;
                },
                set: function (value) {
                    this.createTextStyles(value);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MultiStyleText.prototype, "verticalAlign", {
                get: function () {
                    return this._verticalAlign;
                },
                set: function (value) {
                    if (value == this._verticalAlign)
                        return;
                    this._verticalAlign = value;
                    this.dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(MultiStyleText.prototype, "lastLineAlign", {
                get: function () {
                    return this._lastLineAlign;
                },
                set: function (value) {
                    if (value == this._lastLineAlign)
                        return;
                    this._lastLineAlign = value;
                    this.dirty = true;
                },
                enumerable: true,
                configurable: true
            });
            return MultiStyleText;
        }(gf.display.Text));
        display.MultiStyleText = MultiStyleText;
    })(display = gf.display || (gf.display = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var CubeListItem = (function (_super) {
            __extends(CubeListItem, _super);
            function CubeListItem(cubeList, id, count, index) {
                var _this = _super.call(this, cubeList.game) || this;
                _this.cubeList = cubeList;
                _this.key = "cube_" + id;
                _this._count = count;
                _this._id = id;
                _this._remaining = count;
                _this._index = index;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.bg.width =
                    _this.bg.height = 65;
                _this.addChild(_this.bg);
                _this.cube = new gf.display.Sprite(_this.game, "sprites", _this.key);
                _this.cube.width = _this.bg.width;
                _this.cube.height = _this.bg.height;
                _this.addChild(_this.cube);
                _this.tfLabel = new gf.display.Text(_this.game, loc(_this.key), cuboro.TEXT_STYLE_BUTTON_ICON.clone());
                _this.tfLabel.anchor.set(0.5, 1);
                _this.tfLabel.x = _this.bg.width >> 1;
                _this.tfLabel.y = _this.bg.height;
                _this.addChild(_this.tfLabel);
                _this.tfCount = new gf.display.Text(_this.game, loc("cubes_count", {
                    count: _this._count,
                    remaining: _this._count
                }), cuboro.TEXT_STYLE_BUTTON_ICON.clone());
                _this.tfCount.style.fontFamily = cuboro.DEFAULT_FONT_HEAVY;
                _this.tfCount.x = 2;
                _this.addChild(_this.tfCount);
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                return _this;
            }
            CubeListItem.prototype.setState = function (state) {
                if (this._isSelected) {
                    this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.OUT:
                        this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                        }
                        else {
                            this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        }
                        break;
                }
            };
            Object.defineProperty(CubeListItem.prototype, "count", {
                get: function () {
                    return this._count;
                },
                set: function (value) {
                    this._count = value;
                    this.tfCount.text = loc("cubes_count", { count: this._count, remaining: this._remaining });
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CubeListItem.prototype, "id", {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CubeListItem.prototype, "index", {
                get: function () {
                    return this._index;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CubeListItem.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    if (value == this._isSelected)
                        return;
                    this._isSelected = value;
                    this.setState(this.currentState);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CubeListItem.prototype, "remaining", {
                get: function () {
                    return this._remaining;
                },
                set: function (value) {
                    this._remaining = value;
                    this.tfCount.text = loc("cubes_count", {
                        count: this._count, remaining: this._remaining
                    });
                    this.cubeList.updateUsed();
                    this.alpha = this._remaining > 0 ? 1 : 0.5;
                },
                enumerable: true,
                configurable: true
            });
            return CubeListItem;
        }(gf.ui.Button));
        ui.CubeListItem = CubeListItem;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var CubeList = (function (_super) {
            __extends(CubeList, _super);
            function CubeList(bottomMenu) {
                var _this = _super.call(this, bottomMenu.game) || this;
                _this.bottomMenu = bottomMenu;
                _this.interactive = true;
                _this.items = [];
                _this.scrollEnd = 0;
                _this._total = 0;
                _this.listMask = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.listMask.height = 135;
                _this.addChild(_this.listMask);
                _this.scrollbar = new cuboro.ui.Scrollbar(_this.game);
                _this.scrollbar.on(gf.UPDATE, _this.onScrollbar, _this);
                _this.addChild(_this.scrollbar);
                _this.list = new gf.display.Container(_this.game);
                _this.list.interactive = true;
                _this.list.mask = _this.listMask;
                _this.addChild(_this.list);
                _this.bounds = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                _this.bounds.on("touchstart mousedown", _this.onDown, _this);
                _this.bounds.interactive = true;
                _this.list.addChild(_this.bounds);
                _this.sets = _this.game.cache.getJSON("sets");
                return _this;
            }
            CubeList.prototype.onScrollbar = function () {
                this.bounds.width =
                    this.bounds.height = 1;
                this._minY = this.listMask.y - this.list.height + this.listMask.height;
                this.bounds.width = this.listMask.width;
                this.bounds.height = this.scrollbar.sizeScroll;
            };
            CubeList.prototype.onDown = function (e) {
                if (this._isDragging)
                    return;
                if (!this.scrollbar.visible)
                    return;
                this.on("mouseup mouseupoutside touchend touchendoutside", this.onUp, this);
                this._dragDistance = 0;
                this.onMove(e);
            };
            CubeList.prototype.onMove = function (e) {
                if (this._isDragging) {
                    var py = e.data.global.y - this._dragStart;
                    this.list.y = Math.min(this.listMask.y, Math.max(this._minY, this._startY + py));
                    this.scrollbar.updateToContentPosition();
                }
                else {
                    this._isDragging = true;
                    this._dragStart = e.data.global.y;
                    this._startY = this.list.y;
                    this.on("mousemove touchmove", this.onMove, this);
                    this.emit(gf.DRAG_START);
                }
            };
            CubeList.prototype.onUp = function () {
                if (this._isDragging) {
                    this._isDragging = false;
                    this.removeAllListeners("mousemove mouseup mouseupoutside touchmove touchend touchendoutside");
                }
            };
            CubeList.prototype.selectItem = function (item) {
                if (this.currentItem)
                    this.currentItem.isSelected = false;
                if (this.currentItem == item) {
                    this.currentItem = null;
                    this.bottomMenu.gameScreen.playground.placeables.hide();
                }
                else {
                    this.currentItem = item;
                    this.bottomMenu.gameScreen.playground.placeables.show();
                }
                this.bottomMenu.gameScreen.playground.cubes.selected = null;
            };
            CubeList.prototype.onItemClick = function (e) {
                var item = e.currentTarget;
                var playground = this.bottomMenu.gameScreen.playground;
                if (item.remaining === 0)
                    return;
                if (playground.cubes.swapping) {
                    this.deselectItems();
                    var cubeDeleteId = playground.cubes.selected.id;
                    var cube = new cuboro.core.Cube(playground, item.key);
                    playground.cubes.swap(cube);
                    playground.cubes.remove(playground.cubes.getById(cubeDeleteId));
                    playground.cubes.selected = cube;
                    item.remaining--;
                }
                else {
                    if (item.isSelected) {
                        this.deselectItems();
                    }
                    else {
                        item.isSelected = true;
                        this.bottomMenu.gameScreen.moveMenu.hide();
                        this.bottomMenu.gameScreen.rotateMenu.hide();
                    }
                    this.selectItem(item);
                }
            };
            CubeList.prototype.onItemDown = function (e) {
                var _this = this;
                var item = e.currentTarget;
                if (item.remaining > 0) {
                    this.dragStart = e.data.global.clone();
                    item.on("mousemove touchmove", function (e) { return _this.onItemMove(e); });
                }
            };
            CubeList.prototype.onItemMove = function (e) {
                var item = e.currentTarget;
                if (!this.itemSpawned && gf.utils.Maths.distance(this.dragStart, e.data.global) > 10) {
                    item.remaining--;
                    this.itemSpawned = true;
                    this.selectItem(item);
                    this.bottomMenu.gameScreen.playground.cubes.selected = null;
                    this.bottomMenu.gameScreen.playground.select.spawnCube(e.data.originalEvent, item.key);
                }
            };
            CubeList.prototype.onItemUp = function (e) {
                var item = e.currentTarget;
                item.removeAllListeners("mousemove touchmove");
                this.itemSpawned = false;
            };
            CubeList.prototype.addItem = function (id, count, index) {
                var item = this.getItemById(id);
                if (!item) {
                    item = new cuboro.ui.CubeListItem(this, id, count, index);
                    item.on(gf.CLICK, this.onItemClick, this);
                    item.on(gf.DOWN, this.onItemDown, this);
                    item.on(gf.UP, this.onItemUp, this);
                    this.list.addChild(item);
                    this.items.push(item);
                }
                else {
                    item.count += count;
                    item.remaining += count;
                }
                this._total += count;
            };
            CubeList.prototype.addSet = function (name) {
                var _this = this;
                this.sets[name].forEach(function (value) {
                    _this.addItem(value[0], value[1], value[2]);
                });
            };
            CubeList.prototype.deselectItems = function () {
                if (this.currentItem)
                    this.currentItem.isSelected = false;
                this.currentItem = null;
                this.bottomMenu.gameScreen.playground.placeables.hide();
            };
            CubeList.prototype.getItems = function () {
                return this.items;
            };
            CubeList.prototype.getItemByKey = function (key) {
                var item = null;
                this.items.forEach(function (value) {
                    if (value.key === key) {
                        item = value;
                        return true;
                    }
                });
                return item;
            };
            CubeList.prototype.getItemById = function (id) {
                var item = null;
                this.items.forEach(function (value) {
                    if (value.id === id) {
                        item = value;
                        return true;
                    }
                });
                return item;
            };
            CubeList.prototype.updateUsed = function () {
                var remaining = 0;
                this.items.forEach(function (value) {
                    remaining += value.remaining;
                });
                this.used = this.total - remaining;
            };
            CubeList.prototype.arrange = function (width) {
                if (this.items.length == 0)
                    return;
                this.items.sort(function (a, b) { return (a.index < b.index) ? -1 : 1; });
                this.lastWidth = width;
                this.bounds.height = 1;
                var itemSize;
                this.list.y = this.listMask.y;
                itemSize = this.items[0].width;
                width -= this.scrollbar.width + cuboro.PADDING * 2;
                var col = 0;
                var row = 0;
                var cols = Math.floor(width / (itemSize + cuboro.PADDING));
                this.items.forEach(function (value) {
                    if (col == cols) {
                        row++;
                        col = 0;
                    }
                    value.x = col * itemSize + col * cuboro.PADDING;
                    value.y = row * itemSize + row * cuboro.PADDING;
                    value.isEnabled = value.remaining > 0;
                    col++;
                });
                this.scrollbar.x = cols * itemSize + cols * cuboro.PADDING;
                this.listMask.width = this.scrollbar.x;
                this.bounds.width = this.listMask.width;
                this.bounds.height = this.list.height;
                this.scrollbar.update(this.list, this.listMask, 0);
                this.scrollbar.visible = this.scrollbar.sizeScroll > this.scrollbar.sizeVisible;
            };
            CubeList.prototype.reset = function () {
                this.list.removeChildren();
                this.list.y = this.listMask.y;
                this.list.addChild(this.bounds);
                this.items = [];
                this._total = 0;
            };
            Object.defineProperty(CubeList.prototype, "total", {
                get: function () {
                    return this._total;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(CubeList.prototype, "used", {
                set: function (value) {
                    this.game.stage.header.trackMenu.updateCubesUsed(this._total, value);
                },
                enumerable: true,
                configurable: true
            });
            return CubeList;
        }(gf.display.Container));
        ui.CubeList = CubeList;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var DropHeightButton = (function (_super) {
            __extends(DropHeightButton, _super);
            function DropHeightButton(game) {
                var _this = _super.call(this, game) || this;
                _this.interactiveChildren = false;
                _this.bg = new gf.display.Sprite(game, "sprites", "bt_dropheight_out");
                _this.addChild(_this.bg);
                _this.icon = new gf.display.Sprite(game, "sprites");
                _this.icon.anchor.set(0.5);
                _this.icon.x = _this.bg.width >> 1;
                _this.icon.y = _this.bg.height >> 1;
                _this.addChild(_this.icon);
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                _this.dropHeight = cuboro.MARBLE_DROP_HEIGHT_DEFAULT;
                return _this;
            }
            DropHeightButton.prototype.setState = function (state) {
                if (this._isSelected) {
                    if (this.bg.tint != cuboro.COLOR_YELLOW)
                        this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                if (this._isEnabled) {
                    if (this.icon)
                        this.icon.alpha = 1;
                }
                else {
                    this.bg.tint = cuboro.COLOR_GREY;
                    if (this.icon) {
                        this.icon.alpha = 0.6;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                    }
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.frameName = "bt_dropheight_down";
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OUT:
                        this.bg.frameName = "bt_dropheight_out";
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.frameName = "bt_dropheight_over";
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.frameName = "bt_dropheight_over";
                            if (this.icon)
                                this.icon.tint = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.bg.frameName = "bt_dropheight_out";
                            if (this.icon)
                                this.icon.tint = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            DropHeightButton.prototype.forceState = function (state) {
                this._currentState = state;
                this.setState(state);
            };
            Object.defineProperty(DropHeightButton.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    this._isSelected = value;
                    this._isOver = false;
                    this.setState(this._currentState);
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(DropHeightButton.prototype, "dropHeight", {
                get: function () {
                    return this._dropHeight;
                },
                set: function (value) {
                    if (this._dropHeight == value)
                        return;
                    this._dropHeight = value;
                    switch (this._dropHeight) {
                        case "LOW":
                            this.icon.frameName = "icon_dropheight_1";
                            break;
                        case "MEDIUM":
                            this.icon.frameName = "icon_dropheight_2";
                            break;
                        case "HIGH":
                            this.icon.frameName = "icon_dropheight_3";
                            break;
                    }
                },
                enumerable: true,
                configurable: true
            });
            return DropHeightButton;
        }(gf.ui.Button));
        ui.DropHeightButton = DropHeightButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var MarbleButton = (function (_super) {
            __extends(MarbleButton, _super);
            function MarbleButton(game) {
                var _this = _super.call(this, game, "marble", loc("bt_marble")) || this;
                _this.bg.width = 135;
                _this.icon.anchor.set(0);
                _this.icon.x =
                    _this.icon.y = 0;
                _this.tfLabel.style.fontSize = 16;
                _this.tfLabel.anchor.set(0, 0.5);
                _this.tfLabel.x = _this.icon.right + cuboro.PADDING * 2;
                _this.tfLabel.y = _this.bg.height >> 1;
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                return _this;
            }
            MarbleButton.prototype.setState = function (state) {
                if (this._isSelected) {
                    if (this.bg.tint != cuboro.COLOR_YELLOW)
                        this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                if (this._isEnabled) {
                    this.icon.alpha = 1;
                    this.tfLabel.alpha = 1;
                }
                else {
                    this.bg.tint = cuboro.COLOR_GREY;
                    this.icon.alpha = 0.6;
                    this.icon.tint = cuboro.COLOR_DARK_GREY;
                    this.tfLabel.alpha = 0.6;
                    this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_WHITE;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OUT:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        this.icon.tint = cuboro.COLOR_WHITE;
                        this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                            this.icon.tint = cuboro.COLOR_WHITE;
                            this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            return MarbleButton;
        }(cuboro.ui.IconButton));
        ui.MarbleButton = MarbleButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var MoveTrackIconButton = (function (_super) {
            __extends(MoveTrackIconButton, _super);
            function MoveTrackIconButton(game) {
                return _super.call(this, game, "arrow") || this;
            }
            MoveTrackIconButton.prototype.setState = function (state) {
                if (this._isSelected) {
                    if (this.bg.tint != cuboro.COLOR_YELLOW)
                        this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                if (this._isEnabled) {
                    this.icon.alpha = 1;
                }
                else {
                    this.bg.tint = cuboro.COLOR_GREY;
                    this.icon.alpha = 0.6;
                    this.icon.tint = cuboro.COLOR_DARK_GREY;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_WHITE;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OUT:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        this.icon.tint = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                            this.icon.tint = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            return MoveTrackIconButton;
        }(cuboro.ui.IconButton));
        ui.MoveTrackIconButton = MoveTrackIconButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var MoveTrackButton = (function (_super) {
            __extends(MoveTrackButton, _super);
            function MoveTrackButton(bottomMenu) {
                var _this = _super.call(this, bottomMenu.game, "move_track", loc("bt_move_track")) || this;
                _this.playground = bottomMenu.gameScreen.playground;
                _this.interactiveChildren = true;
                _this.hitArea = null;
                _this.buttons = new gf.display.Container(_this.game);
                _this.buttons.interactive = true;
                _this.buttons.x = -2;
                _this.buttons.y = -262;
                _this.buttons.visible = false;
                _this.addChildAt(_this.buttons, 0);
                var border = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                border.width = _this.bg.width + 4;
                border.height = 262;
                border.tint = cuboro.COLOR_LIGHT_GREY;
                _this.buttons.addChild(border);
                var bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                bg.width = _this.bg.width;
                bg.height = 260;
                bg.x = 2;
                bg.y = 2;
                bg.tint = cuboro.COLOR_YELLOW;
                _this.buttons.addChild(bg);
                _this.btUp = new cuboro.ui.MoveTrackIconButton(_this.game);
                _this.btUp.on(gf.CLICK, _this.onUp, _this);
                _this.btUp.icon.angle = -90;
                _this.btUp.x = 2;
                _this.btUp.y = 2;
                _this.buttons.addChild(_this.btUp);
                _this.btRight = new cuboro.ui.MoveTrackIconButton(_this.game);
                _this.btRight.on(gf.CLICK, _this.onRight, _this);
                _this.btRight.x = 2;
                _this.btRight.y = 67;
                _this.buttons.addChild(_this.btRight);
                _this.btLeft = new cuboro.ui.MoveTrackIconButton(_this.game);
                _this.btLeft.on(gf.CLICK, _this.onLeft, _this);
                _this.btLeft.icon.angle = 180;
                _this.btLeft.x = 2;
                _this.btLeft.y = 132;
                _this.buttons.addChild(_this.btLeft);
                _this.btDown = new cuboro.ui.MoveTrackIconButton(_this.game);
                _this.btDown.on(gf.CLICK, _this.onDown, _this);
                _this.btDown.icon.angle = 90;
                _this.btDown.x = 2;
                _this.btDown.y = 197;
                _this.buttons.addChild(_this.btDown);
                var hit = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                hit.interactive = true;
                hit.buttonMode = true;
                hit.width = _this.bg.width;
                hit.height = _this.bg.height;
                hit.on("click tap", _this.onMoveTrack, _this);
                _this.addChild(hit);
                return _this;
            }
            MoveTrackButton.prototype.onClickOutside = function (e) {
                if (!this.isSelected)
                    return;
                var pos = e.data.getLocalPosition(this);
                if (!this.getLocalBounds().contains(pos.x, pos.y)) {
                    this.onMoveTrack();
                }
            };
            MoveTrackButton.prototype.getLimits = function () {
                var _this = this;
                this.maxX = -1;
                this.maxZ = -1;
                this.minX = -1;
                this.minZ = -1;
                this.playground.cubes.cubes.forEach(function (value) {
                    _this.maxX = _this.maxX == -1 ? value.mapPosition.x : Math.max(_this.maxX, value.mapPosition.x);
                    _this.maxZ = _this.maxZ == -1 ? value.mapPosition.z : Math.max(_this.maxZ, value.mapPosition.z);
                    _this.minX = _this.minX == -1 ? value.mapPosition.x : Math.min(_this.minX, value.mapPosition.x);
                    _this.minZ = _this.minZ == -1 ? value.mapPosition.z : Math.min(_this.minZ, value.mapPosition.z);
                });
            };
            MoveTrackButton.prototype.moveCubes = function (x, z) {
                var _this = this;
                if (this.playground.controls.isDirectionX) {
                    var tx = x;
                    x = z;
                    z = tx;
                    if (this.playground.controls.direction == 1)
                        x *= -1;
                    if (this.playground.controls.direction == -1)
                        z *= -1;
                }
                else {
                    x *= this.playground.controls.direction;
                    z *= this.playground.controls.direction;
                }
                if (this.minX + x < 0)
                    return;
                if (this.minZ + z < 0)
                    return;
                if (this.maxX + x >= cuboro.MAX_X)
                    return;
                if (this.maxZ + z >= cuboro.MAX_Z)
                    return;
                this.playground.cubes.cubes.forEach(function (value) {
                    _this.playground.map.setAt(cuboro.EMPTY, value.mapPosition.x, value.mapPosition.y, value.mapPosition.z);
                    value.mapPosition.x += x;
                    value.mapPosition.z += z;
                });
                this.playground.cubes.cubes.forEach(function (value) {
                    _this.playground.map.setAt(value.id, value.mapPosition.x, value.mapPosition.y, value.mapPosition.z);
                    _this.playground.cubes.updatePosition(value);
                });
                this.playground.save();
                this.playground.history.save();
                this.getLimits();
            };
            MoveTrackButton.prototype.onDown = function () {
                this.getLimits();
                this.moveCubes(0, 1);
                this.playground.emit(cuboro.CUBE_UPDATE);
            };
            MoveTrackButton.prototype.onLeft = function () {
                this.getLimits();
                this.moveCubes(-1, 0);
                this.playground.emit(cuboro.CUBE_UPDATE);
            };
            MoveTrackButton.prototype.onRight = function () {
                this.getLimits();
                this.moveCubes(1, 0);
                this.playground.emit(cuboro.CUBE_UPDATE);
            };
            MoveTrackButton.prototype.onUp = function () {
                this.getLimits();
                this.moveCubes(0, -1);
                this.playground.emit(cuboro.CUBE_UPDATE);
            };
            MoveTrackButton.prototype.onMoveTrack = function () {
                this.isSelected = !this.isSelected;
                this.buttons.visible = this.isSelected;
                if (this.isSelected)
                    this.game.stage.on("mousedown touchstart", this.onClickOutside, this);
                else
                    this.game.stage.off("mousedown touchstart", this.onClickOutside);
            };
            return MoveTrackButton;
        }(cuboro.ui.IconButton));
        ui.MoveTrackButton = MoveTrackButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var PackshotListItem = (function (_super) {
            __extends(PackshotListItem, _super);
            function PackshotListItem(packshotList, id) {
                var _this = _super.call(this, packshotList.game) || this;
                _this.packshotList = packshotList;
                _this.key = "packshot_" + id;
                _this._id = id;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.bg.width = 80;
                _this.bg.height = 65;
                _this.addChild(_this.bg);
                _this.packshot = new gf.display.Sprite(_this.game, "sprites", _this.key);
                _this.addChild(_this.packshot);
                _this.tfLabel = new gf.display.Text(_this.game, loc(_this.key), cuboro.TEXT_STYLE_BUTTON_ICON.clone());
                _this.tfLabel.anchor.set(0.5, 1);
                _this.tfLabel.x = _this.bg.width >> 1;
                _this.tfLabel.y = _this.bg.height;
                _this.addChild(_this.tfLabel);
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                return _this;
            }
            PackshotListItem.prototype.setState = function (state) {
                if (this._isSelected) {
                    this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.OUT:
                        this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                        }
                        else {
                            this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        }
                        break;
                }
            };
            Object.defineProperty(PackshotListItem.prototype, "id", {
                get: function () {
                    return this._id;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(PackshotListItem.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    if (value == this._isSelected)
                        return;
                    this._isSelected = value;
                    this.setState(this.currentState);
                },
                enumerable: true,
                configurable: true
            });
            return PackshotListItem;
        }(gf.ui.Button));
        ui.PackshotListItem = PackshotListItem;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var PackshotList = (function (_super) {
            __extends(PackshotList, _super);
            function PackshotList(bottomMenu) {
                var _this = _super.call(this, bottomMenu.game) || this;
                _this.bottomMenu = bottomMenu;
                _this.interactive = true;
                _this.items = [];
                _this.scrollEnd = 0;
                _this.listMask = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.listMask.width = 80;
                _this.listMask.height = 135;
                _this.addChild(_this.listMask);
                _this.scrollbar = new cuboro.ui.Scrollbar(_this.game);
                _this.addChild(_this.scrollbar);
                _this.list = new gf.display.Container(_this.game);
                _this.list.interactive = true;
                _this.list.mask = _this.listMask;
                _this.addChild(_this.list);
                _this.sets = _this.game.cache.getJSON("sets");
                return _this;
            }
            PackshotList.prototype.selectItem = function (item) {
                if (this.currentItem)
                    this.currentItem.isSelected = false;
                if (this.currentItem == item) {
                    this.currentItem = null;
                    this.bottomMenu.gameScreen.playground.placeables.hide();
                }
                else {
                    this.currentItem = item;
                    this.bottomMenu.gameScreen.playground.placeables.show();
                }
                this.bottomMenu.gameScreen.playground.cubes.selected = null;
            };
            PackshotList.prototype.onItemClick = function (item) {
                this.selectItem(item);
            };
            PackshotList.prototype.addItem = function (id) {
                var _this = this;
                var item = new cuboro.ui.PackshotListItem(this, id);
                item.on(gf.CLICK, function () { return _this.onItemClick(item); }, this);
                this.list.addChild(item);
                this.items.push(item);
                this.arrange();
            };
            PackshotList.prototype.deselectItems = function () {
                if (this.currentItem)
                    this.currentItem.isSelected = false;
                this.currentItem = null;
            };
            PackshotList.prototype.arrange = function () {
                if (this.items.length == 0)
                    return;
                this.list.y = 0;
                this.items.forEach(function (value, index) {
                    value.y = index * 65 + index * cuboro.PADDING;
                });
                this.scrollbar.update(this.list, this.listMask, cuboro.PADDING);
                this.scrollbar.visible = this.scrollbar.sizeScroll > this.scrollbar.sizeVisible;
            };
            PackshotList.prototype.reset = function () {
                this.list.removeChildren();
                this.items = [];
            };
            return PackshotList;
        }(gf.display.Container));
        ui.PackshotList = PackshotList;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var SliderButton = (function (_super) {
            __extends(SliderButton, _super);
            function SliderButton(game, icon, label) {
                var _this = _super.call(this, game, icon, label) || this;
                _this.interactiveChildren = true;
                _this.inverse = false;
                _this.hitArea = null;
                _this.slider = new gf.display.Container(_this.game);
                _this.slider.interactive = true;
                _this.slider.x = -2;
                _this.slider.y = -134;
                _this.slider.visible = false;
                _this.addChildAt(_this.slider, 0);
                var border = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                border.width = _this.bg.width + 4;
                border.height = 134;
                border.tint = cuboro.COLOR_LIGHT_GREY;
                _this.slider.addChild(border);
                var bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                bg.width = _this.bg.width;
                bg.height = 132;
                bg.x = 2;
                bg.y = 2;
                bg.tint = cuboro.COLOR_YELLOW;
                _this.slider.addChild(bg);
                _this.track = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.track.interactive = true;
                _this.track.width = 15;
                _this.track.height = 105;
                _this.track.tint = cuboro.COLOR_WHITE;
                _this.track.x = (bg.width - _this.track.width) >> 1;
                _this.track.y = 17;
                _this.track.on("click tap", _this.onClick, _this);
                _this.slider.addChild(_this.track);
                _this.thumb = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.thumb.tint = cuboro.COLOR_DARK_GREY;
                _this.thumb.interactive = true;
                _this.thumb.buttonMode = true;
                _this.thumb.width = 17;
                _this.thumb.height = 17;
                _this.thumb.x = (bg.width - _this.thumb.width) >> 1;
                _this.thumb.y = _this.track.y;
                _this.thumb.on("mouseover", _this.onOver, _this);
                _this.thumb.on("mouseout", _this.onOut, _this);
                _this.thumb.on("mousedown touchstart", _this.onDown, _this);
                _this.thumb.on("mouseup touchend mouseupoutside", _this.onUp, _this);
                _this.thumb.on("mousemove touchmove", _this.onMove, _this);
                _this.slider.addChild(_this.thumb);
                _this.iconTop = new gf.display.Sprite(_this.game, "sprites", "icon_slider_top");
                _this.iconTop.tint = cuboro.COLOR_DARK_GREY;
                _this.iconTop.x = _this.track.x;
                _this.iconTop.y = _this.track.y - _this.iconTop.height;
                _this.slider.addChild(_this.iconTop);
                _this.iconBottom = new gf.display.Sprite(_this.game, "sprites", "icon_slider_bottom");
                _this.iconBottom.tint = cuboro.COLOR_DARK_GREY;
                _this.iconBottom.x = _this.track.x;
                _this.iconBottom.y = _this.track.bottom;
                _this.slider.addChild(_this.iconBottom);
                _this.max = _this.track.y;
                _this.min = _this.track.y + _this.track.height - _this.thumb.height;
                var hit = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                hit.interactive = true;
                hit.buttonMode = true;
                hit.width = _this.bg.width;
                hit.height = _this.bg.height;
                hit.on("click tap", _this.onSlider, _this);
                _this.addChild(hit);
                return _this;
            }
            SliderButton.prototype.onClickOutside = function (e) {
                if (!this.isSelected)
                    return;
                var pos = e.data.getLocalPosition(this);
                if (!this.getLocalBounds().contains(pos.x, pos.y)) {
                    this.onSlider();
                }
            };
            SliderButton.prototype.onClick = function (e) {
                this.thumb.y = Math.max(this.max, Math.min(this.min, e.data.getLocalPosition(this.slider).y - (this.thumb.height >> 1)));
                this.update();
            };
            SliderButton.prototype.onOver = function () {
                this.thumb.tint = cuboro.COLOR_GREY;
            };
            SliderButton.prototype.onOut = function () {
                if (!this.isDragging)
                    this.thumb.tint = cuboro.COLOR_DARK_GREY;
            };
            SliderButton.prototype.onDown = function (e) {
                this.startDragY = e.data.global.y;
                this.startY = this.thumb.y;
                this.thumb.tint = cuboro.COLOR_DARK_GREY;
                this.isDragging = true;
            };
            SliderButton.prototype.onUp = function () {
                this.thumb.alpha = 1;
                this.isDragging = false;
                this.thumb.tint = (this.isOver) ? cuboro.COLOR_GREY : cuboro.COLOR_DARK_GREY;
                this.update();
            };
            SliderButton.prototype.onMove = function (e) {
                if (this.isDragging) {
                    this.thumb.y = Math.max(this.max, Math.min(this.min, this.startY + (e.data.global.y - this.startDragY)));
                    this.update();
                }
            };
            SliderButton.prototype.update = function () {
                this.emit(gf.CHANGE, this.value);
            };
            SliderButton.prototype.onSlider = function () {
                this.isSelected = !this.isSelected;
                this.slider.visible = this.isSelected;
                if (this.isSelected)
                    this.game.stage.on("mousedown touchstart", this.onClickOutside, this);
                else
                    this.game.stage.off("mousedown touchstart", this.onClickOutside);
            };
            Object.defineProperty(SliderButton.prototype, "value", {
                get: function () {
                    var value = (this.thumb.y - this.track.y) / (this.track.height - this.thumb.height);
                    if (this.inverse)
                        return Math.abs(value - 1);
                    return value;
                },
                set: function (value) {
                    if (this.inverse)
                        value = Math.abs(value - 1);
                    this.thumb.y = Math.max(this.max, Math.min(this.min, value * (this.track.height - this.thumb.height) + this.track.y));
                },
                enumerable: true,
                configurable: true
            });
            return SliderButton;
        }(cuboro.ui.IconButton));
        ui.SliderButton = SliderButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var BottomMenu = (function (_super) {
            __extends(BottomMenu, _super);
            function BottomMenu(gameScreen) {
                var _this = _super.call(this, gameScreen.game) || this;
                _this.interactive = true;
                _this.gameScreen = gameScreen;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.height = 145;
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.addChild(_this.bg);
                _this.btMoveView = new cuboro.ui.IconButton(_this.game, "move_view", loc("bt_move_view"));
                _this.btMoveView.on(gf.CLICK, _this.onMoveView, _this);
                _this.btMoveView.x = cuboro.PADDING;
                _this.btMoveView.y = cuboro.PADDING;
                _this.addChild(_this.btMoveView);
                _this.btLayerDistance = new cuboro.ui.SliderButton(_this.game, "distance_layer", loc("bt_distance_layer"));
                _this.btLayerDistance.on(gf.CHANGE, _this.onLayerDistance, _this);
                _this.btLayerDistance.on(gf.CLICK, _this.updateSlider, _this);
                _this.btLayerDistance.inverse = true;
                _this.btLayerDistance.x = cuboro.PADDING;
                _this.btLayerDistance.y = _this.bg.height - _this.btLayerDistance.height - cuboro.PADDING;
                _this.addChild(_this.btLayerDistance);
                _this.btOpacity = new cuboro.ui.SliderButton(_this.game, "opacity", loc("bt_opacity"));
                _this.btOpacity.on(gf.CHANGE, _this.onOpacity, _this);
                _this.btOpacity.on(gf.CLICK, _this.updateSlider, _this);
                _this.btOpacity.inverse = true;
                _this.btOpacity.x = _this.btMoveView.right + cuboro.PADDING;
                _this.btOpacity.y = _this.btMoveView.y;
                _this.addChild(_this.btOpacity);
                _this.btAddSets = new cuboro.ui.IconButton(_this.game, "plus", loc("bt_select_sets", { count: 0 }));
                _this.btAddSets.on(gf.CLICK, _this.onAddSets, _this);
                _this.btAddSets.x = _this.btOpacity.right + cuboro.PADDING;
                _this.btAddSets.y = _this.btMoveView.y;
                _this.addChild(_this.btAddSets);
                var set = new gf.display.Sprite(_this.game, "sprites", "icon_add_set");
                _this.btAddSets.addChildAt(set, _this.btAddSets.getChildIndex(_this.btAddSets.icon));
                _this.btElementsDistance = new cuboro.ui.SliderButton(_this.game, "distance_elements", loc("bt_distance_elements"));
                _this.btElementsDistance.on(gf.CHANGE, _this.onElementsDistance, _this);
                _this.btElementsDistance.on(gf.CLICK, _this.updateSlider, _this);
                _this.btElementsDistance.inverse = true;
                _this.btElementsDistance.x = _this.btOpacity.x;
                _this.btElementsDistance.y = _this.btLayerDistance.y;
                _this.addChild(_this.btElementsDistance);
                _this.btZoom = new cuboro.ui.SliderButton(_this.game, "zoom", loc("bt_zoom"));
                _this.btZoom.on(gf.CHANGE, _this.onZoom, _this);
                _this.btZoom.on(gf.CLICK, _this.updateSlider, _this);
                _this.btZoom.inverse = true;
                _this.btZoom.x = _this.btAddSets.x;
                _this.btZoom.y = _this.btLayerDistance.y;
                _this.addChild(_this.btZoom);
                _this.listBg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.listBg.tint = cuboro.COLOR_MID_GREY;
                _this.listBg.height = _this.bg.height;
                _this.listBg.x = _this.btZoom.right + cuboro.PADDING;
                _this.addChild(_this.listBg);
                _this.cubeList = new cuboro.ui.CubeList(_this);
                _this.cubeList.x = _this.listBg.x + cuboro.PADDING;
                _this.cubeList.y = cuboro.PADDING;
                _this.addChild(_this.cubeList);
                _this.btUndo = new cuboro.ui.IconButton(_this.game, "undo", loc("bt_undo"));
                _this.btUndo.y = cuboro.PADDING;
                _this.btUndo.on(gf.CLICK, _this.onUndo, _this);
                _this.addChild(_this.btUndo);
                _this.btDelete = new cuboro.ui.IconButton(_this.game, "delete", loc("bt_delete"));
                _this.btDelete.on(gf.CLICK, _this.onDelete, _this);
                _this.btDelete.y = _this.btLayerDistance.y;
                _this.addChild(_this.btDelete);
                _this.btSwap = new cuboro.ui.IconButton(_this.game, "swap", loc("bt_swap"));
                _this.btSwap.on(gf.CLICK, _this.onSwap, _this);
                _this.btSwap.y = _this.btLayerDistance.y;
                _this.addChild(_this.btSwap);
                _this.btMoveCube = new cuboro.ui.IconButton(_this.game, "move_cube", loc("bt_move_cube"));
                _this.btMoveCube.on(gf.CLICK, _this.onMoveCube, _this);
                _this.btMoveCube.y = _this.btLayerDistance.y;
                _this.addChild(_this.btMoveCube);
                _this.btDropHeight = new cuboro.ui.DropHeightButton(_this.game);
                _this.btDropHeight.on(gf.CLICK, _this.onDropHeight, _this);
                _this.btDropHeight.y = cuboro.PADDING;
                _this.addChild(_this.btDropHeight);
                _this.btMoveTrack = new cuboro.ui.MoveTrackButton(_this);
                _this.btMoveTrack.y = _this.btLayerDistance.y;
                _this.addChild(_this.btMoveTrack);
                _this.btMarble = new cuboro.ui.MarbleButton(_this.game);
                _this.btMarble.y = cuboro.PADDING;
                _this.btMarble.on(gf.DOWN, _this.onMarbleDown, _this);
                _this.btMarble.on(gf.UP, _this.onMarbleUp, _this);
                _this.btMarble.on(gf.CLICK, _this.onMarbleClick, _this);
                _this.addChild(_this.btMarble);
                _this.gameScreen.playground.history.on(gf.CHANGE, _this.onHistory, _this);
                _this.gameScreen.playground.on(cuboro.CAMERA_UPDATE, _this.updateSlider, _this);
                _this.gameScreen.playground.on(cuboro.CUBE_DESELECTED, _this.deselectCube, _this);
                _this.onResize();
                return _this;
            }
            BottomMenu.prototype.updateSlider = function () {
                var playground = this.gameScreen.playground;
                this.btElementsDistance.value = playground.elementMargin;
                this.btLayerDistance.value = playground.layerMargin;
                this.btOpacity.value = Math.abs(playground.cubeOpacity / 0.5 - 2);
                var max = playground.controls.settings.maxDistance;
                var min = playground.controls.settings.minDistance;
                this.btZoom.value = 1 - (playground.controls.distance - min) / (max - min);
            };
            BottomMenu.prototype.deselectCube = function () {
                this.btSwap.isSelected = false;
                this.gameScreen.moveMenu.hide();
                this.gameScreen.rotateMenu.hide();
            };
            BottomMenu.prototype.updateElementMargin = function () {
                var playground = this.gameScreen.playground;
                playground.elementMargin = this._elementMargin;
                this.btElementsDistance.value = this._elementMargin;
                playground.cubes.cubes.forEach(function (cube) {
                    cube.x = playground.map.xTo3DPos(cube.mapPosition.x);
                    cube.z = playground.map.zTo3DPos(cube.mapPosition.z);
                });
                playground.ground.tiles.forEach(function (tile) {
                    tile.position.x = playground.map.xTo3DPos(tile.userData.x);
                    tile.position.z = playground.map.zTo3DPos(tile.userData.z);
                });
                playground.placeables.tiles.forEach(function (tile) {
                    tile.position.x = playground.map.xTo3DPos(tile.userData.x);
                    tile.position.z = playground.map.zTo3DPos(tile.userData.z);
                });
                playground.emit(cuboro.CUBE_UPDATE);
            };
            BottomMenu.prototype.updateLayerMargin = function () {
                var playground = this.gameScreen.playground;
                playground.layerMargin = this._layerMargin;
                this.btLayerDistance.value = this._layerMargin;
                playground.cubes.cubes.forEach(function (cube) {
                    cube.y = playground.map.yTo3DPos(cube.mapPosition.y);
                });
                playground.emit(cuboro.CUBE_UPDATE);
            };
            BottomMenu.prototype.spawnMarble = function (e) {
                this.gameScreen.playground.cubes.selected = null;
                this.gameScreen.playground.select.spawnMarble(e);
                this.gameScreen.playground.placeables.hide();
                this.gameScreen.moveMenu.hide();
                this.gameScreen.rotateMenu.hide();
            };
            BottomMenu.prototype.onAddSets = function () {
                var addSets = this.game.overlays.show(cuboro.overlays.AddSets.NAME);
                addSets.bottomMenu = this;
            };
            BottomMenu.prototype.onDelete = function () {
                if (!this.gameScreen.playground.cubes.selected)
                    return;
                this.gameScreen.moveMenu.hide();
                this.gameScreen.rotateMenu.hide();
                this.gameScreen.playground.cubes.remove();
                this.gameScreen.playground.emit(cuboro.CUBE_UPDATE);
                this.gameScreen.playground.history.save();
                this.gameScreen.playground.save();
            };
            BottomMenu.prototype.onHistory = function (length) {
                this.btUndo.isEnabled = (length > 0);
            };
            BottomMenu.prototype.onOpacity = function (value) {
                var playground = this.gameScreen.playground;
                playground.cubeOpacity = 1 - (value * 0.5);
                playground.cubes.cubes.forEach(function (value) {
                    value.opacity = playground.cubeOpacity;
                });
            };
            BottomMenu.prototype.onElementsDistance = function (value) {
                this.elementMargin = value;
            };
            BottomMenu.prototype.onLayerDistance = function (value) {
                this.layerMargin = value;
            };
            BottomMenu.prototype.onMoveView = function () {
                this.btMoveView.isSelected = !this.btMoveView.isSelected;
            };
            BottomMenu.prototype.onZoom = function (value) {
                var playground = this.gameScreen.playground;
                var max = playground.controls.settings.maxDistance;
                var min = playground.controls.settings.minDistance;
                playground.controls.distance = (1 - value) * (max - min) + min;
            };
            BottomMenu.prototype.onSwap = function () {
                if (!this.gameScreen.playground.cubes.selected)
                    return;
                if (this.btSwap.isSelected) {
                    this.btSwap.isSelected = false;
                    this.gameScreen.playground.cubes.swapping = null;
                    this.gameScreen.rotateMenu.show();
                }
                else {
                    this.btSwap.isSelected = true;
                    this.btMoveCube.isSelected = false;
                    this.gameScreen.moveMenu.hide();
                    this.gameScreen.rotateMenu.hide();
                    this.gameScreen.playground.cubes.swapping = this.gameScreen.playground.cubes.selected;
                }
            };
            BottomMenu.prototype.onDropHeight = function () {
                if (this.btDropHeight.dropHeight == "HIGH")
                    this.btDropHeight.dropHeight = "LOW";
                else if (this.btDropHeight.dropHeight == "LOW")
                    this.btDropHeight.dropHeight = "MEDIUM";
                else
                    this.btDropHeight.dropHeight = "HIGH";
            };
            BottomMenu.prototype.onUndo = function () {
                this.gameScreen.playground.history.undo();
            };
            BottomMenu.prototype.onMoveCube = function () {
                if (this.btMoveCube.isSelected) {
                    this.btMoveCube.isSelected = false;
                    this.gameScreen.moveMenu.hide();
                }
                else {
                    this.btMoveCube.isSelected = true;
                    if (this.gameScreen.playground.cubes.selected)
                        this.gameScreen.moveMenu.show();
                }
            };
            BottomMenu.prototype.onMarbleClick = function (e) {
                this.btMarble.removeAllListeners("mousemove touchmove");
                this.spawnMarble(e);
            };
            BottomMenu.prototype.onMarbleDown = function (e) {
                var _this = this;
                this.dragStart = e.data.global.clone();
                this.btMarble.on("mousemove touchmove", function (e) { return _this.onMarbleMove(e); });
            };
            BottomMenu.prototype.onMarbleMove = function (e) {
                if (!this.marbleSpawned && gf.utils.Maths.distance(this.dragStart, e.data.global) > 10) {
                    this.marbleSpawned = true;
                    this.spawnMarble(e);
                }
            };
            BottomMenu.prototype.onMarbleUp = function () {
                this.btMarble.removeAllListeners("mousemove touchmove");
                this.marbleSpawned = false;
            };
            BottomMenu.prototype.start = function () {
                var _this = this;
                this.cubeList.reset();
                mTrack.data.sets.forEach(function (value) {
                    _this.cubeList.addSet(value);
                });
                this.btAddSets.label = loc("bt_select_sets", { count: mTrack.data.sets.length });
                this.game.stage.header.trackMenu.checkPublish();
                this.gameScreen.playground.elementMargin = 0;
                this.gameScreen.playground.layerMargin = 0;
                this.gameScreen.playground.cubeOpacity = 1;
                this.gameScreen.playground.controls.distance = this.gameScreen.playground.controls.settings.maxDistance;
                this.btElementsDistance.value = 1;
                this.btLayerDistance.value = 1;
                this.btOpacity.value = 1;
                this.btZoom.value = 1;
                this.btDropHeight.dropHeight = cuboro.MARBLE_DROP_HEIGHT_DEFAULT;
                if (this.btMoveCube.isSelected)
                    this.btMoveCube.isSelected = false;
                if (this.btMoveTrack.isSelected)
                    this.btMoveTrack.onMoveTrack();
                if (this.btElementsDistance.isSelected)
                    this.btElementsDistance.onSlider();
                if (this.btLayerDistance.isSelected)
                    this.btLayerDistance.onSlider();
                if (this.btOpacity.isSelected)
                    this.btOpacity.onSlider();
                if (this.btZoom.isSelected)
                    this.btZoom.onSlider();
                this.btMoveTrack.isSelected = false;
                this.btMoveView.isSelected = false;
                this.btSwap.isSelected = false;
                this.gameScreen.playground.cubes.swapping = null;
                this.gameScreen.layers.reset();
                this.game.stage.header.trackMenu.btDetails.isSelected = false;
                this.game.stage.header.trackMenu.tfSaved.text = "";
                this.cubeList.updateUsed();
                this.onResize();
            };
            BottomMenu.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.y = this.game.height - this.bg.height - this.game.stage.footer.height;
                this.bg.width = this.game.width;
                this.btDelete.x = this.game.width - this.btDelete.width - cuboro.PADDING;
                this.btSwap.x = this.btDelete.x - this.btSwap.width - cuboro.PADDING;
                this.btMoveTrack.x = this.btSwap.x - this.btMoveTrack.width - cuboro.PADDING;
                this.btDropHeight.x = this.btMoveTrack.x;
                this.btMarble.x = this.btDropHeight.right;
                this.btMoveCube.x = this.btMoveTrack.x - this.btMoveCube.width - cuboro.PADDING;
                this.btUndo.x = this.btMoveCube.x;
                this.listBg.width = this.btMoveCube.x - cuboro.PADDING - this.listBg.x;
                this.cubeList.arrange(this.listBg.width - (this.cubeList.x - this.listBg.x));
            };
            Object.defineProperty(BottomMenu.prototype, "layerMargin", {
                get: function () {
                    return this._layerMargin;
                },
                set: function (value) {
                    if (value == this._layerMargin)
                        return;
                    this._layerMargin = value;
                    this.updateLayerMargin();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(BottomMenu.prototype, "elementMargin", {
                get: function () {
                    return this._elementMargin;
                },
                set: function (value) {
                    if (value == this._elementMargin)
                        return;
                    this._elementMargin = value;
                    this.updateElementMargin();
                },
                enumerable: true,
                configurable: true
            });
            return BottomMenu;
        }(gf.display.Container));
        ui.BottomMenu = BottomMenu;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var LayerButton = (function (_super) {
            __extends(LayerButton, _super);
            function LayerButton(game, layer) {
                var _this = _super.call(this, game, "bt_layer_out", layer.toString()) || this;
                _this.layer = layer;
                _this.bg.width = _this.icon.width;
                _this.bg.height = _this.icon.height;
                _this.icon.x = _this.bg.width >> 1;
                _this.icon.y = _this.bg.height >> 1;
                _this.tfLabel.anchor.set(0.5);
                _this.tfLabel.x = _this.bg.width >> 1;
                _this.tfLabel.y = _this.bg.height >> 1;
                _this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                return _this;
            }
            LayerButton.prototype.addIcon = function () {
                this.icon = new gf.display.Sprite(this.game, "sprites", "bt_layer_out");
                this.icon.anchor.set(0.5);
                this.addChild(this.icon);
            };
            LayerButton.prototype.setState = function (state) {
                if (this._isSelected) {
                    if (this.icon.frameName != "bt_layer_down")
                        this.icon.frameName = "bt_layer_down";
                    this.bg.tint = cuboro.COLOR_YELLOW;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.icon.frameName = "bt_layer_down";
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        break;
                    case gf.OUT:
                        this.icon.frameName = "bt_layer_out";
                        this.bg.tint = cuboro.COLOR_WHITE;
                        break;
                    case gf.OVER:
                        this.icon.frameName = "bt_layer_over";
                        this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.icon.frameName = "bt_layer_over";
                            this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                        }
                        else {
                            this.icon.frameName = "bt_layer_out";
                            this.bg.tint = cuboro.COLOR_WHITE;
                        }
                        break;
                }
            };
            return LayerButton;
        }(cuboro.ui.IconButton));
        ui.LayerButton = LayerButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Layers = (function (_super) {
            __extends(Layers, _super);
            function Layers(gameScreen) {
                var _this = _super.call(this, gameScreen.game) || this;
                _this.gameScreen = gameScreen;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.bg.width = 69;
                _this.addChild(_this.bg);
                _this.tfLayers = new gf.display.Text(_this.game, loc("layers"), cuboro.TEXT_STYLE_BUTTON_ICON.clone());
                _this.tfLayers.x = (_this.bg.width - _this.tfLayers.width) >> 1;
                _this.tfLayers.visible = false;
                _this.addChild(_this.tfLayers);
                _this.buttonContainer = new gf.display.Container(_this.game);
                _this.addChild(_this.buttonContainer);
                _this.buttons = [];
                _this.buttonsHeight = 0;
                var i;
                var _loop_1 = function () {
                    var bt = new cuboro.ui.LayerButton(this_1.game, cuboro.MAX_Y - i);
                    bt.on(gf.CLICK, function () { return _this.onLayer(bt); }, this_1);
                    bt.y = i * bt.height + i * cuboro.PADDING;
                    this_1.buttonsHeight += bt.height + cuboro.PADDING;
                    bt.visible = false;
                    this_1.buttonContainer.addChild(bt);
                    this_1.buttons.push(bt);
                };
                var this_1 = this;
                for (i = 0; i < cuboro.MAX_Y; ++i) {
                    _loop_1();
                }
                _this.btAll = new cuboro.ui.LayerButton(_this.game, 0);
                _this.btAll.on(gf.CLICK, _this.onAll, _this);
                _this.btAll.y = i * _this.btAll.height + i * cuboro.PADDING;
                _this.btAll.label = "Alle Ebenen\nanzeigen";
                _this.btAll.tfLabel.anchor.y = 0;
                _this.btAll.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                _this.btAll.tfLabel.y = _this.btAll.icon.bottom + cuboro.PADDING;
                _this.btAll.bg.height = _this.btAll.tfLabel.bottom + cuboro.PADDING;
                _this.buttonsHeight += _this.btAll.height + cuboro.PADDING;
                _this.buttonContainer.addChild(_this.btAll);
                _this.gameScreen.playground.on(cuboro.CUBE_UPDATE, _this.update, _this);
                return _this;
            }
            Layers.prototype.onAll = function () {
                this.buttons.forEach(function (value) {
                    value.isSelected = false;
                });
                this.onLayer();
            };
            Layers.prototype.onLayer = function (bt) {
                var _this = this;
                if (bt) {
                    bt.isSelected = !bt.isSelected;
                    this.buttons.forEach(function (value) {
                        if (value != bt)
                            value.isSelected = false;
                    });
                }
                var isButtonSelected = false;
                this.buttons.forEach(function (value) {
                    if (value.isSelected) {
                        isButtonSelected = true;
                        return;
                    }
                });
                var currentOpacity = this.gameScreen.playground.cubeOpacity;
                this.gameScreen.playground.cubes.cubes.forEach(function (value) {
                    value.opacity = !isButtonSelected ? currentOpacity : _this.isSelected(value.mapPosition.y + 1) ? currentOpacity : 0.2;
                    value.layer.visible = !isButtonSelected ? false : _this.isSelected(value.mapPosition.y + 1);
                });
            };
            Layers.prototype.isSelected = function (y) {
                var isSelected = false;
                this.buttons.forEach(function (value) {
                    if (value.isSelected && value.layer == y) {
                        isSelected = true;
                        return;
                    }
                });
                return isSelected;
            };
            Layers.prototype.update = function () {
                var cubesPerLayer = [0, 0, 0, 0, 0, 0, 0, 0, 0];
                this.gameScreen.playground.cubes.cubes.forEach(function (value) {
                    cubesPerLayer[value.mapPosition.y]++;
                });
                this.buttons.forEach(function (value) {
                    value.visible = cubesPerLayer[value.layer - 1] > 0;
                });
                this.tfLayers.visible = this.buttons[this.buttons.length - 1].visible;
                this.onLayer();
                this.onResize();
            };
            Layers.prototype.reset = function () {
                this.buttons.forEach(function (value) {
                    value.isSelected = false;
                });
                this.update();
            };
            Layers.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.bg.height = this.gameScreen.bottomMenu.y - this.game.stage.header.bg.height;
                this.tfLayers.y = this.bg.height - this.tfLayers.height - cuboro.PADDING * 2;
                this.buttonContainer.y = this.tfLayers.y - this.buttonsHeight - cuboro.PADDING * 2;
            };
            return Layers;
        }(gf.display.Container));
        ui.Layers = Layers;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var SoundButton = (function (_super) {
            __extends(SoundButton, _super);
            function SoundButton(game, icon, label) {
                var _this = _super.call(this, game, "sound", loc("bt_sound_on")) || this;
                _this.on(gf.CLICK, _this.onToggle);
                return _this;
            }
            SoundButton.prototype.onToggle = function () {
                this.isSelected = !this.isSelected;
                this.game.sounds.muteFx(this.isSelected);
            };
            SoundButton.prototype.setState = function (state) {
                if (!this.isSelected) {
                    if (this.icon.frameName != "icon_sound") {
                        this.icon.frameName = "icon_sound";
                        this.label = loc("bt_sound_on");
                    }
                }
                else {
                    this.icon.frameName = "icon_mute";
                    this.label = loc("bt_sound_off");
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        if (this.tfLabel)
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OUT:
                        this.bg.tint = cuboro.COLOR_WHITE;
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        if (this.tfLabel)
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.tint = cuboro.COLOR_YELLOW;
                        if (this.icon)
                            this.icon.tint = cuboro.COLOR_WHITE;
                        if (this.tfLabel)
                            this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.tint = cuboro.COLOR_YELLOW;
                            if (this.icon)
                                this.icon.tint = cuboro.COLOR_WHITE;
                            if (this.tfLabel)
                                this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.bg.tint = cuboro.COLOR_WHITE;
                            if (this.icon)
                                this.icon.tint = cuboro.COLOR_DARK_GREY;
                            if (this.tfLabel)
                                this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            return SoundButton;
        }(cuboro.ui.IconButton));
        ui.SoundButton = SoundButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var AccountMenu = (function (_super) {
            __extends(AccountMenu, _super);
            function AccountMenu(game) {
                var _this = _super.call(this, game) || this;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.addChild(_this.bg);
                _this.btAccount = new cuboro.ui.IconButton(_this.game, "options", loc("bt_account_management"));
                _this.btAccount.x = cuboro.PADDING;
                _this.btAccount.on(gf.CLICK, _this.onAccount, _this);
                _this.addChild(_this.btAccount);
                _this.btChangePassword = new cuboro.ui.IconButton(_this.game, "password", loc("bt_change_password"));
                _this.btChangePassword.x = cuboro.PADDING;
                _this.btChangePassword.y = _this.btAccount.bottom + cuboro.PADDING;
                _this.btChangePassword.on(gf.CLICK, _this.onChangePassword, _this);
                _this.addChild(_this.btChangePassword);
                _this.btLogout = new cuboro.ui.IconButton(_this.game, "logout", loc("bt_logout"));
                _this.btLogout.x = cuboro.PADDING;
                _this.btLogout.y = _this.btChangePassword.bottom + cuboro.PADDING;
                _this.btLogout.on(gf.CLICK, _this.onLogout, _this);
                _this.addChild(_this.btLogout);
                _this.bg.width = _this.btAccount.width + cuboro.PADDING * 2;
                _this.bg.height = _this.btLogout.bottom + cuboro.PADDING;
                return _this;
            }
            AccountMenu.prototype.onAccount = function () {
                this.game.overlays.show(cuboro.overlays.Account.NAME);
                this.hide();
            };
            AccountMenu.prototype.onChangePassword = function () {
                this.game.overlays.show(cuboro.overlays.ChangePassword.NAME);
                this.hide();
            };
            AccountMenu.prototype.onLogout = function () {
                var _this = this;
                this.game.overlays.show(cuboro.overlays.Loader.NAME);
                casClient.logout(function () {
                    _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                    _this.game.screens.show(cuboro.screens.Start.NAME);
                    _this.hide();
                });
            };
            AccountMenu.prototype.onClickOutside = function (e) {
                if (!this.game.stage.header.btAccount.isSelected)
                    return;
                var pos = e.data.getLocalPosition(this);
                if (!this.getLocalBounds().contains(pos.x, pos.y)) {
                    this.hide();
                }
            };
            AccountMenu.prototype.show = function () {
                this.visible = true;
                this.game.stage.on("mousedown touchstart", this.onClickOutside, this);
            };
            AccountMenu.prototype.hide = function () {
                this.game.stage.header.btAccount.isSelected = false;
                this.visible = false;
                this.game.stage.off("mousedown touchstart", this.onClickOutside);
            };
            return AccountMenu;
        }(gf.display.Container));
        ui.AccountMenu = AccountMenu;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TopMenu = (function (_super) {
            __extends(TopMenu, _super);
            function TopMenu(game) {
                var _this = _super.call(this, game) || this;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.addChild(_this.bg);
                _this.btGallery = new cuboro.ui.IconButton(_this.game, "gallery", loc("bt_gallery_home"));
                _this.btGallery.x = cuboro.PADDING;
                _this.btGallery.on(gf.CLICK, _this.onGallery, _this);
                _this.addChild(_this.btGallery);
                _this.btAbout = new cuboro.ui.IconButton(_this.game, "cuboro", loc("bt_about"));
                _this.btAbout.x = cuboro.PADDING;
                _this.btAbout.y = _this.btGallery.bottom + cuboro.PADDING;
                _this.btAbout.on(gf.CLICK, _this.onAbout, _this);
                _this.addChild(_this.btAbout);
                _this.btSound = new cuboro.ui.SoundButton(_this.game);
                _this.btSound.x = cuboro.PADDING;
                _this.btSound.y = _this.btAbout.bottom + cuboro.PADDING;
                _this.addChild(_this.btSound);
                _this.bg.width = _this.btGallery.width + cuboro.PADDING * 2;
                _this.bg.height = _this.btSound.bottom + cuboro.PADDING;
                return _this;
            }
            TopMenu.prototype.onGallery = function () {
                this.game.screens.show(cuboro.screens.Start.NAME);
                this.hide();
            };
            TopMenu.prototype.onHelp = function () {
            };
            TopMenu.prototype.onClickOutside = function (e) {
                if (!this.game.stage.header.btMenu.isSelected)
                    return;
                var pos = e.data.getLocalPosition(this);
                if (!this.getLocalBounds().contains(pos.x, pos.y)) {
                    this.hide();
                }
            };
            TopMenu.prototype.onAbout = function () {
                window.open("https://www.cuboro.ch", "_blank");
                this.hide();
            };
            TopMenu.prototype.show = function () {
                this.visible = true;
                this.game.stage.on("mousedown touchstart", this.onClickOutside, this);
            };
            TopMenu.prototype.hide = function () {
                this.game.stage.header.btMenu.isSelected = false;
                this.visible = false;
                this.game.stage.off("mousedown touchstart", this.onClickOutside);
            };
            return TopMenu;
        }(gf.display.Container));
        ui.TopMenu = TopMenu;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var MarbleRun = (function (_super) {
            __extends(MarbleRun, _super);
            function MarbleRun(gameScreen) {
                var _this = _super.call(this, gameScreen.game) || this;
                _this.gameScreen = gameScreen;
                _this.interactive = true;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.height = 75;
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.addChild(_this.bg);
                _this.btAbort = new cuboro.ui.IconButton(_this.game, "abort", loc("bt_abort"));
                _this.btAbort.on(gf.CLICK, _this.onAbort, _this);
                _this.btAbort.y = cuboro.PADDING;
                _this.addChild(_this.btAbort);
                return _this;
            }
            MarbleRun.prototype.onAbort = function () {
                this.gameScreen.playground.marble.stop(true);
            };
            MarbleRun.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.bg.width = this.game.width;
                this.btAbort.x = this.game.width - this.btAbort.width - cuboro.PADDING;
            };
            return MarbleRun;
        }(gf.display.Container));
        ui.MarbleRun = MarbleRun;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var RoundIconButton = (function (_super) {
            __extends(RoundIconButton, _super);
            function RoundIconButton(game, icon) {
                var _this = _super.call(this, game) || this;
                _this.interactiveChildren = false;
                _this._icon = icon;
                _this.bg = new gf.display.Sprite(game, "sprites", "bt_round_out");
                _this.addChild(_this.bg);
                _this.addIcon();
                _this.hitArea = _this.getLocalBounds();
                _this.setState(gf.OUT);
                return _this;
            }
            RoundIconButton.prototype.addIcon = function () {
                this.icon = new gf.display.Sprite(this.game, "sprites", "icon_" + this._icon);
                this.icon.anchor.set(0.5);
                this.icon.x = this.bg.width >> 1;
                this.icon.y = this.bg.height >> 1;
                this.addChild(this.icon);
            };
            RoundIconButton.prototype.setState = function (state) {
                if (this._isEnabled) {
                    this.icon.alpha = 1;
                }
                else {
                    this.bg.frameName = "bt_round_over";
                    this.icon.alpha = 0.6;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.frameName = "bt_round_down";
                        break;
                    case gf.OUT:
                        this.bg.frameName = "bt_round_out";
                        break;
                    case gf.OVER:
                        this.bg.frameName = "bt_round_over";
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.frameName = "bt_round_over";
                        }
                        else {
                            this.bg.frameName = "bt_round_out";
                        }
                        break;
                }
            };
            RoundIconButton.prototype.forceState = function (state) {
                this._currentState = state;
                this.setState(state);
            };
            return RoundIconButton;
        }(gf.ui.Button));
        ui.RoundIconButton = RoundIconButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var MoveMenu = (function (_super) {
            __extends(MoveMenu, _super);
            function MoveMenu(playground) {
                var _this = _super.call(this, playground.game) || this;
                _this.interactive = true;
                _this.playground = playground;
                _this.btUp = new cuboro.ui.RoundIconButton(_this.game, "arrow");
                _this.btUp.on(gf.CLICK, _this.onUp, _this);
                _this.btUp.icon.angle = -90;
                _this.addChild(_this.btUp);
                _this.btLeft = new cuboro.ui.RoundIconButton(_this.game, "arrow");
                _this.btLeft.on(gf.CLICK, _this.onLeft, _this);
                _this.btLeft.icon.angle = 180;
                _this.addChild(_this.btLeft);
                _this.btRight = new cuboro.ui.RoundIconButton(_this.game, "arrow");
                _this.btRight.on(gf.CLICK, _this.onRight, _this);
                _this.addChild(_this.btRight);
                _this.btDown = new cuboro.ui.RoundIconButton(_this.game, "arrow");
                _this.btDown.on(gf.CLICK, _this.onDown, _this);
                _this.btDown.icon.angle = 90;
                _this.addChild(_this.btDown);
                _this.btUp.x = _this.btUp.width + 25;
                _this.btLeft.y = _this.btUp.bottom + 10;
                _this.btRight.x = _this.btUp.right + 25;
                _this.btRight.y = _this.btLeft.y;
                _this.btDown.x = _this.btUp.x;
                _this.btDown.y = _this.btLeft.bottom + 10;
                _this.playground.on(cuboro.CAMERA_UPDATED, _this.toScreen, _this);
                _this.playground.on(cuboro.CUBE_UPDATE, _this.toScreen, _this);
                _this.visible = false;
                return _this;
            }
            MoveMenu.prototype.isValidY = function (x, z) {
                return this.playground.map.getNextEmptyY(x, z) < cuboro.MAX_Y;
            };
            MoveMenu.prototype.update = function (cube) {
                var _this = this;
                if (!cube)
                    cube = this.playground.cubes.selected;
                if (this.playground.map.getAt(cube.mapPosition) != cuboro.EMPTY) {
                    cube.mapPosition.y = this.playground.map.getNextEmptyY(cube.mapPosition.x, cube.mapPosition.z);
                }
                TweenMax.to(cube, 0.25, {
                    x: this.playground.map.xTo3DPos(cube.mapPosition.x),
                    y: this.playground.map.yTo3DPos(cube.mapPosition.y),
                    z: this.playground.map.zTo3DPos(cube.mapPosition.z),
                    onUpdate: function () { return _this.playground.emit(cuboro.CUBE_UPDATE); }
                });
                this.playground.cubes.update(cube);
                this.updateButtons();
                this.playground.history.save();
            };
            MoveMenu.prototype.onUp = function () {
                var cube = this.playground.cubes.selected;
                this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                if (this.playground.controls.isDirectionX) {
                    cube.mapPosition.x = Math.max(0, Math.min(cuboro.MAX_X - 1, cube.mapPosition.x + this.playground.controls.direction));
                }
                else {
                    cube.mapPosition.z = Math.max(0, Math.min(cuboro.MAX_Z - 1, cube.mapPosition.z - this.playground.controls.direction));
                }
                this.update(cube);
            };
            MoveMenu.prototype.onLeft = function () {
                var cube = this.playground.cubes.selected;
                this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                if (this.playground.controls.isDirectionX) {
                    cube.mapPosition.z = Math.max(0, Math.min(cuboro.MAX_Z - 1, cube.mapPosition.z - this.playground.controls.direction));
                }
                else {
                    cube.mapPosition.x = Math.max(0, Math.min(cuboro.MAX_X - 1, cube.mapPosition.x - this.playground.controls.direction));
                }
                this.update(cube);
            };
            MoveMenu.prototype.onRight = function () {
                var cube = this.playground.cubes.selected;
                this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                if (this.playground.controls.isDirectionX) {
                    cube.mapPosition.z = Math.max(0, Math.min(cuboro.MAX_Z - 1, cube.mapPosition.z + this.playground.controls.direction));
                }
                else {
                    cube.mapPosition.x = Math.max(0, Math.min(cuboro.MAX_X - 1, cube.mapPosition.x + this.playground.controls.direction));
                }
                this.update(cube);
            };
            MoveMenu.prototype.onDown = function () {
                var cube = this.playground.cubes.selected;
                this.playground.map.setAt(cuboro.EMPTY, cube.mapPosition);
                if (this.playground.controls.isDirectionX) {
                    cube.mapPosition.x = Math.max(0, Math.min(cuboro.MAX_X - 1, cube.mapPosition.x - this.playground.controls.direction));
                }
                else {
                    cube.mapPosition.z = Math.max(0, Math.min(cuboro.MAX_Z - 1, cube.mapPosition.z + this.playground.controls.direction));
                }
                this.update(cube);
            };
            MoveMenu.prototype.toScreen = function () {
                if (!this.visible)
                    return;
                if (!this.playground.cubes.selected)
                    return;
                var vector = new THREE.Vector3();
                var widthHalf = 0.5 * (this.playground.canvas.renderer.context.canvas.width / this.game.scaleX);
                var heightHalf = 0.5 * (this.playground.canvas.renderer.context.canvas.height / this.game.scaleY);
                this.playground.cubes.selected.mesh.updateMatrixWorld(true);
                vector.setFromMatrixPosition(this.playground.cubes.selected.mesh.matrixWorld);
                vector.project(this.playground.camera);
                vector.x = ((vector.x * widthHalf) + widthHalf) / this.game.client.config.resolution;
                vector.y = (-(vector.y * heightHalf) + heightHalf) / this.game.client.config.resolution;
                this.x = vector.x - (this.width >> 1);
                this.y = vector.y - (this.height >> 1);
                this.updateButtons();
                this.checkBounds();
            };
            MoveMenu.prototype.checkBounds = function () {
                var right = this.x < this.playground.gameScreen.layers.right;
                var left = this.right > this.game.width;
                var up = this.bottom > this.playground.gameScreen.bottomMenu.y;
                var down = this.y < this.game.stage.header.bottom;
                var moved = false;
                if (!right && left) {
                    this.playground.controls.panLeft(-1);
                    moved = true;
                }
                else if (right && !left) {
                    this.playground.controls.panLeft(1);
                    moved = true;
                }
                if (!up && down) {
                    this.playground.controls.panUp(1);
                    moved = true;
                }
                else if (up && !down) {
                    this.playground.controls.panUp(-1);
                    moved = true;
                }
                if (moved)
                    this.playground.once(cuboro.CAMERA_UPDATE, this.toScreen, this);
            };
            MoveMenu.prototype.updateButtons = function () {
                var cube = this.playground.cubes.selected;
                if (!cube)
                    return;
                var next;
                if (this.playground.controls.isDirectionX) {
                    next = cube.mapPosition.x + this.playground.controls.direction;
                    this.btUp.isEnabled = this.playground.map.isValidX(next);
                    if (!this.isValidY(next, cube.mapPosition.z))
                        this.btUp.isEnabled = false;
                    next = cube.mapPosition.z - this.playground.controls.direction;
                    this.btLeft.isEnabled = this.playground.map.isValidZ(next);
                    if (!this.isValidY(cube.mapPosition.x, next))
                        this.btLeft.isEnabled = false;
                    next = cube.mapPosition.z + this.playground.controls.direction;
                    this.btRight.isEnabled = this.playground.map.isValidZ(next);
                    if (!this.isValidY(cube.mapPosition.x, next))
                        this.btRight.isEnabled = false;
                    next = cube.mapPosition.x - this.playground.controls.direction;
                    this.btDown.isEnabled = this.playground.map.isValidX(next);
                    if (!this.isValidY(next, cube.mapPosition.z))
                        this.btDown.isEnabled = false;
                }
                else {
                    next = cube.mapPosition.z - this.playground.controls.direction;
                    this.btUp.isEnabled = this.playground.map.isValidZ(next);
                    if (!this.isValidY(cube.mapPosition.x, next))
                        this.btUp.isEnabled = false;
                    next = cube.mapPosition.x - this.playground.controls.direction;
                    this.btLeft.isEnabled = this.playground.map.isValidX(next);
                    if (!this.isValidY(next, cube.mapPosition.z))
                        this.btLeft.isEnabled = false;
                    next = cube.mapPosition.x + this.playground.controls.direction;
                    this.btRight.isEnabled = this.playground.map.isValidX(next);
                    if (!this.isValidY(next, cube.mapPosition.z))
                        this.btRight.isEnabled = false;
                    next = cube.mapPosition.z + this.playground.controls.direction;
                    this.btDown.isEnabled = this.playground.map.isValidZ(next);
                    if (!this.isValidY(cube.mapPosition.x, next))
                        this.btDown.isEnabled = false;
                }
            };
            MoveMenu.prototype.hide = function () {
                if (this.visible) {
                    this.playground.placeables.hide();
                    if (this.playground.cubes.selected)
                        this.playground.gameScreen.rotateMenu.show();
                }
                this.visible = false;
            };
            MoveMenu.prototype.show = function () {
                this.playground.placeables.show();
                this.playground.gameScreen.rotateMenu.hide();
                this.visible = true;
                this.toScreen();
            };
            MoveMenu.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.toScreen();
            };
            return MoveMenu;
        }(gf.display.Container));
        ui.MoveMenu = MoveMenu;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var RotateMenu = (function (_super) {
            __extends(RotateMenu, _super);
            function RotateMenu(playground) {
                var _this = _super.call(this, playground.game) || this;
                _this.interactive = true;
                _this.playground = playground;
                _this.btUp = new cuboro.ui.RoundIconButton(_this.game, "cube_up");
                _this.btUp.on(gf.CLICK, _this.onUp, _this);
                _this.addChild(_this.btUp);
                _this.btDown = new cuboro.ui.RoundIconButton(_this.game, "cube_down");
                _this.btDown.on(gf.CLICK, _this.onDown, _this);
                _this.addChild(_this.btDown);
                _this.btLeft = new cuboro.ui.RoundIconButton(_this.game, "cube_left");
                _this.btLeft.on(gf.CLICK, _this.onLeft, _this);
                _this.addChild(_this.btLeft);
                _this.btLeftSide = new cuboro.ui.RoundIconButton(_this.game, "cube_side_left");
                _this.btLeftSide.on(gf.CLICK, _this.onLeftSide, _this);
                _this.addChild(_this.btLeftSide);
                _this.btRight = new cuboro.ui.RoundIconButton(_this.game, "cube_right");
                _this.btRight.on(gf.CLICK, _this.onRight, _this);
                _this.addChild(_this.btRight);
                _this.btRightSide = new cuboro.ui.RoundIconButton(_this.game, "cube_side_right");
                _this.btRightSide.on(gf.CLICK, _this.onRightSide, _this);
                _this.addChild(_this.btRightSide);
                _this.btUp.x = _this.btUp.width + 25;
                _this.btLeftSide.y = _this.btUp.bottom + 10;
                _this.btRightSide.x = _this.btUp.right + 25;
                _this.btRightSide.y = _this.btLeftSide.y;
                _this.btLeft.y = _this.btLeftSide.bottom + 20;
                _this.btRight.x = _this.btRightSide.x;
                _this.btRight.y = _this.btLeft.y;
                _this.btDown.x = _this.btUp.x;
                _this.btDown.y = _this.btLeft.bottom + 10;
                _this.playground.on(cuboro.CAMERA_UPDATED, _this.toScreen, _this);
                _this.playground.on(cuboro.CUBE_UPDATE, _this.toScreen, _this);
                _this.visible = false;
                return _this;
            }
            RotateMenu.prototype.onUp = function () {
                var _this = this;
                TweenMax.killChildTweensOf(this, true);
                if (!this.playground.controls.isDirectionX) {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationX: this.playground.controls.direction * -cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationX();
                            _this.onRotation();
                        }
                    });
                }
                else {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationZ: this.playground.controls.direction * -cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationZ();
                            _this.onRotation();
                        }
                    });
                }
            };
            RotateMenu.prototype.onDown = function () {
                var _this = this;
                TweenMax.killChildTweensOf(this, true);
                if (!this.playground.controls.isDirectionX) {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationX: this.playground.controls.direction * cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationX();
                            _this.onRotation();
                        }
                    });
                }
                else {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationZ: this.playground.controls.direction * cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationZ();
                            _this.onRotation();
                        }
                    });
                }
            };
            RotateMenu.prototype.onLeft = function () {
                var _this = this;
                TweenMax.killChildTweensOf(this, true);
                TweenMax.to(this.playground.cubes.selected, 0.25, {
                    rotationY: -cuboro.DEG_RAD_90,
                    onComplete: function () {
                        _this.playground.cubes.selected.resetRotationY();
                        _this.onRotation();
                    }
                });
            };
            RotateMenu.prototype.onLeftSide = function () {
                var _this = this;
                TweenMax.killChildTweensOf(this, true);
                if (!this.playground.controls.isDirectionX) {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationZ: this.playground.controls.direction * cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationZ();
                            _this.onRotation();
                        }
                    });
                }
                else {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationX: this.playground.controls.direction * -cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationX();
                            _this.onRotation();
                        }
                    });
                }
            };
            RotateMenu.prototype.onRight = function () {
                var _this = this;
                TweenMax.killChildTweensOf(this, true);
                TweenMax.to(this.playground.cubes.selected, 0.25, {
                    rotationY: cuboro.DEG_RAD_90,
                    onComplete: function () {
                        _this.playground.cubes.selected.resetRotationY();
                        _this.onRotation();
                    }
                });
            };
            RotateMenu.prototype.onRightSide = function () {
                var _this = this;
                TweenMax.killChildTweensOf(this, true);
                if (!this.playground.controls.isDirectionX) {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationZ: this.playground.controls.direction * -cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationZ();
                            _this.onRotation();
                        }
                    });
                }
                else {
                    TweenMax.to(this.playground.cubes.selected, 0.25, {
                        rotationX: this.playground.controls.direction * cuboro.DEG_RAD_90,
                        onComplete: function () {
                            _this.playground.cubes.selected.resetRotationX();
                            _this.onRotation();
                        }
                    });
                }
            };
            RotateMenu.prototype.onRotation = function () {
                this.playground.history.save();
                this.playground.save();
            };
            RotateMenu.prototype.toScreen = function () {
                if (!this.visible)
                    return;
                if (!this.playground.cubes.selected)
                    return;
                var vector = new THREE.Vector3();
                var widthHalf = 0.5 * (this.playground.canvas.renderer.context.canvas.width / this.game.scaleX);
                var heightHalf = 0.5 * (this.playground.canvas.renderer.context.canvas.height / this.game.scaleY);
                this.playground.cubes.selected.mesh.updateMatrixWorld(true);
                vector.setFromMatrixPosition(this.playground.cubes.selected.mesh.matrixWorld);
                vector.project(this.playground.camera);
                vector.x = ((vector.x * widthHalf) + widthHalf) / this.game.client.config.resolution;
                vector.y = (-(vector.y * heightHalf) + heightHalf) / this.game.client.config.resolution;
                this.x = vector.x - (this.width >> 1);
                this.y = vector.y - (this.height >> 1);
                this.checkBounds();
            };
            RotateMenu.prototype.checkBounds = function () {
                var right = this.x < this.playground.gameScreen.layers.right;
                var left = this.right > this.game.width;
                var up = this.bottom > this.playground.gameScreen.bottomMenu.y;
                var down = this.y < this.game.stage.header.bottom;
                var moved = false;
                if (!right && left) {
                    this.playground.controls.panLeft(-1);
                    moved = true;
                }
                else if (right && !left) {
                    this.playground.controls.panLeft(1);
                    moved = true;
                }
                if (!up && down) {
                    this.playground.controls.panUp(1);
                    moved = true;
                }
                else if (up && !down) {
                    this.playground.controls.panUp(-1);
                    moved = true;
                }
                if (moved)
                    this.playground.once(cuboro.CAMERA_UPDATE, this.toScreen, this);
            };
            RotateMenu.prototype.hide = function () {
                this.visible = false;
            };
            RotateMenu.prototype.show = function () {
                this.visible = true;
                this.toScreen();
            };
            RotateMenu.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.toScreen();
            };
            return RotateMenu;
        }(gf.display.Container));
        ui.RotateMenu = RotateMenu;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var screens;
    (function (screens) {
        var Game = (function (_super) {
            __extends(Game, _super);
            function Game() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Game.prototype.start = function () {
            };
            Game.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.start();
            };
            Game.NAME = "game";
            return Game;
        }(gf.screens.Screen));
        screens.Game = Game;
    })(screens = gf.screens || (gf.screens = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var screens;
    (function (screens) {
        var Game = (function (_super) {
            __extends(Game, _super);
            function Game() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Game.prototype.init = function () {
                this.interaction = new cuboro.core.Interaction(this.game);
                this.addChild(this.interaction);
                this.playground = new cuboro.core.Playground(this);
                this.marbleRun = new cuboro.ui.MarbleRun(this);
                this.addChild(this.marbleRun);
                this.moveMenu = new cuboro.ui.MoveMenu(this.playground);
                this.addChild(this.moveMenu);
                this.rotateMenu = new cuboro.ui.RotateMenu(this.playground);
                this.addChild(this.rotateMenu);
                this.layers = new cuboro.ui.Layers(this);
                this.layers.y = this.game.stage.header.bottom;
                this.addChild(this.layers);
                this.bottomMenu = new cuboro.ui.BottomMenu(this);
                this.addChild(this.bottomMenu);
            };
            Game.prototype.transitionInComplete = function () {
                _super.prototype.transitionInComplete.call(this);
                this.game.stage.header.trackMenu.show();
            };
            Game.prototype.transitionOutComplete = function () {
                _super.prototype.transitionOutComplete.call(this);
                this.playground.stop();
                this.game.stage.header.trackMenu.hide();
            };
            return Game;
        }(gf.screens.Game));
        screens.Game = Game;
    })(screens = cuboro.screens || (cuboro.screens = {}));
})(cuboro || (cuboro = {}));
var kr3m;
(function (kr3m) {
    var tracking3;
    (function (tracking3) {
        var Track = (function () {
            function Track() {
            }
            Track.track = function () {
                if (typeof trackGTMCustom != "function")
                    return;
                var trackObj = typeof arguments[0] == "string" ? { eventAction: arguments[0] } : (arguments[0] || {});
                trackObj.event = trackObj.event || "kr3m";
                trackObj.hitType = trackObj.hitType || "Button";
                trackObj.eventCategory = trackObj.eventCategory || "Click";
                trackGTMCustom(trackObj);
            };
            return Track;
        }());
        tracking3.Track = Track;
    })(tracking3 = kr3m.tracking3 || (kr3m.tracking3 = {}));
})(kr3m || (kr3m = {}));
function track() {
    kr3m.tracking3.Track.track(arguments[0]);
}
var gf;
(function (gf) {
    var screens;
    (function (screens) {
        var Start = (function (_super) {
            __extends(Start, _super);
            function Start() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Start.prototype.init = function () {
                this.addBtPlay();
                this.addVersion();
            };
            Start.prototype.addBtPlay = function () {
                if (this.btPlay)
                    this.btPlay.on(gf.CLICK, this.onPlay, this);
            };
            Start.prototype.addVersion = function () {
                this.tfVersion = new gf.display.Text(this.game, loc("say_hello", {
                    name: loc("app_title")
                }));
                this.tfVersion.style.fontFamily = "Arial";
                this.tfVersion.style.fontSize = 8;
                this.tfVersion.hAlign(gf.RIGHT, this.game, -5);
                this.tfVersion.vAlign(gf.BOTTOM, this.game, -5);
                this.addChild(this.tfVersion);
            };
            Start.prototype.onPlay = function () {
                var _this = this;
                track("Start-Play");
                if (this.game.levels.levelCount == 1) {
                    this.game.stage.header.hide();
                    this.game.levels.loadLevel(0, function () {
                        _this.game.overlays.show("detail");
                    });
                }
                else {
                    this.game.screens.show("trail");
                }
            };
            Start.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                if (this.game.stage.header)
                    this.game.stage.header.show();
            };
            Start.NAME = "start";
            return Start;
        }(gf.screens.Screen));
        screens.Start = Start;
    })(screens = gf.screens || (gf.screens = {}));
})(gf || (gf = {}));
var cuboro;
(function (cuboro) {
    var screens;
    (function (screens) {
        var Screen = (function (_super) {
            __extends(Screen, _super);
            function Screen() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            return Screen;
        }(gf.screens.Screen));
        screens.Screen = Screen;
    })(screens = cuboro.screens || (cuboro.screens = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TextLinkButton = (function (_super) {
            __extends(TextLinkButton, _super);
            function TextLinkButton(game, label) {
                var _this = _super.call(this, game) || this;
                _this.tfLabel = new gf.display.Text(game, "", cuboro.TEXT_STYLE_BUTTON_FOOTER.clone());
                _this.addChild(_this.tfLabel);
                _this.label = label;
                _this.setState(gf.OUT);
                return _this;
            }
            TextLinkButton.prototype.setState = function (state) {
                this.tfLabel.alpha = 1;
                if (!this.isEnabled) {
                    this.tfLabel.alpha = 0.5;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.tfLabel.style.fill = cuboro.COLOR_GREY;
                        break;
                    case gf.OUT:
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.tfLabel.style.fill = cuboro.COLOR_YELLOW;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.tfLabel.style.fill = cuboro.COLOR_YELLOW;
                        }
                        else {
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            TextLinkButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.setState(this._currentState);
            };
            TextLinkButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.setState(this._currentState);
            };
            Object.defineProperty(TextLinkButton.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (value == this._label)
                        return;
                    this._label = value;
                    this.tfLabel.text = this._label;
                    this.hitArea = this.getLocalBounds();
                },
                enumerable: true,
                configurable: true
            });
            return TextLinkButton;
        }(gf.ui.Button));
        ui.TextLinkButton = TextLinkButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Language = (function (_super) {
            __extends(Language, _super);
            function Language(game) {
                var _this = _super.call(this, game) || this;
                _this.icon = new gf.display.Sprite(_this.game, "sprites", "icon_language");
                _this.icon.tint = cuboro.COLOR_DARK_GREY;
                _this.addChild(_this.icon);
                _this.btGerman = new cuboro.ui.TextLinkButton(_this.game, loc("bt_german"));
                _this.btGerman.x = _this.icon.right + cuboro.PADDING;
                _this.addChild(_this.btGerman);
                var divider = new gf.display.Text(_this.game, "|", cuboro.TEXT_STYLE_VERSION.clone());
                divider.x = _this.btGerman.right + cuboro.PADDING;
                _this.addChild(divider);
                _this.btEnglish = new cuboro.ui.TextLinkButton(_this.game, loc("bt_english"));
                _this.btEnglish.x = divider.right + cuboro.PADDING;
                _this.addChild(_this.btEnglish);
                return _this;
            }
            return Language;
        }(gf.display.Container));
        ui.Language = Language;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Contest = (function (_super) {
                __extends(Contest, _super);
                function Contest(game) {
                    var _this = _super.call(this, game) || this;
                    _this.tfInfo = new gf.display.Text(_this.game, loc("contest_empty"), cuboro.TEXT_STYLE_TITLE_HINT.clone());
                    _this.tfInfo.style.align = gf.CENTER;
                    _this.tfInfo.style.wordWrap = true;
                    _this.addChild(_this.tfInfo);
                    return _this;
                }
                Contest.prototype.updateSize = function (width, height) {
                    _super.prototype.updateSize.call(this, width, height);
                    this.tfInfo.style.wordWrapWidth = width - cuboro.PADDING * 4;
                    this.tfInfo.x = (width - this.tfInfo.width) >> 1;
                    this.tfInfo.y = (height - this.tfInfo.height) >> 1;
                };
                return Contest;
            }(cuboro.ui.tabs.Tab));
            tabs.Contest = Contest;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var CreateButton = (function (_super) {
            __extends(CreateButton, _super);
            function CreateButton(game, label, type) {
                var _this = _super.call(this, game, label, true) || this;
                _this.icon = new gf.display.Sprite(_this.game, type == "FREE" ? "icon_new_track" : "icon_contest");
                _this.addChild(_this.icon);
                _this.bg.y = _this.icon.bottom + cuboro.PADDING;
                _this.tfLabel.y += _this.bg.y;
                _this.label = label;
                return _this;
            }
            CreateButton.prototype.setWidth = function (value) {
                _super.prototype.setWidth.call(this, value);
                var w = Math.max(this.bg.width, this.icon.width);
                this.bg.hAlign(gf.CENTER, w);
                this.tfLabel.hAlign(gf.CENTER, w);
                this.icon.hAlign(gf.CENTER, w);
                this.hitArea = this.getLocalBounds();
            };
            Object.defineProperty(CreateButton.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (!this.icon || value == this._label)
                        return;
                    this._label = value;
                    this.tfLabel.text = this._label;
                    this.setWidth(Math.round(this.tfLabel.width) + 20);
                },
                enumerable: true,
                configurable: true
            });
            return CreateButton;
        }(cuboro.ui.TextButton));
        ui.CreateButton = CreateButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Create = (function (_super) {
                __extends(Create, _super);
                function Create(game) {
                    var _this = _super.call(this, game) || this;
                    _this.content.x =
                        _this.contentMask.x = cuboro.PADDING;
                    _this.content.y =
                        _this.contentMask.y = cuboro.PADDING * 2;
                    _this.btCreateNewTrack = new cuboro.ui.TextButton(_this.game, loc("bt_create_track"), true);
                    _this.btCreateNewTrack.on(gf.CLICK, _this.onCreateTrack, _this);
                    _this.btCreateNewTrack.autoFit();
                    _this.addChild(_this.btCreateNewTrack);
                    _this.tfSelected = new gf.display.Text(_this.game, loc("new_track_selected", {
                        sets: 0,
                        sixpacks: 0
                    }), cuboro.TEXT_STYLE_TITLE_TAB.clone());
                    _this.tfSelected.style.fontSize = 13;
                    _this.tfSelected.x = cuboro.PADDING;
                    _this.addChild(_this.tfSelected);
                    _this.addSets();
                    return _this;
                }
                Create.prototype.addSet = function (value) {
                    var bt = new cuboro.ui.SelectSetButton(this.game, value);
                    bt.on(gf.CHANGE, this.onSet, this);
                    this.content.addChild(bt);
                    this.items.push(bt);
                };
                Create.prototype.onSet = function () {
                    var sets = 0;
                    var sixpacks = 0;
                    this.items.forEach(function (value) {
                        if (value.isSelected) {
                            if (value.setName.indexOf("sixpack") != -1)
                                sixpacks++;
                            else
                                sets++;
                        }
                    });
                    this.tfSelected.text = loc("new_track_selected", { sets: sets, sixpacks: sixpacks });
                    this.btCreateNewTrack.isEnabled = sets + sixpacks > 0;
                };
                Create.prototype.addSets = function () {
                    var _this = this;
                    this.items = [];
                    var setOrder = [cuboro.SETS.STANDARD,
                        cuboro.SETS.BASIC,
                        cuboro.SETS.BUILD,
                        cuboro.SETS.DUO,
                        cuboro.SETS.METRO,
                        cuboro.SETS.MULTI,
                        cuboro.SETS.PLUS,
                        cuboro.SETS.PROFI,
                        cuboro.SETS.SIXPACK_DUO,
                        cuboro.SETS.SIXPACK_PROFI,
                        cuboro.SETS.SIXPACK_METRO,
                        cuboro.SETS.SIXPACK_MULTI,
                        cuboro.SETS.SIXPACK_PLUS];
                    setOrder.forEach(function (value) {
                        _this.addSet(value);
                    });
                    this.onResize();
                };
                Create.prototype.onCreateTrack = function () {
                    var _this = this;
                    var selectedSets = [];
                    this.items.forEach(function (value) {
                        if (value.isSelected)
                            selectedSets.push(value.setName);
                    });
                    if (selectedSets.length > 0) {
                        mTrack = new cuboro.vo.Track();
                        mTrack.data.sets = selectedSets;
                        if (mUser.isLoggedIn())
                            mTrack.owner = mUser.getUser();
                        this.game.overlays.show(cuboro.overlays.Loader.NAME);
                        sTrack.generateUniqueRandomName(loc("trackname_prefix"), function (response) {
                            _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                            mTrack.name = response;
                            cuboro.core.Loader.loadTrack(_this.game, mTrack, false);
                        });
                    }
                };
                Create.prototype.reset = function () {
                    this.items.forEach(function (value) {
                        value.isSelected = false;
                    });
                    this.tfSelected.text = loc("new_track_selected", { sets: 0, sixpacks: 0 });
                    this.btCreateNewTrack.isEnabled = false;
                };
                Create.prototype.arrange = function () {
                    if (this.items.length == 0)
                        return;
                    var itemSize;
                    itemSize = this.items[0].width;
                    var width = this.contentMask.width - (this.scrollbar.width + cuboro.PADDING * 2);
                    var col = 0;
                    var row = 0;
                    var cols = Math.min(Math.floor(width / (itemSize + cuboro.PADDING)), 5);
                    var offsetX = (this.contentMask.width - (cols * itemSize + cols * cuboro.PADDING * 2)) >> 1;
                    this.items.forEach(function (value) {
                        if (col == cols) {
                            row++;
                            col = 0;
                        }
                        value.x = col * itemSize + col * cuboro.PADDING * 2 + offsetX;
                        value.y = row * itemSize + row * cuboro.PADDING;
                        col++;
                    });
                    this.bounds.width = this.contentMask.width;
                    this.bounds.height = row * itemSize + row * cuboro.PADDING + itemSize;
                    this.scrollbar.update(this.content, this.contentMask, 0);
                    if (!this.scrollbar.visible)
                        this.content.y = (this.contentMask.height - this.content.height) >> 1;
                    else
                        this.content.y = this.contentMask.y;
                };
                Create.prototype.updateSize = function (width, height) {
                    _super.prototype.updateSize.call(this, width - this.scrollbar.width - cuboro.PADDING * 2, height - cuboro.PADDING * 4 - this.btCreateNewTrack.height);
                    this.onResize();
                };
                Create.prototype.show = function () {
                    _super.prototype.show.call(this);
                    this.onSet();
                    if (!this.scrollbar.visible)
                        this.content.y = (this.contentMask.height - this.content.height) >> 1;
                    else
                        this.content.y = this.contentMask.y;
                };
                Create.prototype.onResize = function () {
                    _super.prototype.onResize.call(this);
                    this.btCreateNewTrack.x = this.btCreateNewTrack.x = (this.game.width - this.btCreateNewTrack.width) >> 1;
                    this.btCreateNewTrack.y = this.contentMask.bottom + cuboro.PADDING;
                    this.tfSelected.y = this.btCreateNewTrack.y + ((this.btCreateNewTrack.height - this.tfSelected.height) >> 1);
                    this.arrange();
                };
                return Create;
            }(cuboro.ui.tabs.Tab));
            tabs.Create = Create;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var GalleryItemButton = (function (_super) {
            __extends(GalleryItemButton, _super);
            function GalleryItemButton(game, label) {
                var _this = _super.call(this, game) || this;
                _this.icon = new gf.display.Sprite(_this.game, "sprites", "icon_details_gallery");
                _this.icon.tint = cuboro.COLOR_DARK_GREY;
                _this.icon.y = 1;
                _this.addChild(_this.icon);
                _this.tfLabel = new gf.display.Text(game, "", cuboro.TEXT_STYLE_SMALL.clone());
                _this.tfLabel.x = _this.icon.right + cuboro.PADDING;
                _this.addChild(_this.tfLabel);
                _this.label = label;
                _this.setState(gf.OUT);
                return _this;
            }
            GalleryItemButton.prototype.setState = function (state) {
                this.tfLabel.alpha = 1;
                if (!this.isEnabled) {
                    this.tfLabel.alpha = 0.5;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.tfLabel.style.fill = cuboro.COLOR_GREY;
                        this.icon.tint = cuboro.COLOR_GREY;
                        break;
                    case gf.OUT:
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                        this.icon.tint = cuboro.COLOR_WHITE;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.tfLabel.style.fill = cuboro.COLOR_WHITE;
                            this.icon.tint = cuboro.COLOR_WHITE;
                        }
                        else {
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            GalleryItemButton.prototype.enable = function () {
                _super.prototype.enable.call(this);
                this.setState(this._currentState);
            };
            GalleryItemButton.prototype.disable = function () {
                _super.prototype.disable.call(this);
                this.setState(this._currentState);
            };
            Object.defineProperty(GalleryItemButton.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (value == this._label)
                        return;
                    this._label = value;
                    this.tfLabel.text = this._label;
                    this.hitArea = this.getLocalBounds();
                },
                enumerable: true,
                configurable: true
            });
            return GalleryItemButton;
        }(gf.ui.Button));
        ui.GalleryItemButton = GalleryItemButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var GalleryItem = (function (_super) {
            __extends(GalleryItem, _super);
            function GalleryItem(game) {
                var _this = _super.call(this, game) || this;
                _this.interactive = true;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.tint = cuboro.COLOR_MID_GREY;
                _this.bg.width = 150;
                _this.bg.height = 150;
                _this.addChild(_this.bg);
                _this.preview = new cuboro.ui.TrackPreview(_this.game);
                _this.preview.x = 1;
                _this.preview.y = 1;
                _this.preview.width = 148;
                _this.preview.height = 148;
                _this.addChild(_this.preview);
                _this.bgTop = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bgTop.tint = cuboro.COLOR_MID_GREY;
                _this.bgTop.width = 150;
                _this.bgTop.height = 22;
                _this.addChild(_this.bgTop);
                _this.tfTrackName = new gf.display.Text(_this.game);
                _this.tfTrackName.style = cuboro.TEXT_STYLE_BUTTON_CUBE.clone();
                _this.tfTrackName.x = cuboro.PADDING;
                _this.tfTrackName.y = (_this.bgTop.height - _this.tfTrackName.height) >> 1;
                _this.addChild(_this.tfTrackName);
                _this.bgBottom = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bgBottom.tint = cuboro.COLOR_MID_GREY;
                _this.bgBottom.width = 150;
                _this.bgBottom.height = 22;
                _this.bgBottom.y = 128;
                _this.addChild(_this.bgBottom);
                _this.btLoad = new gf.display.Sprite(_this.game, PIXI.Texture.EMPTY);
                _this.btLoad.on("click tap", _this.onLoad, _this);
                _this.btLoad.width = _this.bg.width;
                _this.btLoad.height = _this.bg.height - _this.bgBottom.height;
                _this.btLoad.interactive = true;
                _this.btLoad.buttonMode = true;
                _this.addChild(_this.btLoad);
                _this.trophy = new gf.display.Sprite(_this.game, "sprites", "icon_trophy");
                _this.trophy.tint = cuboro.COLOR_DARK_GREY;
                _this.trophy.x = cuboro.PADDING;
                _this.trophy.y = 132;
                _this.addChild(_this.trophy);
                _this.tfScoreTotal = new gf.display.Text(_this.game);
                _this.tfScoreTotal.style = cuboro.TEXT_STYLE_SMALL.clone();
                _this.tfScoreTotal.x = _this.trophy.right + cuboro.PADDING;
                _this.tfScoreTotal.y = 132;
                _this.addChild(_this.tfScoreTotal);
                _this.btDetails = new cuboro.ui.GalleryItemButton(_this.game, loc("bt_track_details"));
                _this.btDetails.on("click tap", _this.onDetails, _this);
                _this.btDetails.x = (150 - _this.btDetails.width - cuboro.PADDING) >> 0;
                _this.btDetails.y = _this.tfScoreTotal.y;
                _this.addChild(_this.btDetails);
                return _this;
            }
            GalleryItem.prototype.onDetails = function () {
                var trackDetails = this.game.overlays.show(cuboro.overlays.TrackDetails.NAME);
                trackDetails.track = this._track;
            };
            GalleryItem.prototype.onLoad = function () {
                cuboro.core.Loader.loadTrack(this.game, this.track, false);
            };
            GalleryItem.prototype.update = function () {
                if (!this._track || !this._track.data)
                    return;
                if (this._track.imageUrl)
                    this.preview.url = this._track.imageUrl;
                this.tfTrackName.text = this._track.name;
                this.tfTrackName.truncate(this.bg.width - cuboro.PADDING * 2);
                if (this._track.data.evaluation)
                    this.tfScoreTotal.text = this._track.data.evaluation.scoreTotal.toString();
                else
                    this.tfScoreTotal.text = "-";
            };
            Object.defineProperty(GalleryItem.prototype, "track", {
                get: function () {
                    return this._track;
                },
                set: function (value) {
                    this._track = value;
                    this.update();
                },
                enumerable: true,
                configurable: true
            });
            return GalleryItem;
        }(gf.display.Sprite));
        ui.GalleryItem = GalleryItem;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TextIconButton = (function (_super) {
            __extends(TextIconButton, _super);
            function TextIconButton(game, icon, label) {
                var _this = _super.call(this, game, label, false) || this;
                _this.icon = new gf.display.Sprite(_this.game, "sprites", "icon_" + icon);
                _this.icon.x = cuboro.PADDING;
                _this.addChild(_this.icon);
                _this.tfLabel.x = _this.icon.right + cuboro.PADDING;
                _this.label = label;
                _this.setState(_this._currentState);
                return _this;
            }
            TextIconButton.prototype.setState = function (state) {
                if (!this.icon)
                    return;
                this.icon.alpha = 1;
                this.tfLabel.alpha = 1;
                if (!this.isEnabled) {
                    this.bg.frameName = "bt_text_disabled";
                    this.icon.alpha = 0.5;
                    this.tfLabel.alpha = 0.5;
                    return;
                }
                if (this.isSelected) {
                    this.bg.frameName = "bt_text_over";
                    this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                    this.icon.tint = cuboro.COLOR_DARK_GREY;
                    return;
                }
                switch (this._currentState) {
                    case gf.DOWN:
                        this.bg.frameName = "bt_text_down";
                        this.icon.tint = cuboro.COLOR_YELLOW;
                        this.tfLabel.style.fill = cuboro.COLOR_YELLOW;
                        break;
                    case gf.OUT:
                        this.bg.frameName = (this.isPrimary) ? "bt_text_out" : "bt_text_sek_out";
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.OVER:
                        this.bg.frameName = "bt_text_over";
                        this.icon.tint = cuboro.COLOR_DARK_GREY;
                        this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        break;
                    case gf.UP:
                        if (this.isOver) {
                            this.bg.frameName = "bt_text_over";
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        else {
                            this.bg.frameName = (this.isPrimary) ? "bt_text_out" : "bt_text_sek_out";
                            this.icon.tint = cuboro.COLOR_DARK_GREY;
                            this.tfLabel.style.fill = cuboro.COLOR_DARK_GREY;
                        }
                        break;
                }
            };
            TextIconButton.prototype.setWidth = function (value) {
                this.bg.width = value;
                this.hitArea = this.getLocalBounds();
            };
            Object.defineProperty(TextIconButton.prototype, "label", {
                get: function () {
                    return this._label;
                },
                set: function (value) {
                    if (value == this._label || !this.icon)
                        return;
                    this._label = value;
                    this.tfLabel.text = this._label;
                    this.bg.width = Math.round(this.tfLabel.width) + this.icon.width + 20;
                    this.hitArea = this.getLocalBounds();
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(TextIconButton.prototype, "isSelected", {
                get: function () {
                    return this._isSelected;
                },
                set: function (value) {
                    this._isSelected = value;
                    this._isOver = false;
                    this.setState(this._currentState);
                },
                enumerable: true,
                configurable: true
            });
            return TextIconButton;
        }(cuboro.ui.TextButton));
        ui.TextIconButton = TextIconButton;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var tabs;
        (function (tabs) {
            var Gallery = (function (_super) {
                __extends(Gallery, _super);
                function Gallery(game) {
                    var _this = _super.call(this, game) || this;
                    _this.items = [];
                    _this.btBest = new cuboro.ui.TextIconButton(_this.game, "best", loc("bt_tracks_best"));
                    _this.btBest.x = cuboro.PADDING;
                    _this.btBest.y = cuboro.PADDING * 2;
                    _this.btBest.isSelected = true;
                    _this.btBest.setWidth(150);
                    _this.btBest.on(gf.CLICK, function () { return _this.onFilter("rating", false, false, _this.btBest, true); }, _this);
                    _this.addChild(_this.btBest);
                    _this.btNewest = new cuboro.ui.TextIconButton(_this.game, "newest", loc("bt_tracks_newest"));
                    _this.btNewest.x = _this.btBest.right + cuboro.PADDING;
                    _this.btNewest.y = _this.btBest.y;
                    _this.btNewest.setWidth(150);
                    _this.btNewest.on(gf.CLICK, function () { return _this.onFilter("age", false, false, _this.btNewest, true); }, _this);
                    _this.addChild(_this.btNewest);
                    _this.btOwn = new cuboro.ui.TextIconButton(_this.game, "own", loc("bt_tracks_own"));
                    _this.btOwn.x = _this.btNewest.right + cuboro.PADDING;
                    _this.btOwn.y = _this.btBest.y;
                    _this.btOwn.setWidth(150);
                    _this.btOwn.isEnabled = mUser.isLoggedIn();
                    _this.btOwn.on(gf.CLICK, function () { return _this.onFilter("age", true, false, _this.btOwn, true); }, _this);
                    _this.addChild(_this.btOwn);
                    _this.btEdu = new cuboro.ui.TextIconButton(_this.game, "edu", loc("bt_tracks_edu"));
                    _this.btEdu.x = _this.btOwn.right + cuboro.PADDING;
                    _this.btEdu.y = _this.btBest.y;
                    _this.btEdu.setWidth(150);
                    _this.btEdu.on(gf.CLICK, function () { return _this.onFilter("age", false, true, _this.btEdu, true); }, _this);
                    _this.addChild(_this.btEdu);
                    _this.content.x =
                        _this.contentMask.x = cuboro.PADDING;
                    _this.content.y =
                        _this.contentMask.y = _this.btBest.bottom + cuboro.PADDING * 2;
                    _this.btLoadMore = new cuboro.ui.TextButton(_this.game, loc("bt_load_more"), false);
                    _this.btLoadMore.isEnabled = false;
                    _this.btLoadMore.on(gf.CLICK, _this.onLoadMore, _this);
                    _this.addChild(_this.btLoadMore);
                    _this.tfTracks = new gf.display.Text(_this.game, loc("gallery_tracks", { value: 0 }));
                    _this.tfTracks.style = cuboro.TEXT_STYLE_BUTTON_TEXT.clone();
                    _this.tfTracks.visible = false;
                    _this.addChild(_this.tfTracks);
                    mUser.on("loggedIn", function () { return _this.btOwn.isEnabled = true; });
                    mUser.on("logout", function () { return _this.btOwn.isEnabled = false; });
                    return _this;
                }
                Gallery.prototype.onLoadMore = function () {
                    this.galleryFilters.offset += this.galleryFilters.limit;
                    this.getPage(this.galleryFilters, false);
                };
                Gallery.prototype.addItem = function (track) {
                    var _this = this;
                    var item = new cuboro.ui.GalleryItem(this.game);
                    item.track = track;
                    item.on(gf.CLICK, function () { return _this.emit("track", item); }, this);
                    this.content.addChild(item);
                    this.items.push(item);
                };
                Gallery.prototype.getItem = function (id) {
                    var item = null;
                    this.items.forEach(function (value) {
                        if (value.track.id == id) {
                            item = value;
                            return true;
                        }
                    });
                    return item;
                };
                Gallery.prototype.onFilter = function (sortBy, own, edu, bt, reset) {
                    if (reset === void 0) { reset = false; }
                    var filters = {
                        offset: 0,
                        limit: 20,
                        own: own,
                        edu: edu,
                        sortBy: sortBy
                    };
                    this.btBest.isSelected = this.btBest == bt;
                    this.btNewest.isSelected = this.btNewest == bt;
                    this.btOwn.isSelected = this.btOwn == bt;
                    this.btEdu.isSelected = this.btEdu == bt;
                    this.getPage(filters, reset);
                };
                Gallery.prototype.arrange = function () {
                    var itemSize = 150;
                    var col = 0;
                    var row = 0;
                    var width = this.contentMask.width - (this.scrollbar.width + cuboro.PADDING * 2);
                    var cols = Math.floor(width / (itemSize + cuboro.PADDING));
                    this.items.forEach(function (value) {
                        if (col == cols) {
                            col = 0;
                            row++;
                        }
                        value.scaleXY = 1;
                        value.x = col * itemSize + col * cuboro.PADDING;
                        value.y = row * itemSize + row * cuboro.PADDING;
                        col++;
                    });
                    this.bounds.width = this.contentMask.width;
                    this.bounds.height = row * itemSize + row * cuboro.PADDING + itemSize;
                    this.scrollbar.update(this.content, this.contentMask, 0);
                    this.scrollbar.visible = this.scrollbar.sizeScroll > this.scrollbar.sizeVisible;
                };
                Gallery.prototype.getPage = function (filters, reset) {
                    var _this = this;
                    if (reset === void 0) { reset = true; }
                    this.galleryFilters = filters;
                    this.game.overlays.show(cuboro.overlays.Loader.NAME);
                    if (reset)
                        this.reset();
                    sGallery.getPage(this.galleryFilters, function (result, status) {
                        _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                        if (status == kr3m.SUCCESS) {
                            result.tracks.forEach(function (value) {
                                _this.addItem(value);
                            });
                            var countLeft = result.totalCount - result.usedFilters.offset - result.tracks.length;
                            _this.btLoadMore.isEnabled = countLeft > 0;
                            _this.tfTracks.visible = countLeft > 0;
                            _this.tfTracks.text = loc("gallery_tracks", { value: countLeft });
                            _this.arrange();
                        }
                        _this.emit("galleryLoaded");
                    });
                };
                Gallery.prototype.reset = function () {
                    this.content.y = this.contentMask.y;
                    this.scrollbar.updateToContentPosition();
                    this.content.removeChildren();
                    this.content.addChild(this.bounds);
                    this.items = [];
                };
                Gallery.prototype.updateSize = function (width, height) {
                    this.galleryHeight = height - this.btLoadMore.height - cuboro.PADDING * 4 - this.btBest.bottom;
                    _super.prototype.updateSize.call(this, width - this.scrollbar.width - cuboro.PADDING * 2, this.galleryHeight);
                    this.arrange();
                    this.onResize();
                };
                Gallery.prototype.onResize = function () {
                    _super.prototype.onResize.call(this);
                    if (this.tfTracks.visible) {
                        this.btLoadMore.x = (this.game.width - this.btLoadMore.width - this.tfTracks.width - cuboro.PADDING) >> 1;
                    }
                    else {
                        this.btLoadMore.x = (this.game.width - this.btLoadMore.width) >> 1;
                    }
                    this.btLoadMore.y = this.galleryHeight + this.btBest.bottom + cuboro.PADDING * 3;
                    this.tfTracks.x = this.btLoadMore.right + cuboro.PADDING;
                    this.tfTracks.y = this.btLoadMore.y + ((this.btLoadMore.height - this.tfTracks.height) >> 1);
                };
                return Gallery;
            }(cuboro.ui.tabs.Tab));
            tabs.Gallery = Gallery;
        })(tabs = ui.tabs || (ui.tabs = {}));
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var screens;
    (function (screens) {
        var Start = (function (_super) {
            __extends(Start, _super);
            function Start() {
                return _super !== null && _super.apply(this, arguments) || this;
            }
            Start.prototype.init = function () {
                _super.prototype.init.call(this);
                this.content = new gf.display.Container(this.game);
                this.content.y = this.game.stage.header.bg.height;
                this.content.interactive = true;
                this.addChild(this.content);
                this.logoBg = new gf.display.Sprite(this.game, PIXI.Texture.WHITE);
                this.logoBg.tint = cuboro.COLOR_YELLOW;
                this.content.addChild(this.logoBg);
                this.logo = new gf.display.Sprite(this.game, "logo");
                this.content.addChild(this.logo);
                this.tabContest = new cuboro.ui.tabs.Contest(this.game);
                this.tabCreate = new cuboro.ui.tabs.Create(this.game);
                this.tabGallery = new cuboro.ui.tabs.Gallery(this.game);
                this.tabs = new cuboro.ui.Tabs(this.game);
                this.tabs.y = this.logo.bottom;
                this.tabs.spacing = cuboro.PADDING * 2;
                this.tabs.add(this.tabGallery, loc("bt_gallery"));
                this.tabs.add(this.tabCreate, loc("bt_create_track"));
                this.tabs.add(this.tabContest, loc("bt_contest"));
                this.tabs.current = this.tabGallery;
                this.tabs.on(gf.CHANGE, this.onTab, this);
                this.content.addChild(this.tabs);
                this.language = new cuboro.ui.Language(this.game);
                this.addChild(this.language);
                this.logoBg.height = this.logo.height;
                mUser.on("loggedIn", this.getGallery, this);
            };
            Start.prototype.onTab = function (value) {
                if (value == this.tabGallery)
                    this.getGallery();
            };
            Start.prototype.getGallery = function () {
                var filters = new cuboro.vo.gallery.Filters();
                this.tabGallery.getPage(filters);
            };
            Start.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.logoBg.width = this.game.width;
                this.logo.x = gf.utils.Align.centerX(this.logo, this.game);
                this.language.x = this.game.width - this.language.width - cuboro.PADDING;
                this.language.y = this.game.height - this.game.stage.footer.bg.height - this.language.height - cuboro.PADDING;
                var h = this.game.height - this.tabs.y - this.tabs.tabButtons.height - this.game.stage.footer.height - this.game.stage.header.bg.height;
                this.tabs.maxWidth = this.game.width;
                this.tabs.updateSize(this.game.width, h);
            };
            Start.prototype.transitionIn = function () {
                _super.prototype.transitionIn.call(this);
                this.tabGallery.onFilter("rating", false, false, this.tabGallery.btBest);
                this.tabCreate.reset();
            };
            Start.NAME = "start";
            return Start;
        }(cuboro.screens.Screen));
        screens.Start = Start;
    })(screens = cuboro.screens || (cuboro.screens = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Footer = (function (_super) {
            __extends(Footer, _super);
            function Footer(game) {
                var _this = _super.call(this, game) || this;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.height = 20;
                _this.bg.tint = cuboro.COLOR_WHITE;
                _this.addChild(_this.bg);
                _this.btImprint = new cuboro.ui.TextLinkButton(_this.game, loc("bt_imprint"));
                _this.btImprint.x = cuboro.PADDING;
                _this.btImprint.y = cuboro.PADDING;
                _this.btImprint.on(gf.CLICK, _this.onImprint, _this);
                _this.addChild(_this.btImprint);
                var divider = new gf.display.Text(_this.game, "|", cuboro.TEXT_STYLE_VERSION.clone());
                divider.x = _this.btImprint.right + cuboro.PADDING;
                divider.y = cuboro.PADDING;
                _this.addChild(divider);
                _this.btContact = new cuboro.ui.TextLinkButton(_this.game, loc("bt_contact"));
                _this.btContact.x = divider.right + cuboro.PADDING;
                _this.btContact.y = cuboro.PADDING;
                _this.btContact.on(gf.CLICK, _this.onContact, _this);
                _this.addChild(_this.btContact);
                _this.tfVersion = new gf.display.Text(_this.game);
                _this.tfVersion.style = cuboro.TEXT_STYLE_VERSION.clone();
                _this.tfVersion.text = loc("say_hello", {
                    name: loc("app_title"),
                    version: cuboro.VERSION
                });
                _this.tfVersion.y = cuboro.PADDING;
                _this.addChild(_this.tfVersion);
                return _this;
            }
            Footer.prototype.onImprint = function () {
                track("Imprint");
                this.game.overlays.show(cuboro.overlays.Imprint.NAME);
            };
            Footer.prototype.onContact = function () {
                track("Contact");
                this.game.overlays.show(cuboro.overlays.Contact.NAME);
            };
            Footer.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.y = this.game.height - this.bg.height;
                this.bg.width = this.game.width;
                this.tfVersion.x = this.game.width - this.tfVersion.width - cuboro.PADDING;
            };
            return Footer;
        }(gf.display.Container));
        ui.Footer = Footer;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Pdf = (function (_super) {
            __extends(Pdf, _super);
            function Pdf() {
                var _this = _super.call(this) || this;
                _this.htmlEscapeStrings = false;
                return _this;
            }
            Pdf.prototype.printPdf = function (trackId, screenshot, callback) {
                var params = { trackId: trackId, screenshot: screenshot };
                this.callService("Pdf.printPdf", params, callback);
            };
            return Pdf;
        }(stubs.Abstract));
        stubs.Pdf = Pdf;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sPdf = new cuboro.stubs.Pdf();
var cuboro;
(function (cuboro) {
    var clientmodels;
    (function (clientmodels) {
        var Pdf = (function (_super) {
            __extends(Pdf, _super);
            function Pdf() {
                return _super.call(this) || this;
            }
            Pdf.prototype.printPdf = function (trackId, screenshot) {
                sPdf.printPdf(trackId, screenshot, function (url) {
                    console.log(" URL ", url);
                    open(url, '_blank');
                });
            };
            return Pdf;
        }(kr3m.model.EventDispatcher));
        clientmodels.Pdf = Pdf;
    })(clientmodels = cuboro.clientmodels || (cuboro.clientmodels = {}));
})(cuboro || (cuboro = {}));
var mPdf = new cuboro.clientmodels.Pdf();
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var TrackMenu = (function (_super) {
            __extends(TrackMenu, _super);
            function TrackMenu(game) {
                var _this = _super.call(this, game) || this;
                _this.interactive = true;
                _this.trackNameBg = new gf.display.Slice3(_this.game, 10, 10, "sprites", "bg_dropdown");
                _this.trackNameBg.width = 180;
                _this.trackNameBg.x = cuboro.PADDING;
                _this.trackNameBg.y = 21;
                _this.addChild(_this.trackNameBg);
                _this.form = new gf.input.Form(_this.game, "login");
                _this.addChild(_this.form);
                _this.trackName = new gf.input.TextInput(_this.game, _this.form, "trackName");
                _this.trackName.x = _this.trackNameBg.x + cuboro.PADDING;
                _this.trackName.y = 22;
                _this.trackName.width = _this.trackNameBg.width - cuboro.PADDING * 2;
                _this.trackName.value = loc("unnamed_track");
                _this.trackName.fontFamily = cuboro.DEFAULT_FONT_HEAVY;
                _this.trackName.fontSize = 20;
                _this.trackName.inputDom.style.textOverflow = "ellipsis";
                _this.trackName.maxLength = 30;
                _this.trackName.on(gf.FOCUS, _this.onTrackNameFocus, _this);
                _this.trackName.on(gf.BLUR, _this.onTrackNameChange, _this);
                _this.addChild(_this.trackName);
                var styles = { bold: cuboro.TEXT_STYLE_DEFAULT_HEAVY.clone() };
                _this.tfUsed = new gf.display.MultiStyleText(_this.game, loc("cubes_used", {
                    total: 0,
                    used: 0
                }), cuboro.TEXT_STYLE_DEFAULT.clone(), styles);
                _this.tfUsed.x = _this.trackName.x;
                _this.tfUsed.y = _this.trackNameBg.bottom + cuboro.PADDING;
                _this.addChild(_this.tfUsed);
                _this.btDetails = new cuboro.ui.IconButton(_this.game, "details", loc("bt_track_details"));
                _this.btDetails.on(gf.CLICK, _this.onDetails, _this);
                _this.btDetails.y = cuboro.PADDING;
                _this.addChild(_this.btDetails);
                _this.btPrint = new cuboro.ui.IconButton(_this.game, "print", loc("bt_print"));
                _this.btPrint.on(gf.CLICK, _this.onPrint, _this);
                _this.btPrint.y = cuboro.PADDING;
                _this.addChild(_this.btPrint);
                _this.btPublish = new cuboro.ui.IconButton(_this.game, "publish", loc("bt_publish"));
                _this.btPublish.on(gf.CLICK, _this.onPublish, _this);
                _this.btPublish.y = cuboro.PADDING;
                _this.addChild(_this.btPublish);
                _this.tfSaved = new gf.display.Text(_this.game, "", cuboro.TEXT_STYLE_BUTTON_ICON.clone());
                _this.tfSaved.style.align = gf.LEFT;
                _this.addChild(_this.tfSaved);
                return _this;
            }
            TrackMenu.prototype.trackNameValidation = function () {
                var valid = false;
                if (this.trackName.value.length >= 3) {
                    valid = true;
                }
                else {
                    var message = this.game.overlays.show(cuboro.overlays.Message.NAME);
                    message.text = loc("error_input_track_name");
                    this.trackName.value = this.lastName;
                }
                return valid;
            };
            TrackMenu.prototype.onDetails = function () {
                this.game.overlays.show(cuboro.overlays.TrackDetailsIngame.NAME);
            };
            TrackMenu.prototype.onPrint = function () {
                cuboro.ui.TrackPreview.GetBase64(this.game.screens.current.playground, 600, function (value) {
                    mPdf.printPdf(mTrack.id, value);
                });
            };
            TrackMenu.prototype.onPublish = function () {
                this.game.overlays.show(cuboro.overlays.Publish.NAME);
            };
            TrackMenu.prototype.onTrackNameChange = function () {
                if (this.trackNameValidation()) {
                    mTrack.name = this.trackName.value;
                    var gameScreen = this.game.screens.current;
                    gameScreen.playground.save();
                }
            };
            TrackMenu.prototype.onTrackNameFocus = function () {
                if (this.trackName.value.length >= 3)
                    this.lastName = this.trackName.value;
            };
            TrackMenu.prototype.updateCubesUsed = function (total, used) {
                this.tfUsed.text = loc("cubes_used", { total: total, used: used });
            };
            TrackMenu.prototype.checkPublish = function () {
                var _this = this;
                this.btPublish.isEnabled = false;
                if (!mUser.isLoggedIn())
                    return;
                if (mTrack.data.evaluation.scoreTotal == 0)
                    return;
                sTrack.isPublished(mTrack.id, function (response) {
                    if (!response)
                        _this.btPublish.isEnabled = true;
                });
            };
            TrackMenu.prototype.show = function () {
                this.visible = true;
                this.form.showDom();
            };
            TrackMenu.prototype.hide = function () {
                this.visible = false;
                this.form.hideDom();
            };
            TrackMenu.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                if (!this.game.stage.header)
                    return;
                this.btDetails.x = this.trackNameBg.right + cuboro.PADDING * 2;
                this.btPrint.x = this.btDetails.right + cuboro.PADDING;
                this.btPublish.x = this.btPrint.right + cuboro.PADDING;
                this.tfSaved.x = this.btPublish.right + cuboro.PADDING * 2;
                this.tfSaved.style.wordWrap = true;
                var wordWrapWidth = this.game.stage.header.btAccount.x - cuboro.PADDING * 2 - this.tfSaved.x;
                this.tfSaved.style.wordWrapWidth = Math.max(100, wordWrapWidth);
                this.tfSaved.y = this.btPublish.y + ((this.btPublish.height - this.tfSaved.height) >> 1);
            };
            return TrackMenu;
        }(gf.display.Container));
        ui.TrackMenu = TrackMenu;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Header = (function (_super) {
            __extends(Header, _super);
            function Header(game) {
                var _this = _super.call(this, game) || this;
                _this.interactive = true;
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.height = 75;
                _this.bg.tint = cuboro.COLOR_LIGHT_GREY;
                _this.addChild(_this.bg);
                _this.btAccount = new cuboro.ui.IconButton(_this.game, "account", loc("bt_account"));
                _this.btAccount.tfLabel.style.wordWrap = true;
                _this.btAccount.tfLabel.style.breakWords = true;
                _this.btAccount.tfLabel.style.wordWrapWidth = _this.btAccount.width;
                _this.btAccount.on(gf.CLICK, _this.onAccount, _this);
                _this.btAccount.y = cuboro.PADDING;
                _this.btAccount.visible = false;
                _this.addChild(_this.btAccount);
                _this.accountMenu = new cuboro.ui.AccountMenu(_this.game);
                _this.accountMenu.y = _this.bg.bottom;
                _this.accountMenu.visible = false;
                _this.addChild(_this.accountMenu);
                _this.btMenu = new cuboro.ui.IconButton(_this.game, "menu", loc("bt_menu"));
                _this.btMenu.on(gf.CLICK, _this.onMenu, _this);
                _this.btMenu.y = cuboro.PADDING;
                _this.addChild(_this.btMenu);
                _this.topMenu = new cuboro.ui.TopMenu(_this.game);
                _this.topMenu.y = _this.bg.bottom;
                _this.topMenu.visible = false;
                _this.addChild(_this.topMenu);
                _this.btLogin = new cuboro.ui.IconButton(_this.game, "login", loc("bt_login"));
                _this.btLogin.on(gf.CLICK, _this.onLogin, _this);
                _this.btLogin.y = cuboro.PADDING;
                _this.addChild(_this.btLogin);
                _this.trackMenu = new cuboro.ui.TrackMenu(_this.game);
                _this.trackMenu.hide();
                _this.addChild(_this.trackMenu);
                mUser.on("loggedIn", _this.onUserStatus, _this);
                mUser.on("logout", _this.onUserStatus, _this);
                _this.getUsername();
                return _this;
            }
            Header.prototype.onUserStatus = function () {
                this.btLogin.visible = !mUser.isLoggedIn();
                this.btAccount.visible = mUser.isLoggedIn();
                if (mUser.isLoggedIn()) {
                    if (!mTrack.owner)
                        mTrack.owner = mUser.getUser();
                }
                this.getUsername();
            };
            Header.prototype.getUsername = function () {
                var _this = this;
                if (!mUser.isLoggedIn())
                    return;
                casClient.getUserAccount(function (account) {
                    _this.btAccount.label = account.user.name;
                });
            };
            Header.prototype.onLogin = function () {
                this.game.overlays.show(cuboro.overlays.Login.NAME);
            };
            Header.prototype.onAccount = function () {
                if (this.accountMenu.visible)
                    this.accountMenu.hide();
                else
                    this.accountMenu.show();
                this.btAccount.isSelected = this.accountMenu.visible;
            };
            Header.prototype.onMenu = function () {
                if (this.topMenu.visible)
                    this.topMenu.hide();
                else
                    this.topMenu.show();
                this.btMenu.isSelected = this.topMenu.visible;
            };
            Header.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.bg.width = this.game.width;
                this.btMenu.x = this.game.width - this.btMenu.width - cuboro.PADDING;
                this.topMenu.x = this.btMenu.x - cuboro.PADDING;
                this.btLogin.x =
                    this.btAccount.x = this.btMenu.x - this.btAccount.width - cuboro.PADDING;
                this.accountMenu.x = this.btAccount.x - cuboro.PADDING;
                this.trackMenu.onResize();
            };
            Header.prototype.hide = function () {
                if (this.trackMenu.visible) {
                    this.trackMenu.form.hideDom();
                }
                this.visible = false;
            };
            Header.prototype.show = function () {
                if (this.trackMenu.visible) {
                    this.trackMenu.form.showDom();
                }
                this.visible = true;
            };
            return Header;
        }(gf.display.Container));
        ui.Header = Header;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var Config = (function (_super) {
        __extends(Config, _super);
        function Config() {
            var _this = _super !== null && _super.apply(this, arguments) || this;
            _this.FooterClass = cuboro.ui.Footer;
            _this.HeaderClass = cuboro.ui.Header;
            _this.canvasDomId = "game";
            _this.cheat = false;
            _this.hasEndless = false;
            _this.hasInbox = false;
            _this.hasLives = false;
            _this.hasLogin = false;
            _this.lowQuality = false;
            _this.muteFxDefault = true;
            _this.muteMusicDefault = true;
            _this.roundPixels = true;
            _this.useAntiAlias = true;
            _this.useCAS = false;
            _this.overlays = [
                cuboro.overlays.Account,
                cuboro.overlays.AddSets,
                cuboro.overlays.ChangePassword,
                cuboro.overlays.Contact,
                cuboro.overlays.FinishRegister,
                cuboro.overlays.ForgotPassword,
                cuboro.overlays.Imprint,
                cuboro.overlays.Loader,
                cuboro.overlays.Login,
                cuboro.overlays.LowQuality,
                cuboro.overlays.Message,
                cuboro.overlays.NewComment,
                cuboro.overlays.Publish,
                cuboro.overlays.Register,
                cuboro.overlays.TrackDetails,
                cuboro.overlays.TrackDetailsIngame
            ];
            _this.screens = [
                cuboro.screens.Game,
                cuboro.screens.Start
            ];
            return _this;
        }
        Config.prototype.addAssets = function (client) {
            client.game.loader.json("language", "js/data/lang_" + this.language + ".json");
            client.game.loader.json("sets", "js/data/sets.json");
            client.game.loader.atlas("sprites", "img/sprites.png", "js/data/sprites.json");
            client.game.loader.atlas("sprites-sets", "img/sprites-sets.png", "js/data/sprites-sets.json");
            client.game.loader.woff("avenir", "fonts/avenir-book-webfont.woff");
            client.game.loader.woff("avenir-heavy", "fonts/avenir-heavy-webfont.woff");
            client.game.loader.image("logo", "img/logo.png");
            client.game.loader.image("icon_new_track", "img/icon_new_track.png");
            client.game.loader.image("icon_contest", "img/icon_contest.png");
        };
        Config.prototype.onRun = function (game) {
        };
        return Config;
    }(gf.core.Config));
    cuboro.Config = Config;
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    cuboro.VERSION = "0.83.0.0";
    cuboro.DB_VERSION = "0.80.0.108";
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    cuboro.DEFAULT_FONT = "avenir";
    cuboro.DEFAULT_FONT_HEAVY = "avenir-heavy";
    cuboro.COLOR_YELLOW = 0xfecc00;
    cuboro.COLOR_GREEN = 0x00aa00;
    cuboro.COLOR_DARK_GREY = 0x1d1d1b;
    cuboro.COLOR_GREY = 0xaaaaaa;
    cuboro.COLOR_MID_GREY = 0xcdcdcd;
    cuboro.COLOR_LIGHT_GREY = 0xf0f0f0;
    cuboro.COLOR_RED = 0xcc0000;
    cuboro.COLOR_WHITE = 0xffffff;
    cuboro.COLOR_FB_BLUE = 0x3b5998;
    cuboro.CAMERA_UPDATE = "cameraUpdate";
    cuboro.CAMERA_UPDATED = "cameraUpdated";
    cuboro.CUBE_UPDATE = "cubeUpdate";
    cuboro.CUBE_SELECTED = "cubeSelected";
    cuboro.CUBE_DESELECTED = "cubeDeselected";
    cuboro.PLAYGROUND_READY = "playgroundReady";
    cuboro.DEG_RAD_90 = 1.5707963268;
    cuboro.EMPTY = "0";
    cuboro.PADDING = 5;
    cuboro.LEFT_MENU_CHANGE = "leftMenuChange";
    cuboro.RIGHT_MENU_CHANGE = "rightMenuChange";
    cuboro.MARBLE_SKIP_THRESHOLD = 0.3;
    cuboro.MARBLE_DEATH_SLOW_FACTOR = 0.99;
    cuboro.MARBLE_DROP_HEIGHT_DEFAULT = "LOW";
    cuboro.MARBLE_DROP_HEIGHTS = {
        LOW: -0.75,
        MEDIUM: -0.5,
        HIGH: 0
    };
    cuboro.HISTORY = {
        CURRENT: "current",
        PREDECESSOR: "predecessor",
        SUCCESSOR: "successor"
    };
    cuboro.MAX_X = 12;
    cuboro.MAX_Y = 9;
    cuboro.MAX_Z = 12;
    cuboro.SETS = {
        BASIC: "basic",
        BUILD: "build",
        DUO: "duo",
        PROFI: "profi",
        METRO: "metro",
        PLUS: "plus",
        MULTI: "multi",
        SIXPACK_DUO: "sixpack_duo",
        SIXPACK_PROFI: "sixpack_profi",
        SIXPACK_METRO: "sixpack_metro",
        SIXPACK_PLUS: "sixpack_plus",
        SIXPACK_MULTI: "sixpack_multi",
        STANDARD: "standard"
    };
    cuboro.START_CUBES = ["cube_11", "cube_12", "cube_21", "cube_22", "cube_31", "cube_41", "cube_42", "cube_51", "cube_61", "cube_71", "cube_92"];
    cuboro.SWAP = "swap";
    cuboro.TIMESTEP = 1 / 120;
    cuboro.TEXT_STYLE_BUTTON_CHECKBOX = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 11,
        lineHeight: 12,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_BUTTON_ICON = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 11,
        align: gf.CENTER,
        lineHeight: 11,
        wordWrap: true,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_BUTTON_CUBE = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 13,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_BUTTON_TEXT = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 13,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_BUTTON_FOOTER = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 10,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_BUTTON_TAB = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 20,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_BUTTON_TAB_SELECTED = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT_HEAVY,
        fontSize: 20,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_INPUT_ERROR = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 10,
        fill: cuboro.COLOR_RED,
        wordWrap: true
    });
    cuboro.TEXT_STYLE_INPUT_SUCCESS = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 10,
        fill: cuboro.COLOR_GREEN,
        wordWrap: true
    });
    cuboro.TEXT_STYLE_LAYER = new PIXI.TextStyle({
        align: gf.CENTER,
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 96,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_LOADER = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 18,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_SMALL = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 13,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_SMALL_HEAVY = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT_HEAVY,
        fontSize: 13,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_TITLE = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 42,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_TITLE_RIGHT_MENU_TAB = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 42,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_TITLE_HINT = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 20,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_TITLE_TAB = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT_HEAVY,
        fontSize: 20,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_DEFAULT = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 15,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_DEFAULT_HEAVY = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT_HEAVY,
        fontSize: 15,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.TEXT_STYLE_PACKSHOT = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT_HEAVY,
        fontSize: 15,
        fill: cuboro.COLOR_DARK_GREY,
        lineHeight: 14
    });
    cuboro.TEXT_STYLE_VERSION = new PIXI.TextStyle({
        fontFamily: cuboro.DEFAULT_FONT,
        fontSize: 10,
        fill: cuboro.COLOR_DARK_GREY
    });
    cuboro.RATING_VALUES = [1, 2, 3, 4, 5];
    cuboro.RATING_THRESHOLD = 10;
    cuboro.ERROR_IS_NOT_TRACK_OWNER = "ERROR_IS_NOT_TRACK_OWNER";
    cuboro.ERROR_TRACK_IS_PUBLISHED = "ERROR_TRACK_IS_PUBLISHED";
    cuboro.ERROR_TRACK_NAME_NOT_OVERWRITTEN = "ERROR_TRACK_NAME_NOT_OVERWRITTEN";
    cuboro.ERROR_CANT_RATE_OWN_TRACKS = "ERROR_CANT_RATE_OWN_TRACKS";
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var core;
    (function (core) {
        var Loader = (function () {
            function Loader() {
            }
            Loader.loadTrack = function (game, track, forceDuplicate) {
                mTrack = track;
                if (forceDuplicate) {
                    track.owner = mUser.getUser();
                    sTrack.generateUniqueRandomName(loc("trackname_prefix"), function (response) {
                        mTrack.name = response;
                        game.stage.header.trackMenu.trackName.value = mTrack.name;
                    });
                }
                else {
                    game.stage.header.trackMenu.trackName.value = mTrack.name;
                }
                if (game.screens.currentName != cuboro.screens.Game.NAME) {
                    var gameScreen_1 = game.screens.show(cuboro.screens.Game.NAME);
                    gameScreen_1.on(gf.TRANSITION_IN_COMPLETE, function () {
                        gameScreen_1.playground.on(cuboro.PLAYGROUND_READY, function () {
                            gameScreen_1.layers.update();
                        });
                        gameScreen_1.playground.reset();
                        gameScreen_1.bottomMenu.start();
                        gameScreen_1.playground.start();
                    });
                }
                else {
                    var gameScreen_2 = game.screens.current;
                    gameScreen_2.playground.stop();
                    gameScreen_2.playground.on(cuboro.PLAYGROUND_READY, function () {
                        gameScreen_2.layers.update();
                    });
                    gameScreen_2.playground.reset();
                    gameScreen_2.bottomMenu.start();
                    gameScreen_2.playground.start();
                }
            };
            return Loader;
        }());
        core.Loader = Loader;
    })(core = cuboro.core || (cuboro.core = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var vo;
    (function (vo) {
        var Competition = (function () {
            function Competition() {
            }
            return Competition;
        }());
        vo.Competition = Competition;
    })(vo = cuboro.vo || (cuboro.vo = {}));
})(cuboro || (cuboro = {}));
var cuboro;
(function (cuboro) {
    var stubs;
    (function (stubs) {
        var Competition = (function (_super) {
            __extends(Competition, _super);
            function Competition() {
                var _this = _super.call(this) || this;
                _this.htmlEscapeStrings = false;
                return _this;
            }
            Competition.prototype.getCurrentlyActive = function (callback) {
                var params = {};
                this.callService("Competition.getCurrentlyActive", params, function (response) { return callback(response.data, response.status); });
            };
            return Competition;
        }(stubs.Abstract));
        stubs.Competition = Competition;
    })(stubs = cuboro.stubs || (cuboro.stubs = {}));
})(cuboro || (cuboro = {}));
var sCompetition = new cuboro.stubs.Competition();
var cuboro;
(function (cuboro) {
    var ui;
    (function (ui) {
        var Hint = (function (_super) {
            __extends(Hint, _super);
            function Hint(game) {
                var _this = _super.call(this, game) || this;
                _this.border = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.border.tint = cuboro.COLOR_GREY;
                _this.border.x = -1;
                _this.border.y = -1;
                _this.border.width = 402;
                _this.border.height = 52;
                _this.addChild(_this.border);
                _this.bg = new gf.display.Sprite(_this.game, PIXI.Texture.WHITE);
                _this.bg.width = 400;
                _this.bg.height = 50;
                _this.addChild(_this.bg);
                _this.queue = [];
                _this.addCloseButton();
                _this.addTextFields();
                _this.visible = false;
                return _this;
            }
            Hint.prototype.addTextFields = function () {
                this.tfTitle = new gf.display.Text(this.game, "", cuboro.TEXT_STYLE_TITLE_TAB.clone());
                this.tfTitle.style.wordWrap = true;
                this.tfTitle.style.wordWrapWidth = this.btClose.x - cuboro.PADDING * 2;
                this.tfTitle.x = cuboro.PADDING;
                this.tfTitle.y = cuboro.PADDING * 2;
                this.addChild(this.tfTitle);
                this.tfMessage = new gf.display.Text(this.game, "", cuboro.TEXT_STYLE_SMALL.clone());
                this.tfMessage.style.wordWrap = true;
                this.tfMessage.style.wordWrapWidth = this.btClose.x - cuboro.PADDING * 2;
                this.tfMessage.x = cuboro.PADDING;
                this.tfMessage.y = this.tfTitle.bottom + cuboro.PADDING;
                this.addChild(this.tfMessage);
            };
            Hint.prototype.addCloseButton = function () {
                this.btClose = new cuboro.ui.CloseButton(this.game);
                this.btClose.on(gf.CLICK, this.hide, this);
                this.btClose.x = this.bg.right - this.btClose.width - cuboro.PADDING * 2;
                this.btClose.y = cuboro.PADDING * 2 + 2;
                this.addChild(this.btClose);
            };
            Hint.prototype.show = function (title, message) {
                if (this.visible) {
                    this.queue.push({ title: title, message: message });
                }
                else {
                    this.tfTitle.text = title;
                    this.tfMessage.text = message;
                    this.tfMessage.y = this.tfTitle.bottom + cuboro.PADDING;
                    this.bg.height = this.tfMessage.bottom + cuboro.PADDING * 4;
                    this.border.height = this.bg.height + 2;
                    this.x = (this.game.width - this.bg.width) >> 1;
                    this.y = this.game.height;
                    TweenMax.to(this, 0.25, { y: this.game.height - this.bg.height + cuboro.PADDING * 2, ease: Back.easeOut });
                    this.visible = true;
                }
            };
            Hint.prototype.hide = function () {
                var _this = this;
                TweenMax.to(this, 0.25, {
                    y: this.game.height, ease: Back.easeIn, onComplete: function () {
                        _this.visible = false;
                        if (_this.queue.length > 0) {
                            var item = _this.queue.shift();
                            _this.show(item.title, item.message);
                        }
                    }
                });
            };
            Hint.prototype.onResize = function () {
                _super.prototype.onResize.call(this);
                this.x = (this.game.width - this.bg.width) >> 1;
                this.y = this.game.height - this.bg.height + cuboro.PADDING * 2;
            };
            return Hint;
        }(gf.display.Container));
        ui.Hint = Hint;
    })(ui = cuboro.ui || (cuboro.ui = {}));
})(cuboro || (cuboro = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var Keyboard = (function () {
            function Keyboard() {
                gf.utils.Keyboard.instance = this;
            }
            Keyboard.init = function () {
                var _this = this;
                this.keys = [];
                try {
                    top.addEventListener("keydown", function (e) {
                        _this.onKey(e);
                    }, true);
                    if (window != top) {
                        window.addEventListener("keydown", function (e) {
                            _this.onKey(e);
                        }, true);
                    }
                }
                catch (e) {
                    window.addEventListener("keydown", function (e) {
                        _this.onKey(e);
                    }, true);
                }
            };
            Keyboard.addKey = function (key, callback) {
                if (!this.keys[key]) {
                    this.keys[key] = [];
                }
                this.keys[key].push(callback);
            };
            Keyboard.removeKey = function (key, callback) {
                if (!this.keys[key]) {
                    return;
                }
                this.keys[key].splice(this.keys[key].indexOf(callback), 1);
            };
            Keyboard.onKey = function (e) {
                var key = e.which;
                if (this.keys[key] && this.keys[key].length > 0) {
                    for (var i = 0; i < this.keys[key].length; ++i) {
                        this.keys[key][i](e);
                    }
                }
            };
            Keyboard.getInstance = function () {
                var self = gf.utils.Keyboard;
                if (typeof self.instance == "undefined") {
                    self.instance = new gf.utils.Keyboard();
                    this.init();
                }
                return self.instance;
            };
            Keyboard.add = function (callback, key) {
                var _this = this;
                if (!this.instance)
                    this.getInstance();
                if (!this.callbacks)
                    this.callbacks = {};
                var callbackId;
                if (typeof key == "number") {
                    callbackId = PIXI.utils.uid();
                    this.callbacks[callbackId] = { callback: callback, key: key };
                    this.addKey(key, callback);
                    return callbackId;
                }
                var callbackIds = [];
                key.forEach(function (value) {
                    callbackId = PIXI.utils.uid();
                    _this.callbacks[callbackId] = { callback: callback, key: value };
                    _this.addKey(value, callback);
                    callbackIds.push(callbackId);
                });
                return callbackIds;
            };
            Keyboard.remove = function (callbackId) {
                var _this = this;
                if (!this.instance)
                    this.getInstance();
                if (typeof callbackId == "number") {
                    this.removeKey(this.callbacks[callbackId].key, this.callbacks[callbackId].callback);
                    this.callbacks[callbackId] = null;
                }
                else {
                    callbackId.forEach(function (value) {
                        _this.removeKey(_this.callbacks[value].key, _this.callbacks[value].callback);
                        _this.callbacks[value] = null;
                    });
                }
            };
            return Keyboard;
        }());
        utils.Keyboard = Keyboard;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        utils.LEFT = 37;
        utils.UP = 38;
        utils.RIGHT = 39;
        utils.DOWN = 40;
        var Debug = (function () {
            function Debug() {
            }
            Debug.add = function (display) {
                var _this = this;
                if (!display["data"])
                    display["data"] = {};
                display["data"].buttonMode = display.buttonMode;
                display["data"].interactive = display.interactive;
                display["data"].interactiveChildren = display.interactiveChildren;
                display.buttonMode = true;
                display.interactive = true;
                display.interactiveChildren = true;
                display["data"].downListener = function (e) {
                    logDebug(display);
                    if (_this._currentDisplay) {
                        _this.removeMovement(_this._currentDisplay);
                    }
                    _this._currentDisplay = e.target;
                    _this.addMovement(display);
                    _this.onDown(e);
                };
                display["data"].upListener = function (e) {
                    _this.onUp(e);
                };
                display.on("mousedown touchstart", display["data"].downListener);
                display.on("mouseup mouseupoutside touchend touchendoutside", display["data"].upListener);
                var bounds = display.getLocalBounds();
                var debug = new gf.display.Graphics(display.game);
                debug.lineStyle(2, 0xff00ff, 0.5);
                debug.f(0xff00ff, 0).dr(bounds.x, bounds.y, bounds.width, bounds.height).ef();
                display.addChild(debug);
                display["data"].debug = debug;
            };
            Debug.remove = function (display) {
                if (!display["data"] || !display["data"].debug)
                    return;
                display.removeChild(display["data"].debug);
                display.buttonMode = display["data"].buttonMode;
                display.interactive = display["data"].interactive;
                display.interactiveChildren = display["data"].interactiveChildren;
                this.removeMovement(display);
                display.off("mousedown touchstart", display["data"].downListener);
                display.off("mouseup mouseupoutside touchend touchendoutside", display["data"].upListener);
            };
            Debug.addMovement = function (display) {
                display["data"].movementLeft = function () {
                    display.x -= 1;
                    logDebug(display.x + ", " + display.y, display);
                };
                display["data"].movementRight = function () {
                    display.x += 1;
                    logDebug(display.x + ", " + display.y, display);
                };
                display["data"].movementUp = function () {
                    display.y -= 1;
                    logDebug(display.x + ", " + display.y, display);
                };
                display["data"].movementDown = function () {
                    display.y += 1;
                    logDebug(display.x + ", " + display.y, display);
                };
                display["data"].leftId = gf.utils.Keyboard.add(function () { return display["data"].movementLeft(); }, gf.utils.LEFT);
                display["data"].rightId = gf.utils.Keyboard.add(function () { return display["data"].movementRight(); }, gf.utils.RIGHT);
                display["data"].upId = gf.utils.Keyboard.add(function () { return display["data"].movementUp(); }, gf.utils.UP);
                display["data"].downId = gf.utils.Keyboard.add(function () { return display["data"].movementDown(); }, gf.utils.DOWN);
            };
            Debug.removeMovement = function (display) {
                gf.utils.Keyboard.remove([display["data"].leftId, display["data"].rightId, display["data"].upId, display["data"].downId]);
            };
            Debug.onDown = function (e) {
                this.onDragStart(e);
            };
            Debug.onMove = function (e) {
                var display = e.target;
                if (!display)
                    return;
                if (display["data"] && display["data"].isDragging) {
                    this.onDragMove(e);
                }
                else {
                    this.onDragStart(e);
                }
            };
            Debug.onUp = function (e) {
                var display = e.target;
                if (display["data"].isDragging) {
                    this.onDragStop(e);
                    display.removeListener("mousemove", display["data"].moveListener);
                    display.removeListener("touchmove", display["data"].moveListener);
                }
            };
            Debug.onDragStart = function (e) {
                var _this = this;
                var display = e.target;
                display["data"].isDragging = true;
                display["data"].dragData = e.data;
                display["data"].dragStart = display["data"].dragData.getLocalPosition(display).clone();
                display["data"].moveListener = function (e) {
                    _this.onMove(e);
                };
                display.on("mousemove touchmove", display["data"].moveListener);
            };
            Debug.onDragMove = function (e) {
                var display = e.target;
                if (display["data"].isDragging) {
                    var position = e.data.getLocalPosition(display.parent);
                    display.x = Math.round(position.x - display["data"].dragStart.x);
                    display.y = Math.round(position.y - display["data"].dragStart.y);
                }
            };
            Debug.onDragStop = function (e) {
                var display = e.target;
                display["data"].isDragging = false;
                logDebug(display.x + ", " + display.y, display);
            };
            Debug.domLog = function () {
                var args = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    args[_i] = arguments[_i];
                }
                if (!this._dom) {
                    this._dom = document.createElement("div");
                    this._dom.style.cssText = "position:fixed;display:block;top:0;left:0;height:200px;overflow:auto;cursor:pointer;opacity:0.9;z-index:10000;background-color:#fff;color:#000;font-size:10px;padding:2px;";
                    document.body.appendChild(this._dom);
                }
                this._dom.innerHTML += (this._dom.innerText.length != 0 ? "<br>" : "") + args.join(",");
                this._dom.scrollTop = this._dom.scrollHeight;
            };
            return Debug;
        }());
        utils.Debug = Debug;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var gf;
(function (gf) {
    var utils;
    (function (utils) {
        var FPS = (function () {
            function FPS() {
            }
            FPS.update = function () {
                this._frames++;
                var time = (performance || Date).now();
                if (time > this._prevTime + 1000) {
                    this._fps = (this._frames * 1000) / (time - this._prevTime);
                    this._prevTime = time;
                    this._frames = 0;
                    this._total.push(this._fps);
                    if (this._total.length > 60)
                        this._total = [this.average];
                    if (this._dom)
                        this._dom.innerText = "FPS: " + Math.round(this._fps) + " (∅ " + Math.round(this.average) + ")";
                }
            };
            FPS.reset = function () {
                this._frames = 0;
                this._prevTime = (performance || Date).now();
                this._total = [];
            };
            FPS.add = function (game) {
                if (this._isAdded)
                    return;
                this._isAdded = true;
                this.reset();
                game.ticker.add(this.update, this);
                game.on(gf.FOCUS, this.reset, this);
            };
            FPS.remove = function (game) {
                this._isAdded = false;
                game.ticker.remove(this.update, this);
                game.off(gf.FOCUS, this.reset, this);
            };
            FPS.addToDom = function (game) {
                if (!this._isAdded)
                    this.add(game);
                this._dom = document.createElement("div");
                this._dom.style.cssText = "position:fixed;display:block;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000;background-color:#fff;color:#000;font-size:10px;padding:2px;";
                document.body.appendChild(this._dom);
            };
            Object.defineProperty(FPS, "fps", {
                get: function () {
                    return this._fps;
                },
                enumerable: true,
                configurable: true
            });
            Object.defineProperty(FPS, "average", {
                get: function () {
                    return this._total.reduce(function (a, b) { return a + b; }, 0) / this._total.length;
                },
                enumerable: true,
                configurable: true
            });
            FPS.removeFromDOM = function (game) {
                if (this._isAdded) {
                    this.remove(game);
                    document.body.removeChild(this._dom);
                }
            };
            return FPS;
        }());
        utils.FPS = FPS;
    })(utils = gf.utils || (gf.utils = {}));
})(gf || (gf = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Tokenizer = (function () {
            function Tokenizer() {
            }
            Tokenizer.setFormatter = function (name, formatter) {
                Tokenizer.formatters[name] = formatter;
            };
            Tokenizer.setToken = function (name, value) {
                Tokenizer.globalTokens[name] = value;
            };
            Tokenizer.mergeTokens = function (tokensArray) {
                var result = {};
                for (var i in tokensArray) {
                    for (var j in tokensArray[i]) {
                        if (typeof tokensArray[i][j] != "function") {
                            var key = i + "_" + j;
                            key = key.replace(/\W/g, "");
                            key = key.replace(/([a-z])([A-Z])/g, "$1_$2");
                            key = key.replace(/__+/g, "_");
                            key = key.toUpperCase();
                            result[key] = tokensArray[i][j];
                        }
                    }
                }
                return result;
            };
            Tokenizer.get = function (text, tokens, seperator) {
                if (seperator === void 0) { seperator = "##"; }
                tokens = util.Util.mergeAssoc(Tokenizer.globalTokens, tokens);
                var parts = text.split(seperator);
                for (var i = 1; i < parts.length; i += 2) {
                    var tokenParts = parts[i].split(":");
                    if (tokenParts.length < 1)
                        continue;
                    var value = util.Util.getProperty(tokens, tokenParts[0]);
                    if (tokenParts.length > 1) {
                        var formatter = Tokenizer.formatters[tokenParts[1]];
                        if (formatter) {
                            try {
                                value = formatter(value, tokens, tokenParts[0]);
                            }
                            catch (e) {
                                util.Log.logError(e);
                            }
                        }
                        else {
                            util.Log.logWarning("unknown token-formatter:", tokenParts[1]);
                        }
                    }
                    parts[i] = (value !== null) ? value : seperator + parts[i] + seperator;
                }
                return parts.join("");
            };
            Tokenizer.revertValues = function (templateText, tokenizedText, seperator) {
                if (seperator === void 0) { seperator = "##"; }
                var result = {};
                var parts = templateText.split(seperator);
                if (parts.length == 1)
                    return {};
                var startPos = tokenizedText.indexOf(parts[0], startPos);
                if (startPos < 0)
                    return null;
                var endPos = 0;
                for (var i = 0; i < parts.length - 1; i += 2) {
                    startPos += parts[i].length;
                    endPos = (parts[i + 2] != "") ? tokenizedText.indexOf(parts[i + 2], startPos) : tokenizedText.length;
                    if (endPos < 0)
                        return null;
                    result[parts[i + 1]] = tokenizedText.substring(startPos, endPos);
                    startPos = endPos;
                }
                return result;
            };
            Tokenizer.globalTokens = {};
            Tokenizer.formatters = {};
            return Tokenizer;
        }());
        util.Tokenizer = Tokenizer;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
function tokenize(text, tokens, seperator) {
    if (seperator === void 0) { seperator = "##"; }
    return kr3m.util.Tokenizer.get(text, tokens, seperator);
}
function setToken(name, value) {
    kr3m.util.Tokenizer.setToken(name, value);
}
var kr3m;
(function (kr3m) {
    var async;
    (function (async) {
        var Join = (function () {
            function Join() {
                this.counter = 0;
                this.callbacks = [];
                this.results = {};
            }
            Join.prototype.getResult = function (resultName) {
                var results = this.results[resultName];
                if (results && results.length > 0)
                    return results[0];
                return undefined;
            };
            Join.prototype.getResults = function (resultName) {
                return this.results[resultName] ? this.results[resultName] : undefined;
            };
            Join.prototype.getAllResults = function () {
                return this.results;
            };
            Join.prototype.clearCallbacks = function (runBeforeRemove) {
                if (runBeforeRemove === void 0) { runBeforeRemove = false; }
                if (runBeforeRemove) {
                    for (var i = 0; i < this.callbacks.length; ++i)
                        this.callbacks[i]();
                }
                this.callbacks = [];
            };
            Join.prototype.terminator = function (saveResultName) {
                var results = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    results[_i - 1] = arguments[_i];
                }
                if (saveResultName !== undefined)
                    this.results[saveResultName] = results;
                --this.counter;
                if (this.counter <= 0) {
                    this.counter = 0;
                    for (var i = 0; i < this.callbacks.length; ++i)
                        this.callbacks[i]();
                    this.callbacks = [];
                }
            };
            Join.prototype.fork = function (count) {
                if (count === void 0) { count = 1; }
                this.counter += count;
            };
            Join.prototype.done = function (saveResultName) {
                var results = [];
                for (var _i = 1; _i < arguments.length; _i++) {
                    results[_i - 1] = arguments[_i];
                }
                this.terminator.apply(this, [saveResultName].concat(results));
            };
            Join.prototype.getCallback = function (saveResultName) {
                this.fork();
                return this.terminator.bind(this, saveResultName);
            };
            Join.prototype.addCallback = function (callback) {
                if (this.counter > 0)
                    this.callbacks.push(callback);
                else
                    callback();
            };
            return Join;
        }());
        async.Join = Join;
    })(async = kr3m.async || (kr3m.async = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var algorithms;
    (function (algorithms) {
        var search;
        (function (search) {
            function bisect(sortedValues, searchValue, compareFunc) {
                var from = 0;
                var to = sortedValues.length;
                var i = -1;
                while (to != from) {
                    i = Math.floor((to - from) / 2) + from;
                    var comp = compareFunc(sortedValues[i], searchValue);
                    if (comp == 0)
                        return i;
                    if (comp > 0)
                        to = i;
                    else
                        from = i + 1;
                }
                return -1;
            }
            search.bisect = bisect;
            function bisectInsertPos(sortedValues, insertValue, compareFunc) {
                var from = 0;
                var to = sortedValues.length;
                var i = 0;
                while (to != from) {
                    i = Math.floor((to - from) / 2) + from;
                    var comp = compareFunc(sortedValues[i], insertValue);
                    if (comp == 0)
                        return i;
                    if (comp > 0)
                        to = i;
                    else
                        from = i + 1;
                }
                if (comp < 0)
                    return i + 1;
                else
                    return i;
            }
            search.bisectInsertPos = bisectInsertPos;
        })(search = algorithms.search || (algorithms.search = {}));
    })(algorithms = kr3m.algorithms || (kr3m.algorithms = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var SortedList = (function () {
            function SortedList(sortFunc) {
                this.sortFunc = sortFunc;
                this.items = [];
            }
            SortedList.prototype.useList = function (items, isSorted) {
                if (isSorted === void 0) { isSorted = true; }
                this.items = items;
                if (!isSorted)
                    this.items.sort(this.sortFunc);
            };
            SortedList.prototype.clear = function () {
                this.items = [];
            };
            SortedList.prototype.insertSortedValues = function () {
                var _this = this;
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                var insertPositions = values.map(function (value) { return _this.insertIndexOf(value); });
                for (var i = 1; i < insertPositions.length; ++i)
                    insertPositions[i] += i;
                (_a = this.items).push.apply(_a, values);
                var l = insertPositions.length;
                for (var i = this.items.length - 1; i >= 0; --i) {
                    if (i == insertPositions[l - 1]) {
                        this.items[i] = values.pop();
                        --l;
                    }
                    else {
                        this.items[i] = this.items[i - l];
                    }
                }
                var _a;
            };
            SortedList.prototype.insert = function () {
                var values = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    values[_i] = arguments[_i];
                }
                if (this.items.length == 0) {
                    this.items = values.slice();
                    this.items.sort(this.sortFunc);
                    return;
                }
                if ((values.length / this.items.length) > 0.3) {
                    (_a = this.items).push.apply(_a, values);
                    this.items.sort(this.sortFunc);
                    return;
                }
                values.sort(this.sortFunc);
                this.insertSortedValues.apply(this, values);
                var _a;
            };
            SortedList.prototype.insertFrom = function () {
                var lists = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    lists[_i] = arguments[_i];
                }
                for (var i = 0; i < lists.length; ++i)
                    this.insertSortedValues.apply(this, lists[i].items);
            };
            SortedList.prototype.pop = function () {
                return this.items.pop();
            };
            SortedList.prototype.shift = function () {
                return this.items.shift();
            };
            SortedList.prototype.getLength = function () {
                return this.items.length;
            };
            SortedList.prototype.getItem = function (offset) {
                return this.items[offset];
            };
            SortedList.prototype.findIndex = function (matchFunc) {
                return this.items.findIndex(matchFunc);
            };
            SortedList.prototype.find = function (matchFunc) {
                return this.items.find(matchFunc);
            };
            SortedList.prototype.toArray = function (start, end) {
                return this.items.slice(start, end);
            };
            SortedList.prototype.slice = function (start, end) {
                var newList = new SortedList(this.sortFunc);
                newList.useList(this.items.slice(start, end));
                return newList;
            };
            SortedList.prototype.splice = function (offset, deleteCount) {
                var newElements = [];
                for (var _i = 2; _i < arguments.length; _i++) {
                    newElements[_i - 2] = arguments[_i];
                }
                this.items.splice(offset, deleteCount);
                this.insert.apply(this, newElements);
            };
            SortedList.prototype.indexOf = function (value) {
                return kr3m.algorithms.search.bisect(this.items, value, this.sortFunc);
            };
            SortedList.prototype.insertIndexOf = function (value) {
                return kr3m.algorithms.search.bisectInsertPos(this.items, value, this.sortFunc);
            };
            SortedList.prototype.contains = function (value) {
                return this.indexOf(value) >= 0;
            };
            return SortedList;
        }());
        util.SortedList = SortedList;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var async;
    (function (async) {
        var PriorityQueue = (function () {
            function PriorityQueue(autoRun, parallelCount) {
                if (autoRun === void 0) { autoRun = false; }
                if (parallelCount === void 0) { parallelCount = 1; }
                this.pending = new kr3m.util.SortedList(function (a, b) { return a.p - b.p; });
                this.callbacks = [];
                this.runningCount = 0;
                this.autoRun = autoRun;
                this.parallelCount = parallelCount;
            }
            PriorityQueue.prototype.setParallelCount = function (parallelCount) {
                this.parallelCount = parallelCount;
            };
            PriorityQueue.prototype.getLength = function () {
                return this.pending.getLength();
            };
            PriorityQueue.prototype.getItem = function (offset) {
                return this.pending.getItem(offset);
            };
            Object.defineProperty(PriorityQueue.prototype, "length", {
                get: function () {
                    return this.pending.getLength();
                },
                enumerable: true,
                configurable: true
            });
            PriorityQueue.prototype.clear = function () {
                this.pending.clear();
            };
            PriorityQueue.prototype.insert = function (func, priority) {
                if (priority === void 0) { priority = 0; }
                this.pending.insert({ p: priority, f: func });
                if (this.autoRun)
                    this.start();
            };
            PriorityQueue.prototype.addCallback = function (callback) {
                this.callbacks.push(callback);
            };
            PriorityQueue.prototype.callCallbacks = function () {
                for (var i = 0; i < this.callbacks.length; ++i)
                    this.callbacks[i]();
                this.callbacks = [];
            };
            PriorityQueue.prototype.isRunning = function () {
                return this.runningCount > 0;
            };
            PriorityQueue.prototype.run = function () {
                this.start();
            };
            PriorityQueue.prototype.start = function () {
                var _this = this;
                if (this.runningCount < this.parallelCount) {
                    var current = this.pending.shift();
                    if (current) {
                        ++this.runningCount;
                        current.f(function () {
                            --_this.runningCount;
                            _this.start();
                        });
                    }
                    else {
                        if (this.runningCount == 0)
                            this.callCallbacks();
                    }
                }
            };
            return PriorityQueue;
        }());
        async.PriorityQueue = PriorityQueue;
    })(async = kr3m.async || (kr3m.async = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var loading;
    (function (loading) {
        var cache;
        (function (cache) {
            var CacheBuster = (function () {
                function CacheBuster() {
                }
                CacheBuster.prototype.applyToUrl = function (url) {
                    var pos = url.indexOf("?");
                    if (pos >= 0) {
                        var query = url.substring(pos + 1);
                        var params = kr3m.util.StringEx.splitAssoc(query);
                        params["_"] = this.getString();
                        url = url.substring(0, pos);
                        url = url + "?" + kr3m.util.StringEx.joinAssoc(params);
                    }
                    else {
                        url = url + "?_=" + this.getString();
                    }
                    return url;
                };
                return CacheBuster;
            }());
            cache.CacheBuster = CacheBuster;
        })(cache = loading.cache || (loading.cache = {}));
    })(loading = kr3m.loading || (kr3m.loading = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Validator = (function () {
            function Validator() {
            }
            Validator.email = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_EMAIL.test(text);
            };
            Validator.date = function (d, m, y) {
                var date = new Date(y, m - 1, d);
                return (date.getFullYear() == y && date.getMonth() + 1 == m && date.getDate() == d);
            };
            Validator.username = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_USERNAME.test(text);
            };
            Validator.deviceId = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_DEVICE_ID.test(text);
            };
            Validator.url = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_URL.test(text);
            };
            Validator.dataUrl = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_DATA_URL.test(text);
            };
            Validator.isInt = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_INTEGER.test(text);
            };
            Validator.isFloat = function (text) {
                if (!text)
                    return false;
                return kr3m.REGEX_FLOAT.test(text);
            };
            Validator.getPasswordSecurity = function (password) {
                var maxLevel = 3;
                for (var i = maxLevel; i >= 0; --i)
                    if (Validator.securePassword(password, i))
                        return i / maxLevel;
                return 0;
            };
            Validator.securePassword = function (password, level) {
                if (level === void 0) { level = kr3m.PASSWORD_SECURITY_LOW; }
                if (password == "")
                    return false;
                if (level <= kr3m.PASSWORD_SECURITY_NONE)
                    return true;
                if (password.length < 4)
                    return false;
                if (level <= kr3m.PASSWORD_SECURITY_LOW)
                    return true;
                if (password.length < 6)
                    return false;
                if (level <= kr3m.PASSWORD_SECURITY_MEDIUM)
                    return true;
                if (password.length < 8)
                    return false;
                var types = { digits: /\d/, capitalLetters: /[A-Z]/, letters: /[a-z]/ };
                var typeCount = { digits: 0, capitalLetters: 0, letters: 0, others: 0 };
                for (var j = 0; j < password.length; ++j) {
                    var token = password.substr(j, 1);
                    var found = false;
                    for (var i in types) {
                        if (types[i].test(token)) {
                            ++typeCount[i];
                            found = true;
                        }
                    }
                    if (!found)
                        ++typeCount.others;
                }
                if (typeCount.digits <= 0
                    || typeCount.capitalLetters <= 0
                    || typeCount.others <= 0)
                    return false;
                return true;
            };
            return Validator;
        }());
        util.Validator = Validator;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Rand = (function () {
            function Rand() {
            }
            Rand.getInt = function (a, b) {
                if (b === void 0) { b = 0; }
                var from = Math.min(a, b);
                var to = Math.max(a, b);
                return Math.floor(Math.random() * (to - from) + from);
            };
            Rand.getFloat = function (a, b) {
                if (a === void 0) { a = 1; }
                if (b === void 0) { b = 0; }
                var from = Math.min(a, b);
                var to = Math.max(a, b);
                return Math.random() * (to - from) + from;
            };
            Rand.getString = function (length, allowedCharacters) {
                if (length <= 0)
                    return "";
                allowedCharacters = allowedCharacters || Rand.CHARS_ALPHA_NUM;
                var result = "";
                var len = allowedCharacters.length;
                for (var i = 0; i < length; ++i)
                    result += allowedCharacters.charAt(Rand.getInt(len));
                return result;
            };
            Rand.getFunctionName = function () {
                var name = Rand.getString(16, Rand.CHARS_ALPHA);
                while (window[name])
                    name = Rand.getString(16, Rand.CHARS_ALPHA);
                return name;
            };
            Rand.getBool = function (trueChance) {
                if (trueChance === void 0) { trueChance = 0.5; }
                return Math.random() < trueChance;
            };
            Rand.getIndex = function (array) {
                if (array.length == 0)
                    return undefined;
                return Rand.getInt(array.length);
            };
            Rand.getIndexWeighted = function (weights) {
                var total = 0;
                for (var i = 0; i < weights.length; ++i)
                    total += Math.max(weights[i], 0);
                var weight = Rand.getFloat(total);
                for (var i = 0; i < weights.length; ++i) {
                    if (weight <= weights[i])
                        return i;
                    weight -= Math.max(weights[i], 0);
                }
                return undefined;
            };
            Rand.getElement = function (array) {
                if (array.length == 0)
                    return undefined;
                return array[Rand.getIndex(array)];
            };
            Rand.getElementWeighted = function (array, weights) {
                if (array.length == 0)
                    return undefined;
                if (array.length != weights.length)
                    throw new Error("array length and weights length don't match");
                return array[Rand.getIndexWeighted(weights)];
            };
            Rand.getShuffledInts = function (count) {
                var result = [];
                for (var i = 0; i < count; ++i)
                    result.push(i);
                return Rand.shuffleArray(result);
            };
            Rand.shuffleArray = function (arr) {
                var result = arr.slice();
                for (var i = 0; i < result.length - 1; ++i) {
                    var pos = Rand.getInt(i, result.length);
                    var temp = result[i];
                    result[i] = result[pos];
                    result[pos] = temp;
                }
                return result;
            };
            Rand.getTimeStamp = function (a, b) {
                var from = Math.min(a.getTime(), b.getTime());
                var to = Math.max(a.getTime(), b.getTime());
                return new Date(Math.random() * (to - from) + from);
            };
            Rand.getPassword = function (level) {
                if (level === void 0) { level = kr3m.PASSWORD_SECURITY_LOW; }
                var digits = 10;
                do {
                    var password = Rand.getString(digits, Rand.CHARS_PASSWORD);
                } while (!util.Validator.securePassword(password, level));
                return password;
            };
            Rand.CHARS_ALPHA = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
            Rand.CHARS_ALPHA_NUM = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
            Rand.CHARS_PASSWORD = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!§$%&/()=?{[]}#+-_~^<>|\\@,.;:";
            return Rand;
        }());
        util.Rand = Rand;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var loading;
    (function (loading) {
        var cache;
        (function (cache) {
            var CacheBusterAlways = (function (_super) {
                __extends(CacheBusterAlways, _super);
                function CacheBusterAlways() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                CacheBusterAlways.prototype.getString = function () {
                    return "" + kr3m.util.Rand.getInt(0, 2000000000);
                };
                return CacheBusterAlways;
            }(kr3m.loading.cache.CacheBuster));
            cache.CacheBusterAlways = CacheBusterAlways;
        })(cache = loading.cache || (loading.cache = {}));
    })(loading = kr3m.loading || (kr3m.loading = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var loading;
    (function (loading) {
        var Loader2 = (function () {
            function Loader2() {
                this.queue = new kr3m.async.PriorityQueue(true, 4);
                this.loadedCount = 0;
                this.cacheBuster = new loading.cache.CacheBusterAlways();
            }
            Loader2.getInstance = function () {
                if (!Loader2.instance)
                    Loader2.instance = new Loader2();
                return Loader2.instance;
            };
            Loader2.prototype.getLoadedCount = function () {
                return this.loadedCount;
            };
            Loader2.prototype.getQueueLength = function () {
                return this.queue.getLength();
            };
            Loader2.prototype.getPendingByPriority = function () {
                var result = {};
                var len = this.queue.getLength();
                for (var i = 0; i < len; ++i) {
                    var p = this.queue.getItem(i).p;
                    result[p] = (result[p] || 0) + 1;
                }
                return result;
            };
            Loader2.prototype.setMaxParallelDownloads = function (maxParallel) {
                this.queue.setParallelCount(maxParallel);
            };
            Loader2.prototype.setCacheBuster = function (buster) {
                this.cacheBuster = buster;
            };
            Loader2.prototype.getCacheBusterString = function () {
                return this.cacheBuster.getString();
            };
            Loader2.prototype.loadFile = function () {
                var _this = this;
                var U = kr3m.util.Util;
                var url = arguments[0];
                var resultType = U.getFirstOfType(arguments, "string", 1);
                var callback = U.getFirstOfType(arguments, "function");
                var priority = U.getFirstOfType(arguments, "number") || 0;
                var errorCallback = U.getFirstOfType(arguments, "function", 0, 1);
                var loadUrl = this.cacheBuster.applyToUrl(url);
                this.queue.insert(function (next) {
                    resultType = resultType || kr3m.util.Ajax.getTypeFromUrl(url) || "json";
                    if (resultType == "image") {
                        var image = new Image();
                        image.onload = function () {
                            ++_this.loadedCount;
                            next();
                            callback && callback(image);
                        };
                        image.onerror = function () {
                            next();
                            errorCallback && errorCallback();
                        };
                        image.src = loadUrl;
                    }
                    else {
                        kr3m.util.Ajax.call(loadUrl, function (content) {
                            ++_this.loadedCount;
                            next();
                            callback && callback(content);
                        }, resultType, function () {
                            next();
                            errorCallback && errorCallback();
                        });
                    }
                }, priority);
            };
            Loader2.prototype.loadFiles = function () {
                var U = kr3m.util.Util;
                var urls = arguments[0];
                var callback = U.getFirstOfType(arguments, "function");
                var priority = U.getFirstOfType(arguments, "number") || 0;
                var progressListener = U.getFirstOfType(arguments, "function", 0, 1);
                var total = urls.length;
                var done = 0;
                var errors = 0;
                var join = new kr3m.async.Join();
                for (var i = 0; i < urls.length; ++i) {
                    var fileCallback = join.getCallback(urls[i]);
                    this.loadFile(urls[i], priority, function (content) {
                        ++done;
                        progressListener && progressListener(done, errors, total);
                        fileCallback(content);
                    }, function () {
                        ++errors;
                        progressListener && progressListener(done, errors, total);
                        fileCallback(null);
                    });
                }
                join.addCallback(function () { return callback && callback(join.getAllResults()); });
            };
            return Loader2;
        }());
        loading.Loader2 = Loader2;
    })(loading = kr3m.loading || (kr3m.loading = {}));
})(kr3m || (kr3m = {}));
var kr3m;
(function (kr3m) {
    var util;
    (function (util) {
        var Localization = (function () {
            function Localization() {
            }
            Localization.setModuleItem = function (tempModule, id, value) {
                if (value === undefined || value === null)
                    return;
                if (value || Localization.allowEmptyStrings)
                    tempModule.items[id] = value.toString();
            };
            Localization.setRaw = function (id, text, language) {
                language = language || Localization.language;
                var tempModule = Localization.getModule(language);
                Localization.setModuleItem(tempModule, id, text);
            };
            Localization.getRaw = function (id, language) {
                try {
                    var win = window;
                    while (true) {
                        if (win.location.search.match(/\bshowLocIds=true\b/))
                            return id;
                        if (win == top)
                            break;
                        win = win.parent;
                    }
                }
                catch (e) {
                }
                language = language || Localization.language;
                var modules = Localization.modules[language];
                if (modules) {
                    for (var i = 0; i < modules.length; ++i) {
                        var tempModule = modules[i];
                        if (tempModule.items[id] !== undefined)
                            return tempModule.items[id];
                    }
                }
                return undefined;
            };
            Localization.get = function (id, tokens, language) {
                language = language || Localization.language;
                var raw = Localization.getRaw(id, language);
                if (raw !== undefined)
                    return util.Tokenizer.get(raw, tokens);
                if (language != Localization.fallback)
                    return Localization.get(id, tokens, Localization.fallback);
                util.Log.logWarning("missing localization", id, "for language", language);
                return "loc(" + id + ")";
            };
            Localization.cloneLanguage = function (fromLanguage, toLanguage) {
                Localization.modules[toLanguage] = util.Util.clone(Localization.modules[fromLanguage]);
            };
            Localization.getFormattedDate = function (formatId, dateObj, language) {
                if (dateObj === void 0) { dateObj = new Date(); }
                if (dateObj === null || dateObj == "0000-00-00" || dateObj == "0000-00-00 00:00:00")
                    return "";
                if (!(dateObj instanceof Date))
                    dateObj = new Date(dateObj);
                return Localization.get(formatId, Localization.getDateTokens(dateObj), language);
            };
            Localization.getDateTokens = function (dateObj) {
                if (dateObj === void 0) { dateObj = new Date(); }
                var tokens = {};
                tokens.D = dateObj.getDate();
                tokens.DD = (tokens.D < 10) ? "0" + tokens.D : tokens.D;
                tokens.M = dateObj.getMonth() + 1;
                tokens.MM = (tokens.M < 10) ? "0" + tokens.M : tokens.M;
                tokens.YYYY = dateObj.getFullYear();
                tokens.YY = tokens.YYYY % 100;
                tokens.H = dateObj.getHours();
                tokens.HH = (tokens.H < 10) ? "0" + tokens.H : tokens.H;
                tokens.I = dateObj.getMinutes();
                tokens.II = (tokens.I < 10) ? "0" + tokens.I : tokens.I;
                tokens.S = dateObj.getSeconds();
                tokens.SS = (tokens.S < 10) ? "0" + tokens.S : tokens.S;
                return tokens;
            };
            Localization.getDateFromString = function (formatId, text, language) {
                language = language || Localization.language;
                var raw = Localization.getRaw(formatId, language);
                if (!raw)
                    return null;
                var values = util.Tokenizer.revertValues(raw, text);
                if (!values)
                    return null;
                var date = new Date(0);
                for (var i in values) {
                    var value = parseInt(values[i], 0);
                    if (isNaN(value))
                        return null;
                    switch (i) {
                        case "YY":
                            var year = value;
                            if (year > 30)
                                date.setFullYear(year + 1900);
                            else
                                date.setFullYear(year + 2000);
                            break;
                        case "YYYY":
                            date.setFullYear(value);
                            break;
                        case "M":
                        case "MM":
                            date.setMonth(value - 1);
                            break;
                        case "D":
                        case "DD":
                            date.setDate(value);
                            break;
                        case "H":
                        case "HH":
                            date.setHours(value);
                            break;
                        case "I":
                        case "II":
                            date.setMinutes(value);
                            break;
                        case "S":
                        case "SS":
                            date.setSeconds(value);
                            break;
                    }
                }
                return date;
            };
            Localization.getModule = function (language, moduleName) {
                language = language || Localization.language;
                if (Localization.modules[language] == null)
                    Localization.modules[language] = [];
                for (var i = 0; i < Localization.modules[language].length; ++i)
                    if (Localization.modules[language][i].name == moduleName)
                        return Localization.modules[language][i];
                var tempModule = { name: moduleName, items: {} };
                Localization.modules[language].push(tempModule);
                return tempModule;
            };
            Localization.dropModule = function (name) {
                for (var lang in Localization.modules) {
                    if (Localization.modules[lang][name])
                        delete Localization.modules[lang][name];
                }
            };
            Localization.mergeModule = function (fromName, toName) {
                if (fromName == toName)
                    return;
                for (var lang in Localization.modules) {
                    var from = Localization.getModule(lang, fromName);
                    var to = Localization.getModule(lang, toName);
                    for (var i in from.items)
                        Localization.setModuleItem(to, i, from.items[i]);
                }
                Localization.dropModule(fromName);
            };
            Localization.addJSONModule = function (texts, language, callback, moduleName) {
                language = language || Localization.language;
                var tempModule = Localization.getModule(language, moduleName);
                for (var id in texts)
                    Localization.setModuleItem(tempModule, id, texts[id]);
                callback && callback();
            };
            Localization.addJSONModuleFromUrl = function (fileUrl, language, callback, moduleName) {
                language = language || Localization.language;
                var loader = kr3m.loading.Loader2.getInstance();
                loader.loadFile(fileUrl, -1, function (texts) {
                    Localization.addJSONModule(texts, language, callback, moduleName);
                }, function () {
                    util.Log.logError("localization file " + fileUrl + " could not be loaded");
                    callback && callback();
                });
            };
            Localization.addXMLModule = function (xmlDoc, language, callback, moduleName) {
                if (!xmlDoc)
                    return callback && callback();
                language = language || Localization.language;
                var tempModule = Localization.getModule(language, moduleName);
                var texts = xmlDoc.getElementsByTagName("text");
                var device = util.Device.getInstance();
                if (device.ie) {
                    for (var i = 0; i < texts.length; ++i) {
                        var key = texts[i].getAttribute("id");
                        var value = texts[i].childNodes[0].nodeValue;
                        Localization.setModuleItem(tempModule, key, value.replace(/^\s*\<\!\[CDATA\[([\s\S]*?)\]\]\>\s*$/i, "$1"));
                    }
                }
                else {
                    for (var i = 0; i < texts.length; ++i) {
                        var key = texts[i].id;
                        var value = texts[i].innerHTML;
                        tempModule.items[key] = value.replace(/^\s*\<\!\[CDATA\[([\s\S]*?)\]\]\>\s*$/i, "$1");
                        Localization.setModuleItem(tempModule, key, value.replace(/^\s*\<\!\[CDATA\[([\s\S]*?)\]\]\>\s*$/i, "$1"));
                    }
                }
                callback && callback();
            };
            Localization.addXMLModuleFromRawXml = function (rawXml, language, callback, moduleName) {
                language = language || Localization.language;
                var tempModule = Localization.getModule(language, moduleName);
                var xml = kr3m.xml.parseString(rawXml);
                var texts = Array.isArray(xml.text) ? xml.text : [xml.text];
                for (var i = 0; i < texts.length; ++i) {
                    var key = texts[i]._attributes.id;
                    var value = texts[i]._data;
                    Localization.setModuleItem(tempModule, key, value);
                }
                callback && callback();
            };
            Localization.addXMLModuleFromUrl = function (fileUrl, language, callback, moduleName) {
                language = language || Localization.language;
                var loader = kr3m.loading.Loader2.getInstance();
                loader.loadFile(fileUrl, -1, "text", function (xml) {
                    Localization.addXMLModuleFromRawXml(xml, language, callback, moduleName);
                }, function () {
                    util.Log.logError("localization file " + fileUrl + " could not be loaded");
                    callback && callback();
                });
            };
            Localization.fallback = "en";
            Localization.language = "en";
            Localization.allowEmptyStrings = true;
            Localization.modules = {};
            return Localization;
        }());
        util.Localization = Localization;
    })(util = kr3m.util || (kr3m.util = {}));
})(kr3m || (kr3m = {}));
kr3m.util.Tokenizer.setFormatter("loc", function (value, tokens, name) { return kr3m.util.Localization.get(value, tokens); });
kr3m.util.Tokenizer.setFormatter("date", function (value, tokens, name) { return kr3m.util.Localization.getFormattedDate(kr3m.FORMAT_DATE, value); });
kr3m.util.Tokenizer.setFormatter("time", function (value, tokens, name) { return kr3m.util.Localization.getFormattedDate(kr3m.FORMAT_TIME, value); });
kr3m.util.Tokenizer.setFormatter("dateTime", function (value, tokens, name) { return kr3m.util.Localization.getFormattedDate(kr3m.FORMAT_DATETIME, value); });
function loc(id, tokens, languageId) {
    return kr3m.util.Localization.get(id, tokens, languageId);
}
function locDate(id, dateObj, languageId) {
    return kr3m.util.Localization.getFormattedDate(id, dateObj, languageId);
}
function initLoc(pathOrUrl, languageId, callback) {
    var ext = pathOrUrl.replace(/^.*\.([^\.]+)$/, "$1").toLowerCase();
    kr3m.util.Localization.language = languageId;
    if (ext == "xml")
        return kr3m.util.Localization.addXMLModuleFromUrl(pathOrUrl, languageId, callback);
    if (ext == "json" || ext == "js")
        return kr3m.util.Localization.addJSONModuleFromUrl(pathOrUrl, languageId, callback);
    callback();
}
var Client = (function (_super) {
    __extends(Client, _super);
    function Client() {
        var _this = _super.call(this) || this;
        kr3m.loading.Loader2.getInstance().loadFile("js/data/config.json", function (content) {
            _this.config = $.extend({}, new cuboro.Config(), content);
            _this.config.language = kr3m.util.Browser.getQueryValue("lang") || _this.config.language;
            _this.game = new gf.core.Game(_this);
            _this.game.loader.on(gf.LOAD_PROGRESS, _this.onLoadProgress, _this);
            _this.game.loader.once(gf.LOAD_COMPLETE, _this.onLoadComplete, _this);
            _this.config.addAssets(_this);
            _this.game.loader.start();
            casClient.on(cas.POPUP_EMAIL_VALIDATED, function (data) {
                log(cas.POPUP_EMAIL_VALIDATED, data);
            });
            casClient.on(cas.POPUP_RESET_PASSWORD, function (data) {
                log(cas.POPUP_RESET_PASSWORD, data);
            });
            casClient.on(cas.POPUP_EMAIL_REMINDER, function (data) {
                log(cas.POPUP_EMAIL_REMINDER, data);
                _this.popupEmailReminder = true;
                _this.popupData = data;
                if (_this.clientReady)
                    _this.showPopEmailReminder();
            });
        });
        return _this;
    }
    Client.prototype.onLoadProgress = function () {
        $("#progress").text(this.game.loader.progress + "%");
        $("#bar").width(this.game.loader.progress + "%");
    };
    Client.prototype.onLoadComplete = function () {
        this.game.loader.off(gf.LOAD_PROGRESS, this.onLoadProgress);
        $("#loader").remove();
        kr3m.util.Localization.fallback = this.config.language;
        kr3m.util.Localization.language = this.config.language;
        kr3m.util.Localization.addJSONModule(this.game.cache.getJSON("language"), this.config.language);
        setToken("pixi", PIXI.VERSION);
        setToken("three", THREE.REVISION);
        setToken("renderer", this.game.renderer.type == PIXI.RENDERER_TYPE.CANVAS ? "Canvas" : "WebGL");
        log(loc("say_hello", { name: loc("app_title"), version: cuboro.VERSION }));
        this.game.once(gf.RUNNING, this.onRun, this);
        this.game.start();
    };
    Client.prototype.onRun = function () {
        var _this = this;
        log(this.game);
        this.hint = new cuboro.ui.Hint(this.game);
        this.game.stage.addChild(this.hint);
        var trackId = parseInt(kr3m.util.Browser.getQueryValue("tid"), 10);
        if (trackId) {
            this.game.overlays.show(cuboro.overlays.Loader.NAME);
            sTrack.load(trackId, function (track) {
                _this.game.overlays.hide(cuboro.overlays.Loader.NAME);
                if (track) {
                    cuboro.core.Loader.loadTrack(_this.game, track, false);
                }
                else {
                    _this.game.screens.show("start");
                }
            });
        }
        else {
            this.game.screens.show("start");
        }
        this.clientReady = true;
        if (this.popupEmailReminder)
            this.showPopEmailReminder();
        if (!PIXI.utils.isWebGLSupported() || this.game.renderer.type == PIXI.RENDERER_TYPE.CANVAS)
            this.hint.show(loc("hint_webgl_title"), loc("hint_webgl"));
        if (!this.game.storage.isSupported)
            this.hint.show(loc("hint_cookies_title"), loc("hint_cookies"));
    };
    Client.prototype.showPopEmailReminder = function () {
        this.popupEmailReminder = false;
        var overlay = this.game.overlays.show(cuboro.overlays.FinishRegister.NAME);
        overlay.email = this.popupData.email;
    };
    return Client;
}(gf.Client));
new Client();
