/*
	This file was automatically created using a source code generator.
	Do not edit this file manually as all changes will be overwritten
	the next time the generator runs again.
*/



/// <reference path="../../cuboro/tables/competitionvo.ts"/>
/// <reference path="../../cuboro/tables/regionadminvo.ts"/>
/// <reference path="../../cuboro/tables/regiondomainvo.ts"/>
/// <reference path="../../cuboro/tables/trackvo.ts"/>
/// <reference path="../../cuboro/tables/uservo.ts"/>
/// <reference path="../../kr3m/types.ts"/>
//# !CLIENT
/// <reference path="../../kr3m/services/paramshelper.ts"/>
/// <reference path="../../kr3m/util/factory.ts"/>
//# /!CLIENT



module cuboro.tables
{
	export class RegionVariantVO
	{
		public static ID_MAX_LENGTH = 32;
		public static ID_MAX_LENGTH_SECURE = 16;

		public static LANGUAGE_IDS_MAX_LENGTH = 256;
		public static LANGUAGE_IDS_MAX_LENGTH_SECURE = 128;

		public static REGION_ID_MAX_LENGTH = 2;
		public static REGION_ID_MAX_LENGTH_SECURE = 1;



		public id:string; // varchar(32)
		public languageIds:string; // varchar(256)
		public regionId:string; // char(2)
//# !CLIENT



		public static isColumnName(name:string):boolean
		{
			return (["id","languageIds","regionId"]).indexOf(name) >= 0;
		}



		public static getColumnNames():string[]
		{
			return ["id","languageIds","regionId"];
		}



		/*
			Builds a proper cuboro.tables.RegionVariantVO class object from
			a POD / JSON object.

			If this is not possible, because some required attributes
			are missing for example, null will be returned.
		*/
		public static buildFrom(raw:any):cuboro.tables.RegionVariantVO
		{
			var helper = new kr3m.services.ParamsHelper(raw);
			if (!helper.validate({"id":"string","languageIds":"string","regionId":"string"}, {}))
				return null;

			var foreignKeyNames = [];
			var vo = new cuboro.tables.RegionVariantVO();
			var copyFields = ["id","languageIds","regionId"];
			for (var i = 0; i < copyFields.length; ++i)
			{
				vo[copyFields[i]] = raw[copyFields[i]];
				if (!vo[copyFields[i]] && kr3m.util.Util.contains(foreignKeyNames, copyFields[i]))
					vo[copyFields[i]] = null;
			}
			return vo;
		}



		public constructor(rawData?:any)
		{
			if (rawData)
			{
				for (var i in rawData)
				{
					if (cuboro.tables.RegionVariantVO.isColumnName(i))
						this[i] = rawData[i];
				}
			}
		}



		private wrapErrorCallback(
			errorCallback:ErrorCallback,
			functionName:string):ErrorCallback
		{
			if (!errorCallback)
				return errorCallback;

			var newCallback = (errorMessage) =>
			{
				errorCallback("cuboro.tables.RegionVariantVO." + functionName + " - " + errorMessage);
			}
			return newCallback;
		}



		/*
			Will be called after the class was created and filled
			with content from the database.
		*/
		public postLoad():void
		{
			// can be overwritten in derived classes
		}



		/*
			Will be called before the class' content will be
			written into the database.
		*/
		public preStore():void
		{
			// can be overwritten in derived classes
		}



		/*
			Will be called after the class' content was
			written into the database.
		*/
		public postStore():void
		{
			// can be overwritten in derived classes
		}



		protected checkId(
			callback:(wasGenerated:boolean) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "checkId");
			if (this.id)
				return callback(false);

			kr3m.async.Loop.loop((loopDone) =>
			{
				kr3m.util.Rand.getSecureString(32, null, (secureValue) =>
				{
					this.id = secureValue;
					db.fetchOne(db.escape("SELECT id FROM region_variants WHERE id = ? LIMIT 0,1;", [this.id]), dummy => loopDone(!!dummy), errorCallback);
				});
			}, () => callback(true));
		}



		public insert(
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "insert");
			var retries = 3;
			kr3m.async.Loop.loop((loopDone) =>
			{
				this.checkId((wasGenerated) =>
				{
					this.preStore();
					db.insert("region_variants", this, () =>
					{
						this.postStore();
						callback && callback();
					}, (errorMessage) =>
					{
						if (!wasGenerated || retries <= 0 || errorMessage.indexOf("ER_DUP_ENTRY") < 0)
						{
							if (errorCallback)
								return errorCallback(errorMessage);

							logError(errorMessage);
							return callback && callback();
						}

						logWarning(errorMessage);
						logWarning("retrying");
						--retries;
						loopDone(true);
					});
				});
			});
		}



		public upsert(
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "upsert");
			var retries = 3;
			kr3m.async.Loop.loop((loopDone) =>
			{
				this.checkId((wasGenerated) =>
				{
					this.preStore();
					db.upsert("region_variants", this, () =>
					{
						this.postStore();
						callback && callback();
					}, null, (errorMessage) =>
					{
						if (!wasGenerated || retries <= 0 || errorMessage.indexOf("ER_DUP_ENTRY") < 0)
						{
							if (errorCallback)
								return errorCallback(errorMessage);

							logError(errorMessage);
							return callback && callback();
						}

						logWarning(errorMessage);
						logWarning("retrying");
						--retries;
						loopDone(true);
					});
				});
			});
		}



		public update(
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "update");
			this.preStore();
			db.update("region_variants", this, () =>
			{
				this.postStore();
				callback && callback();
			}, "id", errorCallback);
		}



		public delete(
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "delete");
			var where = db.escape("id = ?", [this.id]);
			db.deleteBatch("region_variants", where, callback, errorCallback);
		}



		public getCompetitions(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitions(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitions(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitions(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitions(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitions(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitions(
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitions(
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitions():void
		{
			var u = kr3m.util.Util;


			var whereObj = <{[colName:string]:any}> u.getFirstOfType(arguments, "object", 0, 0);
			var whereString = whereObj ? db.where(whereObj) : <string> u.getFirstOfType(arguments, "string", 0, 0);
			var where = whereString ? " AND (" + whereString.replace(/\bWHERE\b/i, "") + ") " : "";

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0);
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1);
			var limits = (offset !== undefined && limit !== undefined) ? db.escape(" LIMIT ?, ?", [offset, limit]) : "";

			var callback = <CB<cuboro.tables.CompetitionVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "getCompetitions");

			var sql = "SELECT * FROM `competitions` WHERE `regionId` = ? " + where + limits;
			sql = db.escape(sql, [this.id]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.CompetitionVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getCompetitionsByEnabled(
			enabled:boolean,
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			callback:CB<cuboro.tables.CompetitionVO[]>,
			errorCallback:ErrorCallback):void;

		public getCompetitionsByEnabled(
			enabled:boolean,
			callback:CB<cuboro.tables.CompetitionVO[]>):void;

		public getCompetitionsByEnabled():void
		{
			var u = kr3m.util.Util;
			var enabled = <boolean> u.getFirstOfType(arguments, "boolean", 0, 0);

			var whereObj = <{[colName:string]:any}> u.getFirstOfType(arguments, "object", 0, 0);
			var whereString = whereObj ? db.where(whereObj) : <string> u.getFirstOfType(arguments, "string", 0, 0);
			var where = whereString ? " AND (" + whereString.replace(/\bWHERE\b/i, "") + ") " : "";

			var offset = <number> u.getFirstOfType(arguments, "number", 1, 0);
			var limit = <number> u.getFirstOfType(arguments, "number", 1, 1);
			var limits = (offset !== undefined && limit !== undefined) ? db.escape(" LIMIT ?, ?", [offset, limit]) : "";

			var callback = <CB<cuboro.tables.CompetitionVO[]>> u.getFirstOfType(arguments, "function", 1, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 1, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "getCompetitionsByEnabled");

			var sql = "SELECT * FROM `competitions` WHERE `regionId` = ? AND `enabled` = ? " + where + limits;
			sql = db.escape(sql, [this.id, enabled]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.CompetitionVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getRegionAdmins(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionAdminVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionAdmins(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionAdminVO[]>):void;

		public getRegionAdmins(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.RegionAdminVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionAdmins(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.RegionAdminVO[]>):void;

		public getRegionAdmins(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionAdminVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionAdmins(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionAdminVO[]>):void;

		public getRegionAdmins(
			callback:CB<cuboro.tables.RegionAdminVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionAdmins(
			callback:CB<cuboro.tables.RegionAdminVO[]>):void;

		public getRegionAdmins():void
		{
			var u = kr3m.util.Util;


			var whereObj = <{[colName:string]:any}> u.getFirstOfType(arguments, "object", 0, 0);
			var whereString = whereObj ? db.where(whereObj) : <string> u.getFirstOfType(arguments, "string", 0, 0);
			var where = whereString ? " AND (" + whereString.replace(/\bWHERE\b/i, "") + ") " : "";

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0);
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1);
			var limits = (offset !== undefined && limit !== undefined) ? db.escape(" LIMIT ?, ?", [offset, limit]) : "";

			var callback = <CB<cuboro.tables.RegionAdminVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "getRegionAdmins");

			var sql = "SELECT * FROM `region_admins` WHERE `regionId` = ? " + where + limits;
			sql = db.escape(sql, [this.id]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.RegionAdminVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getRegionAdminByUserId(
			userId:number,
			callback:CB<cuboro.tables.RegionAdminVO>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getRegionAdminByUserId");
			var sql = "SELECT * FROM `region_admins` WHERE `regionId` = ? AND `userId` = ? LIMIT 0,1";
			sql = db.escape(sql, [this.id, userId]);
			db.fetchRow(sql, (data) =>
			{
				if (!data)
					return callback(undefined);

				data.__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.RegionAdminVO).prototype;
				data.postLoad();
				callback(data);
			}, errorCallback);
		}



		public getRegionDomains(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionDomainVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionDomains(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionDomainVO[]>):void;

		public getRegionDomains(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.RegionDomainVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionDomains(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.RegionDomainVO[]>):void;

		public getRegionDomains(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionDomainVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionDomains(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.RegionDomainVO[]>):void;

		public getRegionDomains(
			callback:CB<cuboro.tables.RegionDomainVO[]>,
			errorCallback:ErrorCallback):void;

		public getRegionDomains(
			callback:CB<cuboro.tables.RegionDomainVO[]>):void;

		public getRegionDomains():void
		{
			var u = kr3m.util.Util;


			var whereObj = <{[colName:string]:any}> u.getFirstOfType(arguments, "object", 0, 0);
			var whereString = whereObj ? db.where(whereObj) : <string> u.getFirstOfType(arguments, "string", 0, 0);
			var where = whereString ? " AND (" + whereString.replace(/\bWHERE\b/i, "") + ") " : "";

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0);
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1);
			var limits = (offset !== undefined && limit !== undefined) ? db.escape(" LIMIT ?, ?", [offset, limit]) : "";

			var callback = <CB<cuboro.tables.RegionDomainVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "getRegionDomains");

			var sql = "SELECT * FROM `region_domains` WHERE `regionId` = ? " + where + limits;
			sql = db.escape(sql, [this.id]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.RegionDomainVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getTracks(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public getTracks(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public getTracks(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public getTracks(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public getTracks(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public getTracks(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public getTracks(
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public getTracks(
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public getTracks():void
		{
			var u = kr3m.util.Util;


			var whereObj = <{[colName:string]:any}> u.getFirstOfType(arguments, "object", 0, 0);
			var whereString = whereObj ? db.where(whereObj) : <string> u.getFirstOfType(arguments, "string", 0, 0);
			var where = whereString ? " AND (" + whereString.replace(/\bWHERE\b/i, "") + ") " : "";

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0);
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1);
			var limits = (offset !== undefined && limit !== undefined) ? db.escape(" LIMIT ?, ?", [offset, limit]) : "";

			var callback = <CB<cuboro.tables.TrackVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "getTracks");

			var sql = "SELECT * FROM `tracks` WHERE `regionId` = ? " + where + limits;
			sql = db.escape(sql, [this.id]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getUsers(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.UserVO[]>,
			errorCallback:ErrorCallback):void;

		public getUsers(
			where:string|{[colName:string]:any},
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.UserVO[]>):void;

		public getUsers(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.UserVO[]>,
			errorCallback:ErrorCallback):void;

		public getUsers(
			where:string|{[colName:string]:any},
			callback:CB<cuboro.tables.UserVO[]>):void;

		public getUsers(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.UserVO[]>,
			errorCallback:ErrorCallback):void;

		public getUsers(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.UserVO[]>):void;

		public getUsers(
			callback:CB<cuboro.tables.UserVO[]>,
			errorCallback:ErrorCallback):void;

		public getUsers(
			callback:CB<cuboro.tables.UserVO[]>):void;

		public getUsers():void
		{
			var u = kr3m.util.Util;


			var whereObj = <{[colName:string]:any}> u.getFirstOfType(arguments, "object", 0, 0);
			var whereString = whereObj ? db.where(whereObj) : <string> u.getFirstOfType(arguments, "string", 0, 0);
			var where = whereString ? " AND (" + whereString.replace(/\bWHERE\b/i, "") + ") " : "";

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0);
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1);
			var limits = (offset !== undefined && limit !== undefined) ? db.escape(" LIMIT ?, ?", [offset, limit]) : "";

			var callback = <CB<cuboro.tables.UserVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "getUsers");

			var sql = "SELECT * FROM `users` WHERE `lastRegionId` = ? " + where + limits;
			sql = db.escape(sql, [this.id]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.UserVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}

//# /!CLIENT
	}
}
