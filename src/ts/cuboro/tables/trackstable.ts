/*
	This file was automatically created using a source code generator.
	Do not edit this file manually as all changes will be overwritten
	the next time the generator runs again.
*/



/// <reference path="../../cuboro/tables/trackvo.ts"/>
/// <reference path="../../kr3m/dojo/gridqueryresponse.ts"/>
/// <reference path="../../kr3m/types.ts"/>
//# !CLIENT
/// <reference path="../../kr3m/util/factory.ts"/>
//# /!CLIENT



module cuboro.tables
{
	export class TracksTable
	{
		public isColumnName(name:string):boolean
		{
			return (["createdWhen","data","id","imageUrl","isEducational","isPublished","lastSavedWhen","name","ownerId","previousId","regionId","scoreTotal"]).indexOf(name) >= 0;
		}



		public getColumnNames():string[]
		{
			return ["createdWhen","data","id","imageUrl","isEducational","isPublished","lastSavedWhen","name","ownerId","previousId","regionId","scoreTotal"];
		}



		/*
			Generates an ORDER BY string for mysql from the strings
			given in ordering.

			The parameter ordering can contain columnNames of the table
			or "asc" / "desc" (case is ignored). asc and desc will be
			added to the last columnName added before the asc / desc
			parameter.

			Values that are neither "asc", "desc" or a columnName will
			be silently ignored.

			Example:
				table.buildOrdering(["lastName", "firstName", "ASC", "age", "DESC"]);
		*/
		public buildOrdering(ordering:string[]):string
		{
			var parts:string[] = [];
			var ascDescRe = /^asc|desc$/i;
			for (var i = 0; i < ordering.length; ++i)
			{
				if (this.isColumnName(ordering[i]))
					parts.push(db.escapeId(ordering[i]));
				else if (ascDescRe.test(ordering[i]) && parts.length > 0)
					parts[parts.length - 1] += " " + ordering[i].toUpperCase();
			}
			return parts.length > 0 ? " ORDER BY " + parts.join(", ") : "";
		}



		public getCount(
			where:string,
			callback:NumberCallback,
			errorCallback:ErrorCallback):void;

		public getCount(
			where:string,
			callback:NumberCallback):void;

		public getCount(
			callback:NumberCallback,
			errorCallback:ErrorCallback):void;

		public getCount(
			callback:NumberCallback):void;

		public getCount():void
		{
			var u = kr3m.util.Util;

			var where = <string> u.getFirstOfType(arguments, "string", 0, 0) || "1";
			where = where.replace(/^\s*where\s*/i, " ");

			var callback = <(count:number) => void> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);

			var sql = "SELECT COUNT(*) FROM `tracks` WHERE " + where;
			db.fetchOne(sql, callback, errorCallback);
		}



		private wrapErrorCallback(
			errorCallback:ErrorCallback,
			functionName:string):ErrorCallback
		{
			if (!errorCallback)
				return errorCallback;

			var newCallback = (errorMessage) =>
			{
				errorCallback("cuboro.tables.TrackVO." + functionName + " - " + errorMessage);
			}
			return newCallback;
		}



		public get(
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public get(
			whereSql:string,
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public get(
			whereSql:string,
			ordering:string[],
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			ordering:string[],
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public get(
			whereSql:string,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public get(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public get(
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			callback:CB<cuboro.tables.TrackVO[]>):void;

		public get():void
		{
			var u = kr3m.util.Util;

			var whereSql = <string> u.getFirstOfType(arguments, "string", 0, 0) || "1";
			whereSql = whereSql.replace(/^\s*where\s*/i, " ");

			var callback = <CB<cuboro.tables.TrackVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "get");

			var sql = "SELECT * FROM `tracks` WHERE " + whereSql;

			var ordering = <string[]> u.getFirstOfType(arguments, "object", 0, 0) || [];
			if (ordering.length > 0)
				sql += this.buildOrdering(ordering);

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0) || 0;
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1) || 0;
			if (limit > 0)
				sql += db.escape(" LIMIT ?, ?", [offset, limit]);

			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getIterative(
			where:string,
			dataCallback:(vos:cuboro.tables.TrackVO[], callback:Callback) => void,
			doneCallback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getIterative");
			where = where.replace(/^\s*where\s*/i, " ");
			var sql = "SELECT * FROM `tracks` WHERE " + where;
			db.queryIterative(sql, (rows, nextBatch) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				dataCallback(rows, nextBatch);
			}, doneCallback, 20, errorCallback);
		}



		/*
			Saves the given objects into the table without and kind of checking.
		*/
		public updateRaw(
			rows:any[],
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "updateRaw");
			db.updateBatch("tracks", rows, callback, db.defaultBatchSize, "id", errorCallback);
		}



		/*
			Calls the function of the same name from kr3m.db.MySqlDb using this
			table's name and changing the result elements into VOs before returning
			them.

			Careful: if joins are used, the returned VOs may contain attributes that
			aren't defined in the class definition (in Typescript).
		*/
		public fetchPage(
			where:Object|string,
			orderBy:{col:string, asc:boolean}[],
			joins:{localCol:string, foreignCol:string, tableName:string}[],
			offset:number, limit:number,
			callback:(rows:any[], totalCount:number) => void):void
		{
			db.fetchPage("tracks", where, orderBy, joins, offset, limit, (rows:any[], totalCount:number) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows, totalCount);
			});
		}



		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			callback:(col:any[]) => void):void;

		public fetchCol():void
		{
			var u = kr3m.util.Util;

			var colName = <string> u.getFirstOfType(arguments, "string", 0, 0);
			var whereSql = <string> u.getFirstOfType(arguments, "string", 0, 1) || "1";
			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0) || 0;
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1) || 0;
			var ordering = <string[]> u.getFirstOfType(arguments, "object", 0, 1) || [];
			var distinct = <boolean> u.getFirstOfType(arguments, "boolean", 0, 0) || false;
			var callback = <(col:any[]) => void> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "fetchCol");

			if (!this.isColumnName(colName))
			{
				var error = "invalid column name for table tracks: " + colName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback([]);
			}

			whereSql = whereSql.replace(/^\s*where\s*/i, " ");
			var limitSql = (limit > 0 || offset > 0) ? " LIMIT " + offset + ", " + (offset + limit) : "";
			var orderSql = this.buildOrdering(ordering);
			var distinctSql = distinct ? "DISTINCT " : "";

			var sql = "SELECT " + distinctSql + "`" + colName + "` FROM `tracks` WHERE " + whereSql + orderSql + limitSql;
			db.fetchCol(sql, callback, errorCallback);
		}



		public fetchOne(
			colName:string,
			whereSql:string,
			callback:AnyCallback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "fetchOne");
			if (!this.isColumnName(colName))
			{
				var error = "invalid column name for table tracks: " + colName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback(undefined);
			}

			whereSql = whereSql.replace(/^\s*where\s*/i, " ");
			var sql = "SELECT `" + colName + "` FROM `tracks` WHERE " + whereSql + " LIMIT 1;";
			db.fetchOne(sql, callback, errorCallback);
		}



		public fetchPairs(
			keyName:string,
			valueName:string,
			whereSql:string,
			callback:(pairs:{[name:string]:any}) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "fetchPairs");
			if (!this.isColumnName(keyName))
			{
				var error = "invalid column name for table tracks: " + keyName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback([]);
			}

			if (!this.isColumnName(valueName))
			{
				var error = "invalid column name for table tracks: " + valueName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback([]);
			}

			if (keyName == valueName)
				valueName += "` AS `_" + valueName;

			whereSql = whereSql.replace(/^\s*where\s*/i, " ");
			var sql = "SELECT `" + keyName + "`, `" + valueName + "` FROM `tracks` WHERE " + whereSql;
			db.fetchPairs(sql, callback, errorCallback);
		}



		public deleteWhere(
			where:Object|string,
			callback?:(deletedCount:number) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "deleteWhere");
			db.deleteBatch("tracks", where, callback, errorCallback);
		}



		public getTableName():string
		{
			return "tracks";
		}



		/*
			Handles Dojo requests and returns a matching object.

			The WHERE statement can be extended using conditions
			and escapeArgs.
		*/
		public getDojo(
			params:any,
			callback:(forDojo:kr3m.dojo.GridQueryResponse<cuboro.tables.TrackVO>) => void,
			conditions:string[] = [],
			escapeArgs:any[] = [],
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getDojo");
			var columnNames = this.getColumnNames();

			var offset = params.start || 0;
			var limit = params.count || 20;
			var sort = params.sort || "id";

			for (var i = 0; i < columnNames.length; ++i)
			{
				if (params.hasOwnProperty(columnNames[i]) && params[columnNames[i]])
				{
					conditions.push("`" + columnNames[i] + "` = ?");
					escapeArgs.push(params[columnNames[i]]);
				}
			}
			var where = db.escape(conditions.join(" AND "), escapeArgs);
			if (where == "")
				where = "1";

			var ordering = [];
			if (sort.substring(0, 1) == "-")
				ordering.push(sort, "ASC");
			else
				ordering.push(sort, "DESC");

			this.getCount(where, (count:number) =>
			{
				this.get(where, offset, limit, ordering, (vos:any) => callback(new kr3m.dojo.GridQueryResponse<cuboro.tables.TrackVO>(vos, "id", count, "id", sort)), errorCallback);
			}, errorCallback);
		}



		public upsertBatch(
			vos:cuboro.tables.TrackVO[],
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "upsertBatch");
			for (var i = 0; i < vos.length; ++i)
				vos[i].preStore();

			db.upsertBatch("tracks", vos, () =>
			{
				for (var i = 0; i < vos.length; ++i)
					vos[i].postStore();

				callback && callback();
			}, db.defaultBatchSize, null, errorCallback);
		}



		public insertBatch(
			vos:cuboro.tables.TrackVO[],
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "insertBatch");
			for (var i = 0; i < vos.length; ++i)
				vos[i].preStore();

			db.insertBatch("tracks", vos, () =>
			{
				for (var i = 0; i < vos.length; ++i)
					vos[i].postStore();

				callback && callback();
			}, db.defaultBatchSize, errorCallback);
		}



		public getFreeName(
			callback:(name:string) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getFreeName");
			var name:string;
			kr3m.async.Loop.loop((loopDone) =>
			{
				kr3m.util.Rand.getSecureString(200, null, (secString) =>
				{
					name = secString;
					this.getByName(name, dummy => loopDone(!!dummy), errorCallback);
				});
			}, () => callback(name));
		}



		public getByCreatedWhen(
			createdWhen:Date,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `tracks` WHERE `createdWhen` = ?";
			sql = db.escape(sql, [createdWhen]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		/*
			Function for loading several objects at once based on their
			unique id.

			A map is returned that contains all found objects with the
			unique id as a key.
		*/
		public getByIds(
			ids:number[],
			callback:(vosById:{[id:number]:cuboro.tables.TrackVO}) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getByIds");
			if (ids.length == 0)
				return callback({});

			var sql = "SELECT * FROM `tracks` WHERE `id` IN (?)";
			sql = db.escape(sql, [ids]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(kr3m.util.Util.arrayToAssoc(rows, "id"));
			}, errorCallback);
		}



		public getById(
			id:number,
			callback:CB<cuboro.tables.TrackVO>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getById");
			var sql = "SELECT * FROM `tracks` WHERE `id` = ? LIMIT 0,1";
			sql = db.escape(sql, [id]);
			db.fetchRow(sql, (row) =>
			{
				if (!row)
					return callback(undefined);

				row.__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
				row.postLoad();
				callback(row);
			}, errorCallback);
		}



		/*
			Function for loading several objects at once based on their
			unique name.

			A map is returned that contains all found objects with the
			unique name as a key.
		*/
		public getByNames(
			names:string[],
			callback:(vosByName:{[name:string]:cuboro.tables.TrackVO}) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getByNames");
			if (names.length == 0)
				return callback({});

			var sql = "SELECT * FROM `tracks` WHERE `name` IN (?)";
			sql = db.escape(sql, [names]);
			db.fetchAll(sql, (rows) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(kr3m.util.Util.arrayToAssoc(rows, "name"));
			}, errorCallback);
		}



		public getByName(
			name:string,
			callback:CB<cuboro.tables.TrackVO>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getByName");
			var sql = "SELECT * FROM `tracks` WHERE `name` = ? LIMIT 0,1";
			sql = db.escape(sql, [name]);
			db.fetchRow(sql, (row) =>
			{
				if (!row)
					return callback(undefined);

				row.__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
				row.postLoad();
				callback(row);
			}, errorCallback);
		}



		public getByOwnerId(
			ownerId:number,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `tracks` WHERE `ownerId` = ?";
			sql = db.escape(sql, [ownerId]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getByPreviousId(
			previousId:number,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `tracks` WHERE `previousId` = ?";
			sql = db.escape(sql, [previousId]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getByRegionId(
			regionId:string,
			callback:CB<cuboro.tables.TrackVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `tracks` WHERE `regionId` = ?";
			sql = db.escape(sql, [regionId]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}
	}
}


var tTracks = new cuboro.tables.TracksTable();
