/*
	This file was automatically created using a source code generator.
	Do not edit this file manually as all changes will be overwritten
	the next time the generator runs again.
*/



/// <reference path="../../cuboro/tables/localizationvo.ts"/>
/// <reference path="../../kr3m/types.ts"/>
//# !CLIENT
/// <reference path="../../kr3m/util/factory.ts"/>
//# /!CLIENT



module cuboro.tables
{
	export class LocalizationsTable
	{
		public isColumnName(name:string):boolean
		{
			return (["field","itemId","itemType","locale","text"]).indexOf(name) >= 0;
		}



		public getColumnNames():string[]
		{
			return ["field","itemId","itemType","locale","text"];
		}



		/*
			Generates an ORDER BY string for mysql from the strings
			given in ordering.

			The parameter ordering can contain columnNames of the table
			or "asc" / "desc" (case is ignored). asc and desc will be
			added to the last columnName added before the asc / desc
			parameter.

			Values that are neither "asc", "desc" or a columnName will
			be silently ignored.

			Example:
				table.buildOrdering(["lastName", "firstName", "ASC", "age", "DESC"]);
		*/
		public buildOrdering(ordering:string[]):string
		{
			var parts:string[] = [];
			var ascDescRe = /^asc|desc$/i;
			for (var i = 0; i < ordering.length; ++i)
			{
				if (this.isColumnName(ordering[i]))
					parts.push(db.escapeId(ordering[i]));
				else if (ascDescRe.test(ordering[i]) && parts.length > 0)
					parts[parts.length - 1] += " " + ordering[i].toUpperCase();
			}
			return parts.length > 0 ? " ORDER BY " + parts.join(", ") : "";
		}



		public getCount(
			where:string,
			callback:NumberCallback,
			errorCallback:ErrorCallback):void;

		public getCount(
			where:string,
			callback:NumberCallback):void;

		public getCount(
			callback:NumberCallback,
			errorCallback:ErrorCallback):void;

		public getCount(
			callback:NumberCallback):void;

		public getCount():void
		{
			var u = kr3m.util.Util;

			var where = <string> u.getFirstOfType(arguments, "string", 0, 0) || "1";
			where = where.replace(/^\s*where\s*/i, " ");

			var callback = <(count:number) => void> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);

			var sql = "SELECT COUNT(*) FROM `localizations` WHERE " + where;
			db.fetchOne(sql, callback, errorCallback);
		}



		private wrapErrorCallback(
			errorCallback:ErrorCallback,
			functionName:string):ErrorCallback
		{
			if (!errorCallback)
				return errorCallback;

			var newCallback = (errorMessage) =>
			{
				errorCallback("cuboro.tables.LocalizationVO." + functionName + " - " + errorMessage);
			}
			return newCallback;
		}



		public get(
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:CB<cuboro.tables.LocalizationVO[]>):void;

		public get(
			whereSql:string,
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.LocalizationVO[]>):void;

		public get(
			whereSql:string,
			ordering:string[],
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			ordering:string[],
			callback:CB<cuboro.tables.LocalizationVO[]>):void;

		public get(
			whereSql:string,
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			whereSql:string,
			callback:CB<cuboro.tables.LocalizationVO[]>):void;

		public get(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			offset:number,
			limit:number,
			callback:CB<cuboro.tables.LocalizationVO[]>):void;

		public get(
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback:ErrorCallback):void;

		public get(
			callback:CB<cuboro.tables.LocalizationVO[]>):void;

		public get():void
		{
			var u = kr3m.util.Util;

			var whereSql = <string> u.getFirstOfType(arguments, "string", 0, 0) || "1";
			whereSql = whereSql.replace(/^\s*where\s*/i, " ");

			var callback = <CB<cuboro.tables.LocalizationVO[]>> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "get");

			var sql = "SELECT * FROM `localizations` WHERE " + whereSql;

			var ordering = <string[]> u.getFirstOfType(arguments, "object", 0, 0) || [];
			if (ordering.length > 0)
				sql += this.buildOrdering(ordering);

			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0) || 0;
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1) || 0;
			if (limit > 0)
				sql += db.escape(" LIMIT ?, ?", [offset, limit]);

			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getIterative(
			where:string,
			dataCallback:(vos:cuboro.tables.LocalizationVO[], callback:Callback) => void,
			doneCallback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getIterative");
			where = where.replace(/^\s*where\s*/i, " ");
			var sql = "SELECT * FROM `localizations` WHERE " + where;
			db.queryIterative(sql, (rows, nextBatch) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
					rows[i].postLoad();
				}
				dataCallback(rows, nextBatch);
			}, doneCallback, 20, errorCallback);
		}



		/*
			Saves the given objects into the table without and kind of checking.
		*/
		public updateRaw(
			rows:any[],
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "updateRaw");
			db.updateBatch("localizations", rows, callback, db.defaultBatchSize, "id", errorCallback);
		}



		/*
			Calls the function of the same name from kr3m.db.MySqlDb using this
			table's name and changing the result elements into VOs before returning
			them.

			Careful: if joins are used, the returned VOs may contain attributes that
			aren't defined in the class definition (in Typescript).
		*/
		public fetchPage(
			where:Object|string,
			orderBy:{col:string, asc:boolean}[],
			joins:{localCol:string, foreignCol:string, tableName:string}[],
			offset:number, limit:number,
			callback:(rows:any[], totalCount:number) => void):void
		{
			db.fetchPage("localizations", where, orderBy, joins, offset, limit, (rows:any[], totalCount:number) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
					rows[i].postLoad();
				}
				callback(rows, totalCount);
			});
		}



		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			offset:number,
			limit:number,
			ordering:string[],
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			callback:(col:any[]) => void,
			errorCallback:ErrorCallback):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			whereSql:string,
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			whereSql:string,
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			distinct:boolean,
			callback:(col:any[]) => void):void;

		public fetchCol(
			colName:string,
			callback:(col:any[]) => void):void;

		public fetchCol():void
		{
			var u = kr3m.util.Util;

			var colName = <string> u.getFirstOfType(arguments, "string", 0, 0);
			var whereSql = <string> u.getFirstOfType(arguments, "string", 0, 1) || "1";
			var offset = <number> u.getFirstOfType(arguments, "number", 0, 0) || 0;
			var limit = <number> u.getFirstOfType(arguments, "number", 0, 1) || 0;
			var ordering = <string[]> u.getFirstOfType(arguments, "object", 0, 1) || [];
			var distinct = <boolean> u.getFirstOfType(arguments, "boolean", 0, 0) || false;
			var callback = <(col:any[]) => void> u.getFirstOfType(arguments, "function", 0, 0);
			var errorCallback = <ErrorCallback> u.getFirstOfType(arguments, "function", 0, 1);
			errorCallback = this.wrapErrorCallback(errorCallback, "fetchCol");

			if (!this.isColumnName(colName))
			{
				var error = "invalid column name for table localizations: " + colName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback([]);
			}

			whereSql = whereSql.replace(/^\s*where\s*/i, " ");
			var limitSql = (limit > 0 || offset > 0) ? " LIMIT " + offset + ", " + (offset + limit) : "";
			var orderSql = this.buildOrdering(ordering);
			var distinctSql = distinct ? "DISTINCT " : "";

			var sql = "SELECT " + distinctSql + "`" + colName + "` FROM `localizations` WHERE " + whereSql + orderSql + limitSql;
			db.fetchCol(sql, callback, errorCallback);
		}



		public fetchOne(
			colName:string,
			whereSql:string,
			callback:AnyCallback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "fetchOne");
			if (!this.isColumnName(colName))
			{
				var error = "invalid column name for table localizations: " + colName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback(undefined);
			}

			whereSql = whereSql.replace(/^\s*where\s*/i, " ");
			var sql = "SELECT `" + colName + "` FROM `localizations` WHERE " + whereSql + " LIMIT 1;";
			db.fetchOne(sql, callback, errorCallback);
		}



		public fetchPairs(
			keyName:string,
			valueName:string,
			whereSql:string,
			callback:(pairs:{[name:string]:any}) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "fetchPairs");
			if (!this.isColumnName(keyName))
			{
				var error = "invalid column name for table localizations: " + keyName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback([]);
			}

			if (!this.isColumnName(valueName))
			{
				var error = "invalid column name for table localizations: " + valueName;
				if (errorCallback)
					return errorCallback(error);

				logError(error);
				return callback([]);
			}

			if (keyName == valueName)
				valueName += "` AS `_" + valueName;

			whereSql = whereSql.replace(/^\s*where\s*/i, " ");
			var sql = "SELECT `" + keyName + "`, `" + valueName + "` FROM `localizations` WHERE " + whereSql;
			db.fetchPairs(sql, callback, errorCallback);
		}



		public deleteWhere(
			where:Object|string,
			callback?:(deletedCount:number) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "deleteWhere");
			db.deleteBatch("localizations", where, callback, errorCallback);
		}



		public getTableName():string
		{
			return "localizations";
		}



		public upsertBatch(
			vos:cuboro.tables.LocalizationVO[],
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "upsertBatch");
			for (var i = 0; i < vos.length; ++i)
				vos[i].preStore();

			db.upsertBatch("localizations", vos, () =>
			{
				for (var i = 0; i < vos.length; ++i)
					vos[i].postStore();

				callback && callback();
			}, db.defaultBatchSize, null, errorCallback);
		}



		public insertBatch(
			vos:cuboro.tables.LocalizationVO[],
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "insertBatch");
			for (var i = 0; i < vos.length; ++i)
				vos[i].preStore();

			db.insertBatch("localizations", vos, () =>
			{
				for (var i = 0; i < vos.length; ++i)
					vos[i].postStore();

				callback && callback();
			}, db.defaultBatchSize, errorCallback);
		}



		public getByLocale(
			locale:string,
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `localizations` WHERE `locale` = ?";
			sql = db.escape(sql, [locale]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getByLocaleItemType(
			locale:string,
			itemType:string,
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `localizations` WHERE `locale` = ? AND `itemType` = ?";
			sql = db.escape(sql, [locale, itemType]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getByLocaleItemTypeItemId(
			locale:string,
			itemType:string,
			itemId:number,
			callback:CB<cuboro.tables.LocalizationVO[]>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "finderName");
			var sql = "SELECT * FROM `localizations` WHERE `locale` = ? AND `itemType` = ? AND `itemId` = ?";
			sql = db.escape(sql, [locale, itemType, itemId]);
			db.fetchAll(sql, (rows:any[]) =>
			{
				for (var i = 0; i < rows.length; ++i)
				{
					rows[i].__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
					rows[i].postLoad();
				}
				callback(rows);
			}, errorCallback);
		}



		public getByLocaleItemTypeItemIdField(
			locale:string,
			itemType:string,
			itemId:number,
			field:string,
			callback:CB<cuboro.tables.LocalizationVO>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getByLocaleItemTypeItemIdField");
			var sql = "SELECT * FROM `localizations` WHERE `locale` = ? AND `itemType` = ? AND `itemId` = ? AND `field` = ? LIMIT 0,1";
			sql = db.escape(sql, [locale, itemType, itemId, field]);
			db.fetchRow(sql, (row) =>
			{
				if (!row)
					return callback(undefined);

				row.__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.LocalizationVO).prototype;
				row.postLoad();
				callback(row);
			}, errorCallback);
		}
	}
}


var tLocalizations = new cuboro.tables.LocalizationsTable();
