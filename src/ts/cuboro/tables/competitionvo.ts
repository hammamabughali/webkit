/*
	This file was automatically created using a source code generator.
	Do not edit this file manually as all changes will be overwritten
	the next time the generator runs again.
*/



/// <reference path="../../cuboro/tables/regionvariantvo.ts"/>
/// <reference path="../../cuboro/tables/trackvo.ts"/>
/// <reference path="../../kr3m/types.ts"/>
//# !CLIENT
/// <reference path="../../kr3m/services/paramshelper.ts"/>
/// <reference path="../../kr3m/util/factory.ts"/>
//# /!CLIENT



module cuboro.tables
{
	export class CompetitionVO
	{
		public static NAME_INTERNAL_MAX_LENGTH = 128;
		public static NAME_INTERNAL_MAX_LENGTH_SECURE = 64;

		public static REGION_ID_MAX_LENGTH = 16;
		public static REGION_ID_MAX_LENGTH_SECURE = 8;



		public baseTrackId:number = null; // int unsigned
		public enabled:boolean = true;
		public ends:Date; // datetime
		public fixedParticipants:boolean = false;
		public id:number; // int unsigned
		public isPublic:boolean = false;
		public layers:number = 9; // int unsigned
		public mayApply:boolean = false;
		public minScore:number = 0; // int unsigned
		public nameInternal:string; // varchar(128)
		public regionId:string; // varchar(16)
		public starts:Date; // datetime
//# !CLIENT



		public static isColumnName(name:string):boolean
		{
			return (["baseTrackId","enabled","ends","fixedParticipants","id","isPublic","layers","mayApply","minScore","nameInternal","regionId","starts"]).indexOf(name) >= 0;
		}



		public static getColumnNames():string[]
		{
			return ["baseTrackId","enabled","ends","fixedParticipants","id","isPublic","layers","mayApply","minScore","nameInternal","regionId","starts"];
		}



		/*
			Builds a proper cuboro.tables.CompetitionVO class object from
			a POD / JSON object.

			If this is not possible, because some required attributes
			are missing for example, null will be returned.
		*/
		public static buildFrom(raw:any):cuboro.tables.CompetitionVO
		{
			var helper = new kr3m.services.ParamsHelper(raw);
			if (!helper.validate({"baseTrackId":"number","enabled":"boolean","ends":"Date","fixedParticipants":"boolean","id":"number","isPublic":"boolean","layers":"number","mayApply":"boolean","minScore":"number","nameInternal":"string","regionId":"string","starts":"Date"}, {"baseTrackId":null,"enabled":"true","fixedParticipants":"false","isPublic":"false","layers":"9","mayApply":"false","minScore":"0"}))
				return null;

			var foreignKeyNames = ["baseTrackId","regionId"];
			var vo = new cuboro.tables.CompetitionVO();
			var copyFields = ["baseTrackId","enabled","ends","fixedParticipants","id","isPublic","layers","mayApply","minScore","nameInternal","regionId","starts"];
			for (var i = 0; i < copyFields.length; ++i)
			{
				vo[copyFields[i]] = raw[copyFields[i]];
				if (!vo[copyFields[i]] && kr3m.util.Util.contains(foreignKeyNames, copyFields[i]))
					vo[copyFields[i]] = null;
			}
			return vo;
		}



		public constructor(rawData?:any)
		{
			if (rawData)
			{
				for (var i in rawData)
				{
					if (cuboro.tables.CompetitionVO.isColumnName(i))
						this[i] = rawData[i];
				}
			}
		}



		private wrapErrorCallback(
			errorCallback:ErrorCallback,
			functionName:string):ErrorCallback
		{
			if (!errorCallback)
				return errorCallback;

			var newCallback = (errorMessage) =>
			{
				errorCallback("cuboro.tables.CompetitionVO." + functionName + " - " + errorMessage);
			}
			return newCallback;
		}



		/*
			Will be called after the class was created and filled
			with content from the database.
		*/
		public postLoad():void
		{
			// can be overwritten in derived classes
		}



		/*
			Will be called before the class' content will be
			written into the database.
		*/
		public preStore():void
		{
			// can be overwritten in derived classes
		}



		/*
			Will be called after the class' content was
			written into the database.
		*/
		public postStore():void
		{
			// can be overwritten in derived classes
		}



		public insert(
			callback?:(insertedId:number) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "insert");
			this.preStore();
			db.insert("competitions", this, (insertedId:number) =>
			{
				this.id = insertedId;
				this.postStore();
				callback && callback(insertedId);
			}, errorCallback);
		}



		public upsert(
			callback?:(insertedId:number) => void,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "upsert");
			this.preStore();
			db.upsert("competitions", this, (insertedId:number) =>
			{
				this.id = insertedId || this.id;
				this.postStore();
				callback && callback(insertedId);
			}, null, errorCallback);
		}



		public update(
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "update");
			this.preStore();
			db.update("competitions", this, () =>
			{
				this.postStore();
				callback && callback();
			}, "id", errorCallback);
		}



		public delete(
			callback?:Callback,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "delete");
			var where = db.escape("id = ?", [this.id]);
			db.deleteBatch("competitions", where, callback, errorCallback);
		}



		public getBaseTrack(
			callback:CB<cuboro.tables.TrackVO>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getBaseTrack");
			var sql = "SELECT * FROM `tracks` WHERE `id` = ? LIMIT 0,1";
			sql = db.escape(sql, [this.baseTrackId]);
			db.fetchRow(sql, (data) =>
			{
				if (!data)
					return callback(undefined);

				data.__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.TrackVO).prototype;
				data.postLoad();
				callback(data);
			}, errorCallback);
		}



		public getRegion(
			callback:CB<cuboro.tables.RegionVariantVO>,
			errorCallback?:ErrorCallback):void
		{
			errorCallback = this.wrapErrorCallback(errorCallback, "getRegion");
			var sql = "SELECT * FROM `region_variants` WHERE `id` = ? LIMIT 0,1";
			sql = db.escape(sql, [this.regionId]);
			db.fetchRow(sql, (data) =>
			{
				if (!data)
					return callback(undefined);

				data.__proto__ = kr3m.util.Factory.getInstance().map(cuboro.tables.RegionVariantVO).prototype;
				data.postLoad();
				callback(data);
			}, errorCallback);
		}

//# /!CLIENT
	}
}
