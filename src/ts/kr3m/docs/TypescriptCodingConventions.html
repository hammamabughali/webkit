<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="X-UA-Compatible" content="IE=edge">
		<meta charset="utf-8">
		<title>kr3m Typescript Coding Conventions</title>
	</head>
	<body>
		<style>
			body {padding: 1em;}

			h1, h2
			{
				background-color: #7f0000;
				border-radius: 0.5em;
				box-shadow: lightgrey 0.125em 0.125em;
				color: white;
				padding: 0.5em;
			}

			h1 {font-size: 1.5em;}
			h2
			{
				font-size: 1.25em;
				margin-top: 3em;
			}

			dt {font-weight: bold;}
			dd {margin-bottom: 1em;}

			pre
			{
				overflow: auto;
				tab-size: 2;
			}

			.example
			{
				background-color: #efefef;
				border: solid black 1px;
				padding: 1em;
			}

			.dont
			{
				background-color: #ffdfdf;
				border: solid black 1px;
				padding: 1em;
				max-width: 35vw;
			}

			.do
			{
				background-color: #dfffdf;
				border: solid black 1px;
				padding: 1em;
				max-width: 35vw;
			}

			.dontdo td
			{
				vertical-align: top;
			}
		</style>



		<h1>kr3m Typescript Coding Conventions</h1>

		<p>This document contains a detailed description of how the Typescript
		source code in kr3m's projects is to be formatted and written in order
		to ease the access for other developers working in and for that
		company. Those guidelines are based on common best-practices in order
		to increase readability of source code.</p>

		<p>All rules in this document are subject to change. This version
		of this document was last updated on <b style="color:red">31.08.2017</b>.
		The <a href="https://cas-dev.das-onlinespiel.de/doc/TypescriptCodingConventions.html">
		latest version of this document can be found here</a>. If you have any
		questions or suggestions contact <a href="mailto:jan.minar@kr3m.com">Jan Minar</a>.</p>



		<h2>Names and Identifiers</h2>

		<dl>

			<dt>Use Camel Case (unless noted otherwise)</dt>
			<dd>Use <a target="_blank" href="https://en.wikipedia.org/wiki/Camel_case">Camel Case</a>
			for names and identifiers.</dd>

			<dt>Class Names and custom types</dt>
			<dd>All class names and custom types begin with a capital letter (upper
			camel case).</dd>

			<dt>Function and method names</dt>
			<dd>All function and method names start with a lowercase letter (lower
			camel case). Function and method names should be verbs that properly
			reflect what the function does, optionally with objects appended to
			that verb.</dd>

			<dt>Variable and attributes names</dt>
			<dd>Variable and class attribute names start with a lowercase letter
			(lower camel case) and should easily describe what data is contained
			in that variable. Arrays, lists and other containers should be the
			plural form of the data stored in it.</dd>

			<dt>Don't use the Hungarian notation or anything like it</dt>
			<dd>Do not use the <a target="_blank" href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian
			Notation</a> or anything like it. This also means that there is no
			prefix for (private) class variables. There is one exception to this last
			statement: if working on code that will be compiled to Ecmascript 5 or higher
			and you're using getters and / or setters for a class attribute you may
			prefix the variable with an underscore character to prevent name conflicts
			with the getter and setter for that variable.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
class A
{
	private _dirty:boolean;
	public mName:string;

	private mAge:number;

	public get age():number
	{
		return this.mAge;
	}
}
				</pre></td><td><pre class="do">
class A
{
	private dirty:boolean;
	public name:string;

	private _Age:number; // the one exception to the rule

	public get age():number
	{
		return this._Age;
	}
}
				</pre></td></tr></table>
			</dd>

			<dt>Constants</dt>
			<dd>Constants don't use camel case but are written completely in
			uppercase letters, words seperated by an underscore character.</dd>
		</dl>



		<h2>Files</h2>

		<dl>

			<dt>One class per file</dt>
			<dd>There should be only one exported class per source-file. The
			exceptions to this are classes that are not exported from the
			corresponding module or extremely small helper classes. The files'
			names also have to match the exported class name except for
			writing style.</dd>

			<dt>Module names should match folder names</dt>
			<dd>Although this is not strictly necessary in Typescript, a file's
			location in the folder structure should match its module.
				<pre class="example">
// this should be contained in the file pg2/models/jobs/publishinstance.ts
module pg2.models.jobs
{
	export class PublishInstance
	{
		// ...
	}
}
				</pre>
			</dd>

			<dt>Lowercase file and folder names</dt>
			<dd>File and folder names are to be written completely lowercase
			without any special characters to denote word seperation.</dd>

			<dt>Use relative paths to the src folder in references</dt>
			<dd>To make it easier to see, which required files are already referenced
			and which are missing, base the paths in the reference tag on the src
			folder.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
/// &lt;reference path="../tables/accountvo.ts"/&gt;
/// &lt;reference path="participation.ts"/&gt;

module cas.vo
{
	// ...
}
				</pre></td><td><pre class="do">
/// &lt;reference path="../../cas/tables/accountvo.ts"/&gt;
/// &lt;reference path="../../cas/vo/participation.ts"/&gt;

module cas.vo
{
	// ...
}
				</pre></td></tr></table>
			</dd>

			<dt>Use references where needed, not all in one place</dt>
			<dd>Each file should have references to all other files itself needs. There shouldn't
			be one global list of requires for everthing in the project.</dd>

			<dt>Use module-prefixes when using identifiers from another (sub-)module</dt>
			<dd>When using a type, class, variable, etc. from another module, use the
			complete module path prefix with the identifier, even if the current module is
			a sub-module of the module the used identifier is from.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
module pets
{
	export class A
	{
		// ...
	}
}

module pets.hamsters
{
	export class B extends A
	{
		// ...
	}
}
				</pre></td><td><pre class="do">
module pets
{
	export class A
	{
		// ...
	}
}

module pets.hamsters
{
	export class B extends pets.A
	{
		// ...
	}
}
				</pre></td></tr></table>
			</dd>

			<dt>Omit module prefixes when using identifiers from the exact same (sub-)module</dt>
			<dd>Omit the module prefixes if a used type, class, variable, etc. is from the
			very same module as the location where it is used.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
module pets
{
	export class A
	{
		// ...
	}



	export class B extends pets.A
	{
		// ...
	}
}
				</pre></td><td><pre class="do">
module pets
{
	export class A
	{
		// ...
	}



	export class B extends A
	{
		// ...
	}
}
				</pre></td></tr></table>
			</dd>

		</dl>



		<h2>Types</h2>

		<dl>

			<dt>Always add types where Typescript can not infer them automatically</dt>
			<dd>Typescript is quite good at infering types automatically. The number
			of cases where it can't do so shrinks with each release of the Typescript
			compiler. This <a target="_blank" href="https://www.typescriptlang.org/docs/handbook/type-inference.html">documentation</a>
			describes how types are inferred in Typescript. In those cases where it can't
			do so on its own, please add types to variables and functions.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
// type is any[], should be string[]
var names = [];

// type is inferred from value 3
var count:number = 3;

// type is inferred from function's return type
var users:User[] = getUsers();

// a and b's types are inferred
names.sort((a:string, b:string) => a.localeCompare(b));

// the current TSC can't infer the types of several inbuilt node.js modules
fsLib.readFile("server.log", (err, content) => log(content));
				</pre></td><td><pre class="do">
// type is string[]
var names:string[] = [];

// type is inferred from value 3
var count = 3;

// type is inferred from function's return type
var users = getUsers();

// a and b's types are inferred
names.sort((a, b) => a.localeCompare(b));

// the current TSC can't infer the types of several inbuilt node.js modules
fsLib.readFile("server.log", (err:Error, content:string) => log(content));
				</pre></td></tr></table>
			</dd>

			<dt>Avoid the any-type</dt>
			<dd>Typescripts any-type is the default type assigned to all variables
			that have an unknown type. Basically it tells the compiler to ignore
			all semantic checking on that variable. This usually results in errors
			occuring during runtime instead of during compile-time. Therefore, the
			any type should be avoided if at all possible.</dd>

			<dt>Avoid implicit any-types</dt>
			<dd>If no type is given for a variable and no type can be inferred
			by Typescript, then a variable is considered to be of the any-type. This
			is should be prevented.</dd>

		</dl>



		<h2>Whitespaces and Formatting</h2>

		<dl>

			<dt>Encoding</dt>
			<dd>All files are encoded using UTF-8 including BOM (byte order mark). Use Unix-type
			End-Of-Lines ("\n" instead of "\r\n").</dd>

			<dt>Tabs for Indentation</dt>
			<dd>All line indentations are to be done using tabs, not spaces.</dd>

			<dt>No space inside Braces, Brackets and Parentheses</dt>
			<dd>Don't put spaces immediately inside (right of opening, left of closing) braces,
			brackets and parentheses.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
var params = { a : 1, b : 2 };
var ages = [ 1, 2, 3, 4, 5, 6 ];
var total = ( a + b );
				</pre></td><td><pre class="do">
var params = {a : 1, b : 2};
var ages = [1, 2, 3, 4, 5, 6];
var total = (a + b);
				</pre></td></tr></table>
			</dd>

			<dt>Spaces</dt>
			<dd>Use single spaces to seperate operators and built in Typescript command
			words from their context. The exception are unary operands like ! (not), ++ and
			-- (pre- and postfix).
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
var a=b+c;
var a = ! b;
				</pre></td><td><pre class="do">
var a = b + c;
var a = !b;
				</pre></td></tr></table>
			Never use spaces left of commas / semi-colons, but always put a space on the right
			side of a comma / semi-colon (unless at the end of line).
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
for(var i=0;i&lt;len;++i)
{
	// ...
}
				</pre></td><td><pre class="do">
for (var i = 0; i &lt; len; ++i)
{
	// ...
}
				</pre></td></tr></table>
			<del>
			Treat a colon as a normal operator unless it is used for a type defition - then omit
			all spaces.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
var params = {a:1, b:2, c:3};
var name : string = "Hamster";
				</pre></td><td><pre class="do">
var params = {a : 1, b : 2, c : 3};
var name:string = "Hamster";
				</pre></td></tr></table>
			</del>

			Don't put spaces between function- / method-names and parentheses.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
function echo (text:string):void
{
	// ...
}

echo ("hello world");
				</pre></td><td><pre class="do">
function echo(text:string):void
{
	// ...
}

echo("hello world");
				</pre></td></tr></table>
			</dd>

			<dt>Between Functions</dt>
			<dd>Functions are seperated from each other using three empty lines. This
			also applies to other areas where a group of entities is seperated from
			another group. For example classes are seperated from each other using
			three empty lines or class attribute definitions from class methods.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
function a():void
{
	...
}

function b():void
{
	...
}

function c():void
{
	...
}
				</pre></td><td><pre class="do">
function a():void
{
	...
}



function b():void
{
	...
}



function c():void
{
	...
}
				</pre></td></tr></table>
			</dd>

			<dt>Grouping</dt>
			<dd>Code can be grouped inside a function call by using single empty lines.
			There should never be more than one single successive empty line inside
			a function body.</dd>

			<dt>Opening and Closing Braces</dt>
			<dd>Braces opening or closing blocks of code are placed on a new line
			with an indentation equal to the surrounding code. Opening braces are
			never placed at the end of a line or statement. Code inside a code block
			is indented with one tab more than the surrounding code.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
if (!user) {
	log("user not logged in");
	return;
}
				</pre></td><td><pre class="do">
if (!user)
{
	log("user not logged in");
	return;
}
				</pre></td></tr></table>
			</dd>

			<dt>Don't use braces for single-statement code blocks...</dt>
			<dd>If you're using an if-statement or a loop, don't put the branches
			or loop body into braces if it only contains one statement line
			(see next entry for exception).
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
for (var i = 0; i < 10; ++i)
{
	log("i is now", i);
}

if (a > b)
{
	log("a is bigger than b");
}
				</pre></td><td><pre class="do">
for (var i = 0; i < 10; ++i)
	log("i is now", i);

if (a > b)
	log("a is bigger than b");
				</pre></td></tr></table>
			</dd>

			<dt>...unless the other conditional branches are multi-statement blocks</dt>
			<dd>If the other branch in an if-statement contains more than one line, also
			put the single-line blocks in braces.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
if (a > b)
	log("a is bigger than b");
else
{
	log("no, its not");
	return;
}
				</pre></td><td><pre class="do">
if (a > b)
{
	log("a is bigger than b");
}
else
{
	log("no, its not");
	return;
}
				</pre></td></tr></table>
			</dd>

			<dt>Leading (Logical) Operators in Conditions</dt>
			</dd>If you break long conditions into multiple lines put the operators at
			the start of the new line.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
if (a == 1 &&
	b == 2 &&
	c == 3 &&
	d == 4)
{
	//...
}
				</pre></td><td><pre class="do">
if (a == 1
	&& b == 2
	&& c == 3
	&& d == 4)
{
	//...
}
				</pre></td></tr></table>
			</dd>

			<dt>Avoid too long function bodies</dt>
			<dd>If a function body is too long, break it down into several smaller
			functions. There is no hard rule how long is too long, but a rule of
			thumb: if the entire function body is longer than your screen can
			display at once, it is too long. If you use a 27 inch monitor with
			vertical orientation, please use common sense.</dd>

		</dl>



		<h2>Functions Signatures</h2>

		<dl>

			<dt>Always add a functions return type</dt>
			<dd>All functions must have a proper return type. Don't omit void
			on functions not returning anything. Also, use a return type for
			functions that do return date, even though Typescript can infer it.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
function doSomething()
{
	// ...
}

function getAge()
{
	return 42;
}
				</pre></td><td><pre class="do">
function doSomething():void
{
	// ...
}

function getAge():number
{
	return 42;
}
				</pre></td></tr></table>
			</dd>

			<dt>All parameters must be typed</dt>
			<dd>Although its possible to omit paramter types in function signatures,
			do use types for all of them.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
function saveUser(user):void
{
	// ...
}
				</pre></td><td><pre class="do">
function saveUser(user:User):void
{
	// ...
}
				</pre></td></tr></table>
			</dd>

			<dt>Avoid too long function signatures in one line</dt>
			<dd>If the entire function signature is wider than your screen can display
			(use common sense), break it into multiple lines. Put each parameter into
			a new line unless the parameters really belong together semantically. Indent
			the lines with parameters by one more tab than the function name. If using
			multiple lines for a function signature, place the first parameter in a new
			line.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
function drawRectangle(x:number, y:number, w:number, h:number, fillColor:Color, boundaryColor:Color):void
{
	// ...
}

function drawRectangle(x:number, y:number,
                       w:number, h:number,
                       fillColor:Color,
                       boundaryColor:Color):void
{
	// ...
}
				</pre></td><td><pre class="do">
function drawRectangle(
	x:number, y:number,
	w:number, h:number,
	fillColor:Color,
	boundaryColor:Color):void
{
	// ...
}
				</pre></td></tr></table>
			</dd>

		</dl>



		<h2>Function Calling</h2>

		<dl>

			<dt>Arrow Functions for Anonymous Functions</dt>
			<dd>Use arrow functions for anonymous functions of any type: callbacks,
			listeners, handlers, comparefunctions, etc.</dd>

			<dt>Omit Parentheses on One-Parameter-One-Line Arrow Functions</dt>
			<dd>If an anonymous function takes only one parameter and can be written
			into a single line, omit the parentheses left of the arrow. Use parentheses
			every else arrow functions are used.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
users.filter((user) => user.age > 18);

users.filter(user =>
{
	// ...
});
				</pre></td><td><pre class="do">
users.filter(user => user.age > 18);

users.filter((user) =>
{
	// ...
});
				</pre></td></tr></table>
			</dd>

			<dt>Don't return results with too long syntax</dt>
			<dd>If the result to be returned from a function call doesn't fit into the one line
			containing the return keyword, store the result in a variable and return that. Or in
			other words: try to prevent synchronous code below the return statement returning that
			code's result.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
return
{
	firstname : "Hans",
	lastname : "Wurst"
}
				</pre></td><td><pre class="do">
var user =
{
	firstname : "Hans",
	lastname : "Wurst"
}
return user;
				</pre></td></tr></table>
			</dd>

		</dl>

		<dl>
		<h2>Comments</h2>

		<dl>

			<dt>Use English comments</dt>
			<dd>Currently all of our source code is commented in German. That is
			now outdated. Please use English comments in the source code.</dd>

			<dt>Don't use redundant comments</dt>
			<dd>If a comment only contains information that is easily available
			from the source code, remove that comment. If it contains additional
			information, keep it.
				<table class="dontdo"><tr><th>Don't</th><th>Do</th></tr><tr><td><pre class="dont">
// this function creates a new user
function createUser():void;

// calculate the sum of all expenses
var total = spentA + spentB + spentC;
				</pre></td><td><pre class="do">
// Get the total running duration (in ms).
function getDuration():number;
				</pre></td></tr></table>
			</dd>

			<dt>Avoid wrong comments</dt>
			<dd>Wrong comments are worse than no comments. If a piece of code is
			changed, check whether the comments are still correct. If the comments
			are no longer correct, update the comments or at least delete them to
			avoid confusion.</dd>

			<dt>Only single-line comments in function bodies</dt>
			<dd>Only use single line comments to describe parts of functions.</dd>

			<dt>Multi-line comments for class or function descriptions</dt>
			<dd>Use multi-line comments to describe how classes and functions
			work or what they do. <del>Do not use javadoc-style-comments to do so, just
			/* and */ . </del> Do use
			<a href="https://en.wikipedia.org/wiki/Javadoc" target="_blank">JavaDoc</a>
			syntax for larger comment blocks.</dd>

			<dt>Comment a function if its name doesn't properly reflect what it does</dt>
			<dd>A function called saveToFile() propably doesn't need a comment. But if
			that function also updates some related database entries, this should be noted
			in the comments. If a function does more or something different than one
			might expect from its name (and signature) only, there definately should be
			a comment about that.</dd>

		</dl>



		<h2>kr3m Precompiler</h2>

		At kr3m we use a custom precompiler to process all Typescript files before
		they are sent to the compiler. The main reason for this is that we reuse
		the same code on the client and server sides of our applications and there
		are parts in the code we do not want to have in both. As long as Typescript
		doesn't support conditional compilation, we will use that precompiler. Here
		are a few things to watch out for when using the compiler. Note: precompiler
		directives always start with //# (two slashes followed by a hash sign), so
		they are treated as single-line-comments by most IDEs. The behaviour can be
		inversed if the ID is prefixed with an exclamation mark.

		<dl>

			<dt>Conditional Compilation</dt>
			<dd>The pair "//# ID" and "//# /ID" can be used for conditional compilation.
			Code between those two entities is only used if the precompiler is run
			with the -f parameter followed by ID.
				<pre class="example">
//# CLIENT
	// this part is only used when compiling the code with "-f CLIENT"
//# /CLIENT

	// this part is always used

//# !CLIENT
	// this part is only used when compiling the code without "-f CLIENT"
//# /!CLIENT
				</pre>
			</dd>

			<dt>Precompiler Comments</dt>
			<dd>The precompiler directives TODO, FIXME and ERROR can be used to display
			information to developers during compilation time. If the precompiler is run
			with the "-c" parameter, the text behind those directives will be displayed
			during compilation.
				<pre class="example">
//# TODO: we might fix this, but it's not important
//# FIXME: we really should fix this, it's required in a proper working product
//# ERROR: this is really broken, abort compilation with an error message
				</pre>
			</dd>

			<dt>Embedding files in code</dt>
			<dd>The EMBED precompiler directive replaces itself with the content
			of another file, formatted as required.
				<pre class="example">
// take icon.png, convert it to a dataUrl and write it into the source code
var iconDataUrl = "//# EMBED(icon.png, dataUrl)";

// take the content of startup.js, encode it as a json-object and write it into the source code
var startupScript = //# EMBED(startup.js, json);
				</pre>
			</dd>

		</dl>

		<script>

			function addSyntaxHighlighting()
			{
				var pres = document.getElementsByTagName("pre");
				for (var i = 0; i < pres.length; ++i)
				{
					var code = pres[i].innerHTML;
					var lines = code.split(/\r?\n/);
					for (var j = 0; j < lines.length; ++j)
					{
						var parts = lines[j].split("//");
						lines[j] = parts[0]
							.replace(/:(\w+)\b/g, ":<span style='color:orange'>$1</span>")
							.replace(/\b(private|protected|extends|implements|public|class|export|module|var|function|for|if|return|else)\b/g, "<span style='color:blue'>$1</span>")

						if (parts.length > 1)
							lines[j] += "<span style='color:magenta'>//" + parts.slice(1).join("//") + "</span>";
					}
					code = lines.join("\n");
					pres[i].innerHTML = code;
				}
			}

			addSyntaxHighlighting();

		</script>

	</body>
</html>
