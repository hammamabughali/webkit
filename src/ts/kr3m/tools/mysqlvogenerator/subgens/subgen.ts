/// <reference path="../../../constants.ts"/>
/// <reference path="../../../db/mysqldb.ts"/>
/// <reference path="../../../lib/node.ts"/>
/// <reference path="../../../tools/autoformatter/autoformatter.ts"/>
/// <reference path="../../../tools/mysqlvogenerator/parameters.ts"/>
/// <reference path="../../../types.ts"/>
/// <reference path="../../../util/file.ts"/>
/// <reference path="../../../util/log.ts"/>
/// <reference path="../../../util/stringex.ts"/>
/// <reference path="../../../util/tokenizer.ts"/>
/// <reference path="../../../util/util.ts"/>



module kr3m.tools.mysqlvogenerator.subgens
{
	export class SubGen
	{
		public static typePatterns =
		{
			"boolean":
			[
				/^enum\((?:'false','true'|'true','false')\)$/
			],
			"string":
			[
				/^(varchar\(\d+\))$/,
				/^(char\(\d+\))$/,
				/^(enum\(.+\))$/,
				/^(set\(.+\))$/,
				/^(tinytext)$/,
				/^(mediumtext)$/,
				/^(text)$/,
				/^(longtext)$/
			],
			"number":
			[
				/^(int)\(\d+\)$/,
				/^(int)\(\d+\) (unsigned)$/,
				/^(tinyint)\(\d+\)$/,
				/^(tinyint)\(\d+\) (unsigned)$/,
				/^(bigint)\(\d+\)$/,
				/^(bigint)\(\d+\) (unsigned)$/,
				/^(float)$/
			],
			"Date":
			[
				/^(date)$/,
				/^(datetime)$/,
				/^(timestamp)$/
			],
			"NodeBuffer":
			[
				/^(tinyblob)$/,
				/^(mediumblob)$/,
				/^(blob)$/,
				/^(longblob)$/
			]
		};



		public db:kr3m.db.MySqlDb;
		public params:kr3m.tools.mysqlvogenerator.Parameters;
		public output:string;
		public references:{path:string, conditionals:string[]}[];



		constructor(db:kr3m.db.MySqlDb, params:kr3m.tools.mysqlvogenerator.Parameters)
		{
			this.db = db;
			this.params = params;
			this.output = "";
			this.references = [];

			this.addGlobalReference("kr3m/util/factory.ts", ["!CLIENT"]);
			this.addGlobalReference("kr3m/types.ts", []);
		}



		public addGlobalReference(absPath:string, conditionals:string[]):void
		{
			var depth = this.params.moduleName.split(".").length;
			var prefix = "";
			for (var i = 0; i < depth; ++i)
				prefix = "../" + prefix;

			this.references.push({path : prefix + absPath, conditionals : conditionals});
		}



		public addLocalReference(localPath:string):void
		{
			localPath = localPath.toLowerCase();
			var depth = this.params.moduleName.split(".").length;
			var modulePath = this.params.moduleName.replace(/\./g, "/");
			var prefix = "";
			for (var i = 0; i < depth; ++i)
				prefix = "../" + prefix;

			this.references.push({path : prefix + modulePath + "/" + localPath, conditionals : []});
		}



		public logSep():void
		{
			log("-------------------------------------------------------------");
		}



		public getClassName(tableName):string
		{
			var name = tableName.toLowerCase();
			name = name.slice(0, 1).toUpperCase() + name.slice(1);
			var i = name.indexOf("_");
			while (i >= 0)
			{
				if (i <= name.length - 1)
					name = name.slice(0, i) + name.slice(i + 1, i + 2).toUpperCase() + name.slice(i + 2);
				else
					name = name.slice(0, i) + name.slice(i + 1);
				i = name.indexOf("_");
			}
			return name;
		}



		public generate(callback:Callback):void
		{
			callback();
		}



		public singular(name:string):string
		{
			if (name.slice(-7).toLowerCase() == "cookies")
				return name.slice(0, -1);

			if (name.slice(-3) == "ies")
				return name.slice(0, -3) + "y";

			if (name.slice(-1) == "s")
				return name.slice(0, -1);

			return name;
		}



		public plural(name:string):string
		{
			return name + "s";
		}



		public generateStart():void
		{
			this.out("/*");
			this.out("	This file was automatically created using a source code generator.");
			this.out("	Do not edit this file manually as all changes will be overwritten");
			this.out("	the next time the generator runs again.");
			this.out("*/");
			this.out("\REFERENCEPLACEHOLDER\n");
			this.out("\n\n");
		}



		public getPropertyType(type:string):string
		{
			var pats = kr3m.tools.mysqlvogenerator.subgens.SubGen.typePatterns;
			for (var i in pats)
			{
				for (var j = 0; j < pats[i].length; ++j)
				{
					var pat:RegExp = pats[i][j];
					if (pat.test(type))
						return i;
				}
			}
			log("unknown type: " + type);
			return "any";
		}



		public capitalKeys(keys:string[]):string[]
		{
			var result = keys.slice();
			for (var i = 0; i < result.length; ++i)
				result[i] = result[i].slice(0, 1).toUpperCase() + result[i].slice(1);
			return result;
		}



		public out(text:string, tokens?:any):void
		{
			this.output += tokenize((text + "\n").replace(/\r/g, ""), tokens);
		}



		private realpath(path:string):string
		{
			try
			{
				return fsLib.realpathSync(path);
			}
			catch(e)
			{
				return path;
			}
		}



		private removeObsoleteConditionals(referenceText:string):string
		{
			var allConditionals:string[] = this.references.map(r => r.conditionals).reduce((t, m) => t.concat(m), []);
			allConditionals = kr3m.util.Util.removeDuplicates(allConditionals);
			var oldReferenceText:string;
			while (oldReferenceText != referenceText)
			{
				oldReferenceText = referenceText;
				for (var i = 0; i < allConditionals.length; ++i)
					referenceText = kr3m.util.StringEx.literalReplace(referenceText, "\n/" + "/# /" + allConditionals[i] + "\n/" + "/# " + allConditionals[i], "");
			}
			return referenceText;
		}



		public saveToFile(path:string):void
		{
			var referenceText = "";
			if (this.references.length > 0)
			{
				referenceText = "\n\n";
				this.references.sort((a, b) => (a.conditionals.length == b.conditionals.length) ? a.path.localeCompare(b.path) : a.conditionals.length - b.conditionals.length);

				var realPath = this.realpath(path);
				for (var i = 0; i < this.references.length; ++i)
				{
					var refPath = kr3m.util.File.resolvePath(path, this.references[i].path);
					if (realPath == this.realpath(refPath))
					{
						this.references.splice(i--, 1);
						continue;
					}

					var doContinue = false;
					for (var j = 0; j < i; ++j)
					{
						if (this.references[i].path == this.references[j].path)
						{
							this.references[i].conditionals.sort((a, b) => a.localeCompare(b));
							this.references[j].conditionals.sort((a, b) => a.localeCompare(b));

							var inter = kr3m.util.Util.intersect(this.references[i].conditionals, this.references[j].conditionals);
							if (kr3m.util.Util.equal(inter, this.references[j].conditionals))
							{
								this.references.splice(i--, 1);
								doContinue = true;
								break;
							}
						}
					}
					if (doContinue)
						continue;

					this.references[i].conditionals = this.references[i].conditionals.map(c => c.toUpperCase());
					for (var j = 0; j < this.references[i].conditionals.length; ++j)
						referenceText += "\n/" + "/# " + this.references[i].conditionals[j];
					referenceText += "\n/// <reference path=\"" + this.references[i].path + "\"/>";
					for (var j = this.references[i].conditionals.length - 1; j >= 0 ; --j)
						referenceText += "\n/" + "/# /" + this.references[i].conditionals[j];
				}
				referenceText = this.removeObsoleteConditionals(referenceText);
			}
			this.output = kr3m.util.StringEx.BOM + this.output.replace("REFERENCEPLACEHOLDER", referenceText);

			if (this.params.verbose)
				log(this.output);
			fsLib.writeFileSync(path, this.output);

			var autoformatter = new kr3m.tools.autoformatter.AutoFormatter();
			var afParams = new kr3m.tools.autoformatter.Parameters();
			afParams.rootPath = path;
			afParams.silent = true;
			autoformatter.runWithParameters(afParams);
		}
	}
}
